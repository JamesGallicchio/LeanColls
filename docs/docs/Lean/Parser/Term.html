<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Parser.Term</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Lean.Parser.Term";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Lean/Parser/Attr.html">Lean.Parser.Attr</a></li><li><a href="../.././Lean/Parser/Level.html">Lean.Parser.Level</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Parser.Term" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.commentBody"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.commentBody.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">parenthesizer</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.commentBody.formatter"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">formatter</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Command.docComment"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">docComment</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.tacticParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">tacticParser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.convParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">convParser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.sepByIndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepByIndentSemicolon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.sepBy1IndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepBy1IndentSemicolon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeq1Indented"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq1Indented</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeqBracketed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqBracketed</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSeqIndentGt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqIndentGt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.seq1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">seq1</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.darrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">darrow</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.semicolonOrLinebreak"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">semicolonOrLinebreak</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.byTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.byTactic'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optSemicolon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ident"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ident</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.num"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">num</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.scientific"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scientific</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.str"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">str</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.char"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">char</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.type"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">type</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.sort"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sort</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">prop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.hole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">hole</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.syntheticHole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">syntheticHole</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.omission"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">omission</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.sorry"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sorry</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.cdot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">cdot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.typeAscription"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeAscription</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.tuple"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">tuple</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.paren"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">paren</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.anonymousCtor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">anonymousCtor</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.fromTerm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fromTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.showRhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">showRhs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.sufficesDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sufficesDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.suffices"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">suffices</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.show"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">show</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstArrayRef"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstArrayRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstLVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstLVal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstField"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstField</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInstFieldAbbrev"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstFieldAbbrev</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optEllipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optEllipsis</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.structInst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.typeSpec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeSpec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.explicit"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.inaccessible"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">inaccessible</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderTactic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderDefault"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binderDefault.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span>.<span class="name">parenthesizer</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.explicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.implicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">implicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.strictImplicitLeftBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitLeftBracket</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.strictImplicitRightBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitRightBracket</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.strictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.instBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.bracketedBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.depArrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">depArrow</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.forall"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forall</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAltExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchDiscr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchDiscr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.trueVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trueVal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.falseVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">falseVal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.generalizingParam"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">generalizingParam</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.motive"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">motive</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.match"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">match</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.nomatch"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">nomatch</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.nofun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">nofun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.funImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funImplicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.funStrictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funStrictImplicitBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.funBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.basicFun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">basicFun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.optExprPrecedence"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optExprPrecedence</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.withAnonymousAntiquot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withAnonymousAntiquot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.leading_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">leading_parser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.trailing_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trailing_parser</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.borrowed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">borrowed</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.quotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">quotedName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.doubleQuotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">doubleQuotedName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letIdBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdBinder</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdLhs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letPatDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letPatDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letEqnsDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let_fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_fun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let_delayed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_delayed</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.let_tmp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_tmp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveId"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveId</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdLhs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveEqnsDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.have"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">have</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.haveI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveI</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letI</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.scoped"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scoped</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.local"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">local</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.attrKind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.attrInstance"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.attributes"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attributes</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Termination.terminationBy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">terminationBy</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Termination.terminationBy?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">terminationBy?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Termination.decreasingBy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">decreasingBy</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Termination.suffix"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">suffix</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letRecDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letRecDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecls</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letrec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.whereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">whereDecls</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchAltsWhereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltsWhereDecls</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.noindex"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noindex</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.unsafe"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unsafe</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binrel"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binrel_no_prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel_no_prop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.binop_lazy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop_lazy</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.leftact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">leftact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.rightact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">rightact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.unop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.forInMacro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.forInMacro'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.declName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">declName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.withDeclName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withDeclName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.typeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeOf</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ensureTypeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureTypeOf</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ensureExpectedType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureExpectedType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.noImplicitLambda"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noImplicitLambda</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.clear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">clear</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.waitIfTypeMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.waitIfTypeContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeContainsMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.waitIfContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfContainsMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.defaultOrOfNonempty"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">defaultOrOfNonempty</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.noErrorIfUnused"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noErrorIfUnused</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.namedArgument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedArgument</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.ellipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ellipsis</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.argument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">argument</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.app"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">app</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.proj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">proj</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.completion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">completion</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.arrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">arrow</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.identProjKind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">identProjKind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.isIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">isIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.explicitUniv"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitUniv</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.namedPattern"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedPattern</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.pipeProj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeProj</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.pipeCompletion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeCompletion</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.subst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">subst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.bracketedBinderF"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinderF</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.panic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">panic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.unreachable"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unreachable</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.dbgTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dbgTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.assert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">assert</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.macroArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.macroDollarArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroDollarArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.macroLastArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroLastArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.stateRefT"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">stateRefT</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.dynamicQuot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dynamicQuot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.dotIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dotIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.showTermElabImpl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">showTermElabImpl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchExprPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchExprAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprAlt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchExprElseAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprElseAlt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchExprAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.matchExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Term.letExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.quotSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quotSeq</span></a></div></nav><main>
<div class="decl" id="Lean.Parser.Command.commentBody"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L14-L15">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Command.commentBody" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Command.commentBody.parenthesizer"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L18-L18">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">parenthesizer</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer">Lean.PrettyPrinter.Parenthesizer</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer">Lean.Parser.Command.commentBody.parenthesizer</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer.visitToken">Lean.PrettyPrinter.Parenthesizer.visitToken</a></span></li></ul></details><details id="instances-for-list-Lean.Parser.Command.commentBody.parenthesizer" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Command.commentBody.formatter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L20-L20">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">commentBody</span>.<span class="name">formatter</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter">Lean.PrettyPrinter.Formatter</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter">Lean.Parser.Command.commentBody.formatter</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter.visitAtom">Lean.PrettyPrinter.Formatter.visitAtom</a> <a href="../.././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Command.commentBody.formatter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Command.docComment"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L27-L28">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Command.docComment"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Command</span>.<span class="name">docComment</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Command.docComment">docComment</a></code> parses a &quot;documentation comment&quot; like <code>/-- foo -/</code>. This is not treated like
a regular comment (that is, as whitespace); it is parsed and forms part of the syntax tree structure.</p><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Command.docComment">docComment</a></code> node contains a <code>/--</code> atom and then the remainder of the comment, <code>foo -/</code> in this
example. Use <code>TSyntax.getDocString</code> to extract the body text from a doc string syntax node.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Command.docComment" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.tacticParser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L35-L36">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.tacticParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">tacticParser</span></a></span><span class="decl_args">
<span class="fn">(rbp : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Nat">Nat</a> <span class="fn">0</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.tacticParser">Lean.Parser.tacticParser</a> <span class="fn">rbp</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.categoryParser">Lean.Parser.categoryParser</a> <span class="fn">`tactic</span> <span class="fn">rbp</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.tacticParser" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.convParser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L38-L39">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.convParser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">convParser</span></a></span><span class="decl_args">
<span class="fn">(rbp : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Nat">Nat</a> <span class="fn">0</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.convParser">Lean.Parser.convParser</a> <span class="fn">rbp</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.categoryParser">Lean.Parser.categoryParser</a> <span class="fn">`conv</span> <span class="fn">rbp</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.convParser" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.sepByIndentSemicolon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L53-L54">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepByIndentSemicolon</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>sepByIndentSemicolon(p)</code> parses a sequence of <code>p</code> optionally followed by <code>;</code>,
similar to <code>manyIndent(p &quot;;&quot;?)</code>, except that if two occurrences of <code>p</code> occur on the same line,
the <code>;</code> is mandatory. This is used by tactic parsing, so that</p><pre><code>example := by
  skip
  skip
</code></pre><p>is legal, but <code>by skip skip</code> is not - it must be written as <code>by skip; skip</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon">Lean.Parser.Tactic.sepByIndentSemicolon</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.sepByIndent">Lean.Parser.sepByIndent</a> <span class="fn">p</span> <span class="fn">&quot;; &quot;</span> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;; &quot;</span>)</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.sepByIndentSemicolon" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.sepBy1IndentSemicolon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L66-L67">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sepBy1IndentSemicolon</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>sepBy1IndentSemicolon(p)</code> parses a (nonempty) sequence of <code>p</code> optionally followed by <code>;</code>,
similar to <code>many1Indent(p &quot;;&quot;?)</code>, except that if two occurrences of <code>p</code> occur on the same line,
the <code>;</code> is mandatory. This is used by tactic parsing, so that</p><pre><code>example := by
  skip
  skip
</code></pre><p>is legal, but <code>by skip skip</code> is not - it must be written as <code>by skip; skip</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon">Lean.Parser.Tactic.sepBy1IndentSemicolon</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.sepBy1Indent">Lean.Parser.sepBy1Indent</a> <span class="fn">p</span> <span class="fn">&quot;; &quot;</span> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;; &quot;</span>)</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.sepBy1IndentSemicolon" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeq1Indented"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L73-L74">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq1Indented"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq1Indented</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeq1Indented" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeqBracketed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L77-L78">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqBracketed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqBracketed</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>The syntax <code>{ tacs }</code> is an alternative syntax for <code>· tacs</code>.
It runs the tactics in sequence, and fails if the goal is not solved.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeqBracketed" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L82-L83">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A sequence of tactics in brackets, or a delimiter-free indented sequence of tactics.
Delimiter-free indentation is determined by the <em>first</em> tactic of the sequence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSeqIndentGt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L88-L89">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqIndentGt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSeqIndentGt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Same as [<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq">tacticSeq</a></code>] but requires delimiter-free tactic sequence to have strict indentation.
The strict indentation requirement only apply to <em>nested</em> <code>by</code>s, as top-level <code>by</code>s do not have a
position set.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSeqIndentGt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.seq1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L92-L93">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.seq1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">seq1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.seq1">Lean.Parser.Tactic.seq1</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.node">Lean.Parser.node</a> <span class="fn">`Lean.Parser.Tactic.seq1</span>
    <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.sepBy1">Lean.Parser.sepBy1</a> <span class="fn">Lean.Parser.tacticParser</span> <span class="fn">&quot;;\n&quot;</span> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;;\n&quot;</span>)</span> <a href="../.././Init/Prelude.html#Bool.true">true</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.seq1" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.darrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L97-L97">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.darrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">darrow</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.darrow">Lean.Parser.darrow</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot; =&gt; &quot;</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.darrow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.semicolonOrLinebreak"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L98-L98">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">semicolonOrLinebreak</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak">Lean.Parser.semicolonOrLinebreak</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#HOrElse.hOrElse">HOrElse.hOrElse</a> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;;&quot;</span>)</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt;
    <span class="fn"><a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <span class="fn">Lean.Parser.checkLinebreakBefore</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Basic.html#Lean.Parser.pushNone">Lean.Parser.pushNone</a></span></span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.semicolonOrLinebreak" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Built-in-parsers">Built-in parsers <a class="hover-link" href="#Built-in-parsers">#</a></h1></div><div class="decl" id="Lean.Parser.Term.byTactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L106-L107">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.byTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>by tac</code> constructs a term of the expected type by running the tactic(s) <code>tac</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.byTactic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.byTactic'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L115-L116">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.byTactic'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">byTactic'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.byTactic'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optSemicolon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L119-L120">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optSemicolon</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon">Lean.Parser.Term.optSemicolon</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.ppDedent">Lean.Parser.ppDedent</a>
    <span class="fn">(<a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <a href="../.././Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak">Lean.Parser.semicolonOrLinebreak</a> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt;
      <span class="fn"><a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <a href="../.././Lean/Parser/Extra.html#Lean.Parser.ppLine">Lean.Parser.ppLine</a> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn">p</span></span></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.optSemicolon" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ident"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L123-L124">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ident"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ident</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ident">Lean.Parser.Term.ident</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a>)</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Extra.html#Lean.Parser.ident">Lean.Parser.ident</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.ident" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.num"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L125-L126">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.num"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">num</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.num">Lean.Parser.Term.num</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a>)</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Extra.html#Lean.Parser.numLit">Lean.Parser.numLit</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.num" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.scientific"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L127-L128">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.scientific"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scientific</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.scientific">Lean.Parser.Term.scientific</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a>)</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Extra.html#Lean.Parser.scientificLit">Lean.Parser.scientificLit</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.scientific" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.str"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L129-L130">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.str"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">str</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.str">Lean.Parser.Term.str</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a>)</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Extra.html#Lean.Parser.strLit">Lean.Parser.strLit</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.str" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.char"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L131-L132">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.char"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">char</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.char">Lean.Parser.Term.char</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.checkPrec">Lean.Parser.checkPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a>)</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Extra.html#Lean.Parser.charLit">Lean.Parser.charLit</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.char" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.type"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L134-L135">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.type"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">type</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A type universe. <code>Type ≡ Type 0</code>, <code>Type u ≡ Sort (u + 1)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.type" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.sort"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L137-L138">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sort"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sort</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A specific universe in Lean's infinite hierarchy of universes.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.sort" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.prop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L140-L141">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">prop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>The universe of propositions. <code>Prop ≡ Sort 0</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.prop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.hole"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L143-L144">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.hole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">hole</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A placeholder term, to be synthesized by unification.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.hole" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.syntheticHole"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L147-L148">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.syntheticHole"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">syntheticHole</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Parses a &quot;synthetic hole&quot;, that is, <code>?foo</code> or <code>?_</code>.
This syntax is used to construct named metavariables.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.syntheticHole" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.omission"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L157-L158">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.omission"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">omission</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>The <code>⋯</code> term denotes a term that was omitted by the pretty printer.
The presence of <code>⋯</code> in pretty printer output is controlled by the <code>pp.deepTerms</code> and <code>pp.proofs</code> options,
and these options can be further adjusted using <code>pp.deepTerms.threshold</code> and <code>pp.proofs.threshold</code>.</p><p>It is only meant to be used for pretty printing.
However, in case it is copied and pasted from the Infoview, <code>⋯</code> logs a warning and elaborates like <code>_</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.omission" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L159-L159">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderIdent">Lean.Parser.Term.binderIdent</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#HOrElse.hOrElse">HOrElse.hOrElse</a> <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ident">Lean.Parser.Term.ident</a> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.hole">Lean.Parser.Term.hole</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.sorry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L161-L162">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sorry"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sorry</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A temporary placeholder for a missing proof or value.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.sorry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.cdot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L167-L168">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.cdot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">cdot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A placeholder for an implicit lambda abstraction's variable. The lambda abstraction is scoped to the surrounding parentheses.
For example, <code>(· + ·)</code> is equivalent to <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x y =&gt; x + y</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.cdot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.typeAscription"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L175-L176">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.typeAscription"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeAscription</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Type ascription notation: <code>(0 : Int)</code> instructs Lean to process <code>0</code> as a value of type <code><a href="../.././Init/Data/Int/Basic.html#Int">Int</a></code>.
An empty type ascription <code>(e :)</code> elaborates <code>e</code> without the expected type.
This is occasionally useful when Lean's heuristics for filling arguments from the expected type
do not yield the right result.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.typeAscription" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.tuple"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L179-L180">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.tuple"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">tuple</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Tuple notation; <code>()</code> is short for <code><a href="../.././Init/Prelude.html#Unit.unit">Unit.unit</a></code>, <code>(a, b, c)</code> for <code><a href="../.././Init/Prelude.html#Prod.mk">Prod.mk</a> a (Prod.mk b c)</code>, etc.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.tuple" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.paren"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L191-L192">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.paren"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">paren</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Parentheses, used for grouping expressions (e.g., <code>a * (b + c)</code>).
Can also be used for creating simple functions when combined with <code>·</code>. Here are some examples:</p><ul>
<li><code>(· + 1)</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x =&gt; x + 1</code></li>
<li><code>(· + ·)</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x y =&gt; x + y</code></li>
<li><code>(f · a b)</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x =&gt; f x a b</code></li>
<li><code>(h (· + 1) ·)</code> is shorthand for <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x =&gt; h (fun y =&gt; y + 1) x</code></li>
<li>also applies to other parentheses-like notations such as <code>(·, 1)</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.paren" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.anonymousCtor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L200-L201">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">anonymousCtor</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>The <em>anonymous constructor</em> <code>⟨e, ...⟩</code> is equivalent to <code>c e ...</code> if the
expected type is an inductive type with a single constructor <code>c</code>.
If more terms are given than <code>c</code> has parameters, the remaining arguments
are turned into a new anonymous constructor application. For example,
<code>⟨a, b, c⟩ : α × (β × γ)</code> is equivalent to <code>⟨a, ⟨b, c⟩⟩</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.anonymousCtor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L202-L203">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optIdent">Lean.Parser.Term.optIdent</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.optional">Lean.Parser.optional</a>
    <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.atomic">Lean.Parser.atomic</a> <span class="fn">(<a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ident">Lean.Parser.Term.ident</a> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot; : &quot;</span></span></span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.optIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.fromTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L204-L205">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fromTerm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fromTerm</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.fromTerm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.showRhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L206-L206">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.showRhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">showRhs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.showRhs">Lean.Parser.Term.showRhs</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#HOrElse.hOrElse">HOrElse.hOrElse</a> <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fromTerm">Lean.Parser.Term.fromTerm</a> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.byTactic'">Lean.Parser.Term.byTactic'</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.showRhs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.sufficesDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L209-L210">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">sufficesDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl">sufficesDecl</a></code> represents everything that comes after the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.suffices">suffices</a></code> keyword:
an optional <code>x :</code>, then a term <code>ty</code>, then <code>from val</code> or <code>by tac</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.sufficesDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.suffices"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L211-L212">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.suffices"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">suffices</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.suffices" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.show"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L213-L213">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.show"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">show</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.show" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstArrayRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L214-L215">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstArrayRef"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstArrayRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstArrayRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstLVal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L216-L218">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstLVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstLVal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstLVal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstField"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L219-L220">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstField"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstField</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstField" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInstFieldAbbrev"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L221-L223">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldAbbrev"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInstFieldAbbrev</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInstFieldAbbrev" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optEllipsis"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L224-L225">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optEllipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optEllipsis</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.optEllipsis" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.structInst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L235-L239">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.structInst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">structInst</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Structure instance. <code>{ x := e, ... }</code> assigns <code>e</code> to field <code>x</code>, which may be
inherited. If <code>e</code> is itself a variable called <code>x</code>, it can be elided:
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> y =&gt; { x := 1, y }</code>.
A <em>structure update</em> of an existing value can be given via <code>with</code>:
<code>{ point with x := 1 }</code>.
The structure type can be specified if not inferable:
<code>{ x := 1, y := 2 : Point }</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.structInst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.typeSpec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L240-L240">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.typeSpec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeSpec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.typeSpec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L241-L241">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optType</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optType">Lean.Parser.Term.optType</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.optional">Lean.Parser.optional</a> <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.typeSpec">Lean.Parser.Term.typeSpec</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.optType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.explicit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L246-L247">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.explicit"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>@x</code> disables automatic insertion of implicit parameters of the constant <code>x</code>.
<code>@e</code> for any term <code>e</code> also disables the insertion of implicit lambdas at this position.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.explicit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.inaccessible"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L252-L253">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.inaccessible"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">inaccessible</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>.(e)</code> marks an &quot;inaccessible pattern&quot;, which does not influence evaluation of the pattern match, but may be necessary for type-checking.
In contrast to regular patterns, <code>e</code> may be an arbitrary term of the appropriate type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.inaccessible" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L254-L255">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderType</span></a></span><span class="decl_args">
<span class="fn">(requireType : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderTactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L256-L257">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderTactic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderTactic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderTactic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderDefault"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L258-L259">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderDefault"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderDefault" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binderDefault.parenthesizer"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L262-L269">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binderDefault.parenthesizer"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binderDefault</span>.<span class="name">parenthesizer</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer">Lean.PrettyPrinter.Parenthesizer</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binderDefault.parenthesizer" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.explicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L275-L276">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.explicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Explicit binder, like <code>(x y : A)</code> or <code>(x y)</code>.
Default values can be specified using <code>(x : A := v)</code> syntax, and tactics using <code>(x : A := by tac)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.explicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.implicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L286-L287">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.implicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">implicitBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Implicit binder, like <code>{x y : A}</code> or <code>{x y}</code>.
In regular applications, whenever all parameters before it have been specified,
then a <code>_</code> placeholder is automatically inserted for this parameter.
Implicit parameters should be able to be determined from the other arguments and the return type
by unification.</p><p>In <code>@</code> explicit mode, implicit binders behave like explicit binders.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.implicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.strictImplicitLeftBracket"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L288-L288">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitLeftBracket</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.strictImplicitLeftBracket" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.strictImplicitRightBracket"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L289-L289">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitRightBracket</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.strictImplicitRightBracket" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.strictImplicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L303-L305">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">strictImplicitBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Strict-implicit binder, like <code>⦃x y : A⦄</code> or <code>⦃x y⦄</code>.
In contrast to <code>{ ... }</code> implicit binders, strict-implicit binders do not automatically insert
a <code>_</code> placeholder until at least one subsequent explicit parameter is specified.
Do <em>not</em> use strict-implicit binders unless there is a subsequent explicit parameter.
Assuming this rule is followed, for fully applied expressions implicit and strict-implicit binders have the same behavior.</p><p>Example: If <code>h : ∀ ⦃x : A⦄, x ∈ s → p x</code> and <code>hs : y ∈ s</code>,
then <code>h</code> by itself elaborates to itself without inserting <code>_</code> for the <code>x : A</code> parameter,
and <code>h hs</code> has type <code>p y</code>.
In contrast, if <code>h' : ∀ {x : A}, x ∈ s → p x</code>, then <code>h</code> by itself elaborates to have type <code>?m ∈ s → p ?m</code>
with <code>?m</code> a fresh metavariable.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.strictImplicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.instBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L313-L314">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Instance-implicit binder, like <code>[C]</code> or <code>[inst : C]</code>.
In regular applications without <code>@</code> explicit mode, it is automatically inserted
and solved for by typeclass inference for the specified class <code>C</code>.
In <code>@</code> explicit mode, if <code>_</code> is used for an an instance-implicit parameter, then it is still solved for by typeclass inference;
use <code>(_)</code> to inhibit this and have it be solved for by unification instead, like an implicit argument.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.instBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.bracketedBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L321-L324">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinder</span></a></span><span class="decl_args">
<span class="fn">(requireType : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder">bracketedBinder</a></code> matches any kind of binder group that uses some kind of brackets:</p><ul>
<li>An explicit binder like <code>(x y : A)</code></li>
<li>An implicit binder like <code>{x y : A}</code></li>
<li>A strict implicit binder, <code>⦃y z : A⦄</code> or its ASCII alternative <code>{{y z : A}}</code></li>
<li>An instance binder <code>[A]</code> or <code>[x : A]</code> (multiple variables are not allowed here)</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.bracketedBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.depArrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L341-L342">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.depArrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">depArrow</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.depArrow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.forall"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L345-L348">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.forall"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forall</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.forall" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L350-L355">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlt</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a> <span class="fn">Lean.Parser.termParser</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchAlt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchAltExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L359-L359">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Useful for syntax quotations. Note that generic patterns such as <code>`(matchAltExpr| | ... =&gt; $rhs)</code> should also
work with other <code>rhsParser</code>s (of arity 1).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr">Lean.Parser.Term.matchAltExpr</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">Lean.Parser.Term.matchAlt</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchAltExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L361-L362">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Coe.html#Coe">Coe</a> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.matchAltExpr</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.matchAlt</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean">Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">coe</span> := <span class="fn">fun (<span class="fn">stx</span> : <span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.matchAltExpr</span></span>) =&gt; <span class="fn">{ <span class="fn">raw</span> := <span class="fn"><span class="fn">stx</span>.raw</span> }</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchAlts"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L364-L365">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAlts</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a> <span class="fn">Lean.Parser.termParser</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchAlts" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchDiscr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L369-L370">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchDiscr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr">matchDiscr</a></code> matches a &quot;match discriminant&quot;, either <code>h : tm</code> or <code>tm</code>, used in <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code> as
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a> h1 : e1, e2, h3 : e3 with ...</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchDiscr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.trueVal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L372-L372">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.trueVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trueVal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.trueVal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.falseVal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L373-L373">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.falseVal"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">falseVal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.falseVal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.generalizingParam"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L374-L376">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">generalizingParam</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.generalizingParam" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.motive"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L378-L380">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.motive"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">motive</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.motive" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.match"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L415-L417">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">match</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Pattern matching. <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a> e, ... with | p, ... =&gt; f | ...</code> matches each given
term <code>e</code> against each pattern <code>p</code> of a match alternative. When all patterns
of an alternative match, the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code> term evaluates to the value of the
corresponding right-hand side <code>f</code> with the pattern variables bound to the
respective matched values.
If used as <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a> h : e, ... with | p, ... =&gt; f | ...</code>, <code>h : e = p</code> is available
within <code>f</code>.</p><p>When not constructing a proof, <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code> does not automatically substitute variables
matched on in dependent variables' types. Use <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a> (generalizing := true) ...</code> to
enforce this.</p><p>Syntax quotations can also be used in a pattern match.
This matches a <code>Syntax</code> value against quotations, pattern variables, or <code>_</code>.</p><p>Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.</p><p><code>Syntax.atom</code>s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in</p><pre><code class="language-lean">syntax &quot;c&quot; (&quot;foo&quot; &lt;|&gt; &quot;bar&quot;) ...
</code></pre><p><code>foo</code> and <code>bar</code> are indistinguishable during matching, but in</p><pre><code class="language-lean">syntax foo := &quot;foo&quot;
syntax &quot;c&quot; (foo &lt;|&gt; &quot;bar&quot;) ...
</code></pre><p>they are not.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.match" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.nomatch"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L423-L423">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.nomatch"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">nomatch</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Empty match/ex falso. <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.nomatch">nomatch</a> e</code> is of arbitrary type <code>α : Sort u</code> if
Lean can show that an empty set of patterns is exhaustive given <code>e</code>'s type,
e.g. because it has no constructors.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.nomatch" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.nofun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L425-L425">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.nofun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">nofun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.nofun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.funImplicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L427-L428">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funImplicitBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.funImplicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.funStrictImplicitBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L429-L433">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funStrictImplicitBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.funStrictImplicitBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.funBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L434-L436">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.funBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">funBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.funBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.basicFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L439-L440">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.basicFun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">basicFun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.basicFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.fun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L441-L442">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">fun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.fun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.optExprPrecedence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L444-L444">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">optExprPrecedence</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence">Lean.Parser.Term.optExprPrecedence</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Extra.html#Lean.Parser.optional">Lean.Parser.optional</a>
    <span class="fn">(<a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.atomic">Lean.Parser.atomic</a> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;:&quot;</span>)</span>)</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt;
      <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.termParser">Lean.Parser.termParser</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.optExprPrecedence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.withAnonymousAntiquot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L445-L447">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withAnonymousAntiquot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.withAnonymousAntiquot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.leading_parser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L448-L449">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.leading_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">leading_parser</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.leading_parser" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.trailing_parser"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L450-L451">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">trailing_parser</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.trailing_parser" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.borrowed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L453-L454">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.borrowed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">borrowed</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.borrowed" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.quotedName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L456-L456">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.quotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">quotedName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A literal of type <code>Name</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.quotedName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.doubleQuotedName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L463-L464">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">doubleQuotedName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A resolved name literal. Evaluates to the full name of the given constant if
existent in the current context, or else fails.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.doubleQuotedName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letIdBinder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L466-L468">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdBinder</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letIdBinder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letIdLhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L470-L473">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdLhs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letIdLhs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letIdDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L474-L475">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letIdDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letIdDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letPatDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L476-L477">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letPatDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letPatDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letEqnsDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L494-L495">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letEqnsDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letEqnsDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L500-L504">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letDecl">letDecl</a></code> matches the body of a let declaration <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> f x1 x2 := e</code>,
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> pat := e</code> (where <code>pat</code> is an arbitrary term) or <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> f | pat1 =&gt; e1 | pat2 =&gt; e2 ...</code>
(a pattern matching declaration), except for the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> keyword itself.
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> rec</code> declarations are not handled here.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L526-L527">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> is used to declare a local definition. Example:</p><pre><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> x := 1
<a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> y := x + 1
x + y
</code></pre><p>Since functions are first class citizens in Lean, you can use <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> to declare
local functions too.</p><pre><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> double := <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.fun">fun</a> x =&gt; 2*x
double (double 3)
</code></pre><p>For recursive definitions, you should use <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> rec</code>.
You can also perform pattern matching using <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code>. For example,
assume <code>p</code> has type <code><a href="../.././Init/Prelude.html#Nat">Nat</a> × <a href="../.././Init/Prelude.html#Nat">Nat</a></code>, then you can write</p><pre><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> (x, y) := p
x + y
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.let" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let_fun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L533-L534">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_fun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun">let_fun</a> x := v; b</code> is syntax sugar for <code>(fun x =&gt; b) v</code>.
It is very similar to <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> x := v; b</code>, but they are not equivalent.
In <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun">let_fun</a></code>, the value <code>v</code> has been abstracted away and cannot be accessed in <code>b</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.let_fun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let_delayed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L538-L539">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_delayed"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_delayed</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_delayed">let_delayed</a> x := v; b</code> is similar to <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a> x := v; b</code>, but <code>b</code> is elaborated before <code>v</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.let_delayed" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.let_tmp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L544-L545">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_tmp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">let_tmp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code>-declaration that is only included in the elaborated term if variable is still there.
It is often used when building macros.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.let_tmp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L547-L548">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveId"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveId</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveIdLhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L550-L551">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdLhs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveIdLhs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveIdDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L552-L553">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveIdDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveIdDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveIdDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveEqnsDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L554-L555">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveEqnsDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveEqnsDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveEqnsDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L559-L560">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveDecl">haveDecl</a></code> matches the body of a have declaration: <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> := e</code>, <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> f x1 x2 := e</code>,
<code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> pat := e</code> (where <code>pat</code> is an arbitrary term) or <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a> f | pat1 =&gt; e1 | pat2 =&gt; e2 ...</code>
(a pattern matching declaration), except for the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a></code> keyword itself.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.have"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L561-L562">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">have</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.have" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.haveI"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L564-L565">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">haveI</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.haveI">haveI</a></code> behaves like <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.have">have</a></code>, but inlines the value instead of producing a <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun">let_fun</a></code> term.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.haveI" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letI"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L567-L568">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letI</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letI">letI</a></code> behaves like <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code>, but inlines the value instead of producing a <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let_fun">let_fun</a></code> term.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letI" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.scoped"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L570-L570">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.scoped"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">scoped</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.scoped" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.local"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L571-L571">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.local"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">local</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.local" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.attrKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L573-L573">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attrKind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attrKind">attrKind</a></code> matches <code>(&quot;scoped&quot; &lt;|&gt; &quot;local&quot;)?</code>, used before an attribute like <code>@[local simp]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.attrKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.attrInstance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L574-L574">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attrInstance"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attrInstance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.attrInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.attributes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L576-L577">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.attributes"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">attributes</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.attributes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Termination.terminationBy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L610-L614">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">terminationBy</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Specify a termination argument for recursive functions.</p><pre><code>termination_by a - b
</code></pre><p>indicates that termination of the currently defined recursive function follows
because the difference between the arguments <code>a</code> and <code>b</code> decreases.</p><p>If the fuction takes further argument after the colon, you can name them as follows:</p><pre><code>def example (a : Nat) : <a href="../.././Init/Prelude.html#Nat">Nat</a> → <a href="../.././Init/Prelude.html#Nat">Nat</a> → <a href="../.././Init/Prelude.html#Nat">Nat</a> :=
termination_by b c =&gt; a - b
</code></pre><p>By default, a <code>termination_by</code> clause will cause the function to be constructed using well-founded
recursion. The syntax <code>termination_by structural a</code> (or <code>termination_by structural _ c =&gt; c</code>)
indicates the the function is expected to be structural recursive on the argument. In this case
the body of the <code>termination_by</code> clause must be one of the function's parameters.</p><p>If omitted, a termination argument will be inferred. If written as <code>termination_by?</code>,
the inferrred termination argument will be suggested.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Termination.terminationBy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Termination.terminationBy?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L617-L618">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">terminationBy?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Specify a termination argument for recursive functions.</p><pre><code>termination_by a - b
</code></pre><p>indicates that termination of the currently defined recursive function follows
because the difference between the arguments <code>a</code> and <code>b</code> decreases.</p><p>If the fuction takes further argument after the colon, you can name them as follows:</p><pre><code>def example (a : Nat) : <a href="../.././Init/Prelude.html#Nat">Nat</a> → <a href="../.././Init/Prelude.html#Nat">Nat</a> → <a href="../.././Init/Prelude.html#Nat">Nat</a> :=
termination_by b c =&gt; a - b
</code></pre><p>By default, a <code>termination_by</code> clause will cause the function to be constructed using well-founded
recursion. The syntax <code>termination_by structural a</code> (or <code>termination_by structural _ c =&gt; c</code>)
indicates the the function is expected to be structural recursive on the argument. In this case
the body of the <code>termination_by</code> clause must be one of the function's parameters.</p><p>If omitted, a termination argument will be inferred. If written as <code>termination_by?</code>,
the inferrred termination argument will be suggested.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Termination.terminationBy?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Termination.decreasingBy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L629-L630">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Termination.decreasingBy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">decreasingBy</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Manually prove that the termination argument (as specified with <code>termination_by</code> or inferred)
decreases at each recursive call.</p><p>By default, the tactic <code>decreasing_tactic</code> is used.</p><p>Forces the use of well-founded recursion and is hence incompatible with
<code>termination_by structural</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Termination.decreasingBy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Termination.suffix"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L635-L636">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Termination.suffix"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Termination</span>.<span class="name">suffix</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Termination hints are <code>termination_by</code> and <code>decreasing_by</code>, in that order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Termination.suffix" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letRecDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L643-L644">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl">letRecDecl</a></code> matches the body of a let-rec declaration: a doc comment, attributes, and then
a let declaration without the <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.let">let</a></code> keyword, such as <code>/-- foo -/ @[simp] bar := 1</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letRecDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letRecDecls"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L646-L647">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letRecDecls</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls">letRecDecls</a></code> matches <code>letRecDecl,+</code>, a comma-separated list of let-rec declarations (see <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl">letRecDecl</a></code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letRecDecls" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letrec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L649-L651">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letrec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letrec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.whereDecls"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L654-L655">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.whereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">whereDecls</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.whereDecls" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchAltsWhereDecls"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L658-L659">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchAltsWhereDecls</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchAltsWhereDecls" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.noindex"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L661-L662">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.noindex"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noindex</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.noindex" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.unsafe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L675-L675">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unsafe"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unsafe</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unsafe">unsafe</a> t : α</code> is an expression constructor which allows using unsafe declarations inside the
body of <code>t : α</code>, by creating an auxiliary definition containing <code>t</code> and using <code>implementedBy</code> to
wrap it in a safe interface. It is required that <code>α</code> is nonempty for this to be sound,
but even beyond that, an <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unsafe">unsafe</a></code> block should be carefully inspected for memory safety because
the compiler is unable to guarantee the safety of the operation.</p><p>For example, the <code>evalExpr</code> function is unsafe, because the compiler cannot guarantee that when
you call <code>evalExpr Foo ``Foo e</code> that the type <code>Foo</code> corresponds to the name <code>Foo</code>, but in a
particular use case, we can ensure this, so <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unsafe">unsafe</a> (evalExpr Foo ``Foo e)</code> is a correct usage.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.unsafe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binrel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L678-L679">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binrel"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>binrel% r a b</code> elaborates <code>r a b</code> as a binary relation using the type propogation protocol in <code><a href="../.././Lean/Elab/Extra.html">Lean.Elab.Extra</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binrel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binrel_no_prop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L681-L682">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binrel_no_prop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>binrel_no_prop% r a b</code> is similar to <code>binrel% r a b</code>, but it coerces <code>Prop</code> arguments into <code><a href="../.././Init/Prelude.html#Bool">Bool</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binrel_no_prop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L684-L685">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>binop% f a b</code> elaborates <code>f a b</code> as a binary operation using the type propogation protocol in <code><a href="../.././Lean/Elab/Extra.html">Lean.Elab.Extra</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.binop_lazy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L687-L688">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">binop_lazy</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>binop_lazy%</code> is similar to <code>binop% f a b</code>, but it wraps <code>b</code> as a function from <code><a href="../.././Init/Prelude.html#Unit">Unit</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.binop_lazy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.leftact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L691-L692">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.leftact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">leftact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>leftact% f a b</code> elaborates <code>f a b</code> as a left action using the type propogation protocol in <code><a href="../.././Lean/Elab/Extra.html">Lean.Elab.Extra</a></code>.
In particular, it is like a unary operation with a fixed parameter <code>a</code>, where only the right argument <code>b</code> participates in the operator coercion elaborator.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.leftact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.rightact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L695-L696">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.rightact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">rightact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>rightact% f a b</code> elaborates <code>f a b</code> as a right action using the type propogation protocol in <code><a href="../.././Lean/Elab/Extra.html">Lean.Elab.Extra</a></code>.
In particular, it is like a unary operation with a fixed parameter <code>b</code>, where only the left argument <code>a</code> participates in the operator coercion elaborator.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.rightact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.unop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L698-L699">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>unop% f a</code> elaborates <code>f a</code> as a unary operation using the type propogation protocol in <code><a href="../.././Lean/Elab/Extra.html">Lean.Elab.Extra</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.unop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.forInMacro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L701-L702">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.forInMacro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.forInMacro" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.forInMacro'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L703-L704">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">forInMacro'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.forInMacro'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.declName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L707-L707">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.declName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">declName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A macro which evaluates to the name of the currently elaborating declaration.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.declName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.withDeclName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L715-L716">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.withDeclName"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">withDeclName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><ul>
<li><code>with_decl_name% <a href="../.././Init/Prelude.html#id">id</a> e</code> elaborates <code>e</code> in a context while changing the effective
declaration name to <code><a href="../.././Init/Prelude.html#id">id</a></code>.</li>
<li><code>with_decl_name% ?id e</code> does the same, but resolves <code><a href="../.././Init/Prelude.html#id">id</a></code> as a new definition name
(appending the current namespaces).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.withDeclName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.typeOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L717-L718">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.typeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">typeOf</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.typeOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ensureTypeOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L719-L720">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureTypeOf</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.ensureTypeOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ensureExpectedType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L721-L722">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ensureExpectedType</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.ensureExpectedType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.noImplicitLambda"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L723-L724">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noImplicitLambda</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.noImplicitLambda" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.clear"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L730-L731">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.clear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">clear</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>clear% x; e</code> elaborates <code>x</code> after clearing the free variable <code>x</code> from the local context.
If <code>x</code> cannot be cleared (due to dependencies), it will keep <code>x</code> without failing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.clear" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L733-L734">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letMVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.waitIfTypeMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L735-L736">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.waitIfTypeMVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.waitIfTypeContainsMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L737-L738">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfTypeContainsMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.waitIfTypeContainsMVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.waitIfContainsMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L739-L740">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">waitIfContainsMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.waitIfContainsMVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.defaultOrOfNonempty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L742-L743">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">defaultOrOfNonempty</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.defaultOrOfNonempty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.noErrorIfUnused"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L749-L750">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">noErrorIfUnused</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Helper parser for marking <code><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.match">match</a></code>-alternatives that should not trigger errors if unused.
We use them to implement <code>macro_rules</code> and <code>elab_rules</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.noErrorIfUnused" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.namedArgument"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L752-L753">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.namedArgument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedArgument</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.namedArgument" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.ellipsis"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L754-L755">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.ellipsis"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">ellipsis</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.ellipsis" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.argument"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L756-L759">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.argument"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">argument</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.argument" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.app"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L763-L763">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.app"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">app</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.app">Lean.Parser.Term.app</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.trailingNode">Lean.Parser.trailingNode</a> <span class="fn">`Lean.Parser.Term.app</span> <a href="../.././Lean/Parser/Types.html#Lean.Parser.leadPrec">Lean.Parser.leadPrec</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a>
    <span class="fn">(<a href="../.././Lean/Parser/Extra.html#Lean.Parser.many1">Lean.Parser.many1</a> <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.argument">Lean.Parser.Term.argument</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.app" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.proj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L777-L778">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.proj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">proj</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p>The <em>extended field notation</em> <code>e.f</code> is roughly short for <code>T.f e</code> where <code>T</code> is the type of <code>e</code>.
More precisely,</p><ul>
<li>if <code>e</code> is of a function type, <code>e.f</code> is translated to <code>Function.f (p := e)</code>
where <code>p</code> is the first explicit parameter of function type</li>
<li>if <code>e</code> is of a named type <code>T ...</code> and there is a declaration <code>T.f</code> (possibly from <code>export</code>),
<code>e.f</code> is translated to <code>T.f (p := e)</code> where <code>p</code> is the first explicit parameter of type <code>T ...</code></li>
<li>otherwise, if <code>e</code> is of a structure type,
the above is repeated for every base type of the structure.</li>
</ul><p>The field index notation <code>e.i</code>, where <code>i</code> is a positive number,
is short for accessing the <code>i</code>-th field (1-indexed) of <code>e</code> if it is of a structure type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.proj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.completion"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L779-L780">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.completion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">completion</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.completion">Lean.Parser.Term.completion</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.trailingNode">Lean.Parser.trailingNode</a> <span class="fn">`Lean.Parser.Term.completion</span> <span class="fn">1024</span> <span class="fn">0</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#HAndThen.hAndThen">HAndThen.hAndThen</a> <span class="fn">Lean.Parser.checkNoWsBefore</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot;.&quot;</span></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.completion" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.arrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L781-L782">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.arrow"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">arrow</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.arrow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.identProjKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L793-L793">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.identProjKind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">identProjKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.Name">Lake.Name</a></div></div><p>Syntax kind for syntax nodes representing the field of a projection in the <code>InfoTree</code>.
Specifically, the <code>InfoTree</code> node for a projection <code>s.f</code> contains a child <code>InfoTree</code> node
with syntax <code>(Syntax.node .none <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.identProjKind">identProjKind</a> #[`f])</code>.</p><p>This is necessary because projection syntax cannot always be detected purely syntactically
(<code>s.f</code> may refer to either the identifier <code>s.f</code> or a projection <code>s.f</code> depending on
the available context).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.identProjKind">Lean.Parser.Term.identProjKind</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">`Lean.Parser.Term.identProj</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.identProjKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.isIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L795-L797">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.isIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">isIdent</span></a></span><span class="decl_args">
<span class="fn">(stx : <a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.isIdent">Lean.Parser.Term.isIdent</a> <span class="fn">stx</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn">stx</span>.isAntiquot</span> <a href="../.././Init/Prelude.html#or">||</a> <span class="fn"><span class="fn">stx</span>.isIdent</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.isIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.explicitUniv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L800-L803">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">explicitUniv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>x.{u, ...}</code> explicitly specifies the universes <code>u, ...</code> of the constant <code>x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.explicitUniv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.namedPattern"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L806-L809">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.namedPattern"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">namedPattern</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>x@e</code> or <code>x@h:e</code> matches the pattern <code>e</code> and binds its value to the identifier <code>x</code>.
If present, the identifier <code>h</code> is bound to a proof of <code>x = e</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.namedPattern" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.pipeProj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L815-L816">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.pipeProj"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeProj</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>e |&gt;.x</code> is a shorthand for <code>(e).x</code>.
It is especially useful for avoiding parentheses with repeated applications.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.pipeProj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.pipeCompletion"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L817-L818">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">pipeCompletion</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion">Lean.Parser.Term.pipeCompletion</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.trailingNode">Lean.Parser.trailingNode</a> <span class="fn">`Lean.Parser.Term.pipeCompletion</span> <a href="../.././Lean/Parser/Types.html#Lean.Parser.minPrec">Lean.Parser.minPrec</a> <span class="fn">0</span> <span class="fn">(<a href="../.././Lean/Parser/Basic.html#Lean.Parser.symbol">Lean.Parser.symbol</a> <span class="fn">&quot; |&gt;.&quot;</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.pipeCompletion" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.subst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L832-L833">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.subst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">subst</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.TrailingParser">Lean.Parser.TrailingParser</a></div></div><p><code>h ▸ e</code> is a macro built on top of <code><a href="../.././Init/Prelude.html#Eq.rec">Eq.rec</a></code> and <code><a href="../.././Init/Prelude.html#Eq.symm">Eq.symm</a></code> definitions.
Given <code>h : a = b</code> and <code>e : p a</code>, the term <code>h ▸ e</code> has type <code>p b</code>.
You can also view <code>h ▸ e</code> as a &quot;type casting&quot; operation
where you change the type of <code>e</code> by using <code>h</code>.</p><p>The macro tries both orientations of <code>h</code>. If the context provides an
expected type, it rewrites the expeced type, else it rewrites the type of e`.</p><p>See the Chapter &quot;Quantifiers and Equality&quot; in the manual
&quot;Theorem Proving in Lean&quot; for additional information.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.subst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.bracketedBinderF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L835-L835">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">bracketedBinderF</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF">Lean.Parser.Term.bracketedBinderF</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">Lean.Parser.Term.bracketedBinder</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.bracketedBinderF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L836-L836">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Coe.html#Coe">Coe</a> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.bracketedBinderF</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.bracketedBinder</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1">Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_lean_1</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">coe</span> := <span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.bracketedBinderF</span></span>) =&gt; <span class="fn">{ <span class="fn">raw</span> := <span class="fn"><span class="fn">s</span>.raw</span> }</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Term.panic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L846-L847">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.panic"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">panic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>panic! msg</code> formally evaluates to <code>@Inhabited.default α</code> if the expected type
<code>α</code> implements <code><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a></code>.
At runtime, <code>msg</code> and the file position are printed to stderr unless the C
function <code>lean_set_panic_messages(false)</code> has been executed before. If the C
function <code>lean_set_exit_on_panic(true)</code> has been executed before, the process is
then aborted.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.panic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.unreachable"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L849-L850">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.unreachable"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">unreachable</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A shorthand for <code>panic! &quot;unreachable code has been reached&quot;</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.unreachable" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.dbgTrace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L855-L857">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dbgTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>dbg_trace e; body</code> evaluates to <code>body</code> and prints <code>e</code> (which can be an
interpolated string literal) to stderr. It should only be used for debugging.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.dbgTrace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.assert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L859-L860">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.assert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">assert</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p><code>assert! <a href="../.././Init/Prelude.html#cond">cond</a></code> panics if <code><a href="../.././Init/Prelude.html#cond">cond</a></code> evaluates to <code>false</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.assert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.macroArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L862-L862">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroArg">Lean.Parser.Term.macroArg</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Parser/Basic.html#Lean.Parser.termParser">Lean.Parser.termParser</a> <a href="../.././Lean/Parser/Types.html#Lean.Parser.maxPrec">Lean.Parser.maxPrec</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.macroArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.macroDollarArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L863-L863">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroDollarArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.macroDollarArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.macroLastArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L864-L864">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">macroLastArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg">Lean.Parser.Term.macroLastArg</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#HOrElse.hOrElse">HOrElse.hOrElse</a> <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg">Lean.Parser.Term.macroDollarArg</a> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <a href="../.././Lean/Parser/Term.html#Lean.Parser.Term.macroArg">Lean.Parser.Term.macroArg</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Term.macroLastArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.stateRefT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L867-L868">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.stateRefT"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">stateRefT</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.stateRefT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.dynamicQuot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L870-L871">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dynamicQuot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.dynamicQuot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.dotIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L873-L874">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.dotIdent"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">dotIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.dotIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.showTermElabImpl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L879-L880">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.showTermElabImpl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">showTermElabImpl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Implementation of the <code>show_term</code> term elaborator.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.showTermElabImpl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p><code>match_expr</code> support.</p></div><div class="decl" id="Lean.Parser.Term.matchExprPat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L886-L886">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchExprPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchExprPat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchExprAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L887-L887">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchExprAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprAlt</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchExprAlt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchExprElseAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L888-L888">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchExprElseAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprElseAlt</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchExprElseAlt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchExprAlts"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L889-L892">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchExprAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExprAlts</span></a></span><span class="decl_args">
<span class="fn">(rhsParser : <a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchExprAlts" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.matchExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L893-L894">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.matchExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">matchExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.matchExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Term.letExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L896-L897">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Term.letExpr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Term</span>.<span class="name">letExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Term.letExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.quot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L901-L902">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.quot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.quotSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Lean/Parser/Term.lean#L903-L904">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">quotSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.quotSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>