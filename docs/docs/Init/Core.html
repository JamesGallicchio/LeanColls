<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href=".././style.css"></link><link rel="icon" href=".././favicon.svg"></link><link rel="mask-icon" href=".././favicon.svg" color="#000000"></link><link rel="prefetch" href=".././/declarations/declaration-data.bmp" as="image"></link><title>Init.Core</title><script defer="true" src=".././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT=".././";</script><script>const MODULE_NAME="Init.Core";</script><script type="module" src=".././jump-src.js"></script><script type="module" src=".././search.js"></script><script type="module" src=".././expand-nav.js"></script><script type="module" src=".././how-about.js"></script><script type="module" src=".././instances.js"></script><script type="module" src=".././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Init</span>.<span class="name">Core</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href=".././Init/Prelude.html">Init.Prelude</a></li><li><a href=".././Init/SizeOf.html">Init.SizeOf</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Core" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#inline"><span class="name">inline</span></a></div><div class="nav_link"><a class="break_within" href="#id_def"><span class="name">id_def</span></a></div><div class="nav_link"><a class="break_within" href="#flip"><span class="name">flip</span></a></div><div class="nav_link"><a class="break_within" href="#Function.const_apply"><span class="name">Function</span>.<span class="name">const_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Function.comp_apply"><span class="name">Function</span>.<span class="name">comp_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Function.comp_def"><span class="name">Function</span>.<span class="name">comp_def</span></a></div><div class="nav_link"><a class="break_within" href="#Empty.elim"><span class="name">Empty</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqEmpty"><span class="name">instDecidableEqEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#PEmpty.elim"><span class="name">PEmpty</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqPEmpty"><span class="name">instDecidableEqPEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk"><span class="name">Thunk</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk.pure"><span class="name">Thunk</span>.<span class="name">pure</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk.get"><span class="name">Thunk</span>.<span class="name">get</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk.map"><span class="name">Thunk</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk.bind"><span class="name">Thunk</span>.<span class="name">bind</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk.sizeOf_eq"><span class="name">Thunk</span>.<span class="name">sizeOf_eq</span></a></div><div class="nav_link"><a class="break_within" href="#thunkCoe"><span class="name">thunkCoe</span></a></div><div class="nav_link"><a class="break_within" href="#Iff"><span class="name">Iff</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.mp"><span class="name">Iff</span>.<span class="name">mp</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.mpr"><span class="name">Iff</span>.<span class="name">mpr</span></a></div><div class="nav_link"><a class="break_within" href="#«term_&lt;-&gt;_»"><span class="name">«term_&lt;-&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_↔_»"><span class="name">«term_↔_»</span></a></div><div class="nav_link"><a class="break_within" href="#Sum"><span class="name">Sum</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⊕_»"><span class="name">«term_⊕_»</span></a></div><div class="nav_link"><a class="break_within" href="#PSum"><span class="name">PSum</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⊕'_»"><span class="name">«term_⊕'_»</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedPSum"><span class="name">instInhabitedPSum</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedPSum_1"><span class="name">instInhabitedPSum_1</span></a></div><div class="nav_link"><a class="break_within" href="#Sigma"><span class="name">Sigma</span></a></div><div class="nav_link"><a class="break_within" href="#PSigma"><span class="name">PSigma</span></a></div><div class="nav_link"><a class="break_within" href="#Exists"><span class="name">Exists</span></a></div><div class="nav_link"><a class="break_within" href="#ForInStep"><span class="name">ForInStep</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedForInStep"><span class="name">instInhabitedForInStep</span></a></div><div class="nav_link"><a class="break_within" href="#ForIn"><span class="name">ForIn</span></a></div><div class="nav_link"><a class="break_within" href="#ForIn'"><span class="name">ForIn'</span></a></div><div class="nav_link"><a class="break_within" href="#DoResultPRBC"><span class="name">DoResultPRBC</span></a></div><div class="nav_link"><a class="break_within" href="#DoResultPR"><span class="name">DoResultPR</span></a></div><div class="nav_link"><a class="break_within" href="#DoResultBC"><span class="name">DoResultBC</span></a></div><div class="nav_link"><a class="break_within" href="#DoResultSBC"><span class="name">DoResultSBC</span></a></div><div class="nav_link"><a class="break_within" href="#HasEquiv"><span class="name">HasEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#«term_≈_»"><span class="name">«term_≈_»</span></a></div><div class="nav_link"><a class="break_within" href="#HasSubset"><span class="name">HasSubset</span></a></div><div class="nav_link"><a class="break_within" href="#HasSSubset"><span class="name">HasSSubset</span></a></div><div class="nav_link"><a class="break_within" href="#Superset"><span class="name">Superset</span></a></div><div class="nav_link"><a class="break_within" href="#SSuperset"><span class="name">SSuperset</span></a></div><div class="nav_link"><a class="break_within" href="#Union"><span class="name">Union</span></a></div><div class="nav_link"><a class="break_within" href="#Inter"><span class="name">Inter</span></a></div><div class="nav_link"><a class="break_within" href="#SDiff"><span class="name">SDiff</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⊆_»"><span class="name">«term_⊆_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⊂_»"><span class="name">«term_⊂_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⊇_»"><span class="name">«term_⊇_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⊃_»"><span class="name">«term_⊃_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_∪_»"><span class="name">«term_∪_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_∩_»"><span class="name">«term_∩_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_\_»"><span class="name">«term_\_»</span></a></div><div class="nav_link"><a class="break_within" href="#EmptyCollection"><span class="name">EmptyCollection</span></a></div><div class="nav_link"><a class="break_within" href="#«term{}»"><span class="name">«term{}»</span></a></div><div class="nav_link"><a class="break_within" href="#«term∅»"><span class="name">«term∅»</span></a></div><div class="nav_link"><a class="break_within" href="#Insert"><span class="name">Insert</span></a></div><div class="nav_link"><a class="break_within" href="#Singleton"><span class="name">Singleton</span></a></div><div class="nav_link"><a class="break_within" href="#LawfulSingleton"><span class="name">LawfulSingleton</span></a></div><div class="nav_link"><a class="break_within" href="#LawfulSingleton.insert_emptyc_eq"><span class="name">LawfulSingleton</span>.<span class="name">insert_emptyc_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Sep"><span class="name">Sep</span></a></div><div class="nav_link"><a class="break_within" href="#Task"><span class="name">Task</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedTask"><span class="name">instInhabitedTask</span></a></div><div class="nav_link"><a class="break_within" href="#instNonemptyTask"><span class="name">instNonemptyTask</span></a></div><div class="nav_link"><a class="break_within" href="#Task.Priority"><span class="name">Task</span>.<span class="name">Priority</span></a></div><div class="nav_link"><a class="break_within" href="#Task.Priority.default"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Task.Priority.max"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">max</span></a></div><div class="nav_link"><a class="break_within" href="#Task.Priority.dedicated"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">dedicated</span></a></div><div class="nav_link"><a class="break_within" href="#Task.spawn"><span class="name">Task</span>.<span class="name">spawn</span></a></div><div class="nav_link"><a class="break_within" href="#Task.map"><span class="name">Task</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Task.bind"><span class="name">Task</span>.<span class="name">bind</span></a></div><div class="nav_link"><a class="break_within" href="#NonScalar"><span class="name">NonScalar</span></a></div><div class="nav_link"><a class="break_within" href="#PNonScalar"><span class="name">PNonScalar</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.add_zero"><span class="name">Nat</span>.<span class="name">add_zero</span></a></div><div class="nav_link"><a class="break_within" href="#optParam_eq"><span class="name">optParam_eq</span></a></div><div class="nav_link"><a class="break_within" href="#strictOr"><span class="name">strictOr</span></a></div><div class="nav_link"><a class="break_within" href="#strictAnd"><span class="name">strictAnd</span></a></div><div class="nav_link"><a class="break_within" href="#bne"><span class="name">bne</span></a></div><div class="nav_link"><a class="break_within" href="#«term_!=_»"><span class="name">«term_!=_»</span></a></div><div class="nav_link"><a class="break_within" href="#LawfulBEq"><span class="name">LawfulBEq</span></a></div><div class="nav_link"><a class="break_within" href="#LawfulBEq.eq_of_beq"><span class="name">LawfulBEq</span>.<span class="name">eq_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#LawfulBEq.rfl"><span class="name">LawfulBEq</span>.<span class="name">rfl</span></a></div><div class="nav_link"><a class="break_within" href="#instLawfulBEqBool"><span class="name">instLawfulBEqBool</span></a></div><div class="nav_link"><a class="break_within" href="#instLawfulBEq"><span class="name">instLawfulBEq</span></a></div><div class="nav_link"><a class="break_within" href="#instLawfulBEqChar"><span class="name">instLawfulBEqChar</span></a></div><div class="nav_link"><a class="break_within" href="#instLawfulBEqString"><span class="name">instLawfulBEqString</span></a></div><div class="nav_link"><a class="break_within" href="#trivial"><span class="name">trivial</span></a></div><div class="nav_link"><a class="break_within" href="#mt"><span class="name">mt</span></a></div><div class="nav_link"><a class="break_within" href="#not_false"><span class="name">not_false</span></a></div><div class="nav_link"><a class="break_within" href="#not_not_intro"><span class="name">not_not_intro</span></a></div><div class="nav_link"><a class="break_within" href="#proof_irrel"><span class="name">proof_irrel</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.mp"><span class="name">Eq</span>.<span class="name">mp</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.mpr"><span class="name">Eq</span>.<span class="name">mpr</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.substr"><span class="name">Eq</span>.<span class="name">substr</span></a></div><div class="nav_link"><a class="break_within" href="#cast_eq"><span class="name">cast_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Ne"><span class="name">Ne</span></a></div><div class="nav_link"><a class="break_within" href="#«term_≠_»"><span class="name">«term_≠_»</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.intro"><span class="name">Ne</span>.<span class="name">intro</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.elim"><span class="name">Ne</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.irrefl"><span class="name">Ne</span>.<span class="name">irrefl</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.symm"><span class="name">Ne</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#ne_comm"><span class="name">ne_comm</span></a></div><div class="nav_link"><a class="break_within" href="#false_of_ne"><span class="name">false_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#ne_false_of_self"><span class="name">ne_false_of_self</span></a></div><div class="nav_link"><a class="break_within" href="#ne_true_of_not"><span class="name">ne_true_of_not</span></a></div><div class="nav_link"><a class="break_within" href="#true_ne_false"><span class="name">true_ne_false</span></a></div><div class="nav_link"><a class="break_within" href="#false_ne_true"><span class="name">false_ne_true</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.of_not_eq_true"><span class="name">Bool</span>.<span class="name">of_not_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.of_not_eq_false"><span class="name">Bool</span>.<span class="name">of_not_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#ne_of_beq_false"><span class="name">ne_of_beq_false</span></a></div><div class="nav_link"><a class="break_within" href="#beq_false_of_ne"><span class="name">beq_false_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.ndrec"><span class="name">HEq</span>.<span class="name">ndrec</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.ndrecOn"><span class="name">HEq</span>.<span class="name">ndrecOn</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.elim"><span class="name">HEq</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.subst"><span class="name">HEq</span>.<span class="name">subst</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.symm"><span class="name">HEq</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#heq_of_eq"><span class="name">heq_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.trans"><span class="name">HEq</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#heq_of_heq_of_eq"><span class="name">heq_of_heq_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_of_eq_of_heq"><span class="name">heq_of_eq_of_heq</span></a></div><div class="nav_link"><a class="break_within" href="#type_eq_of_heq"><span class="name">type_eq_of_heq</span></a></div><div class="nav_link"><a class="break_within" href="#eqRec_heq"><span class="name">eqRec_heq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_of_eqRec_eq"><span class="name">heq_of_eqRec_eq</span></a></div><div class="nav_link"><a class="break_within" href="#cast_heq"><span class="name">cast_heq</span></a></div><div class="nav_link"><a class="break_within" href="#iff_iff_implies_and_implies"><span class="name">iff_iff_implies_and_implies</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.refl"><span class="name">Iff</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.rfl"><span class="name">Iff</span>.<span class="name">rfl</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.of_eq"><span class="name">Iff</span>.<span class="name">of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.trans"><span class="name">Iff</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#instTransIff"><span class="name">instTransIff</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.comm"><span class="name">Eq</span>.<span class="name">comm</span></a></div><div class="nav_link"><a class="break_within" href="#eq_comm"><span class="name">eq_comm</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.symm"><span class="name">Iff</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.comm"><span class="name">Iff</span>.<span class="name">comm</span></a></div><div class="nav_link"><a class="break_within" href="#iff_comm"><span class="name">iff_comm</span></a></div><div class="nav_link"><a class="break_within" href="#And.symm"><span class="name">And</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#And.comm"><span class="name">And</span>.<span class="name">comm</span></a></div><div class="nav_link"><a class="break_within" href="#and_comm"><span class="name">and_comm</span></a></div><div class="nav_link"><a class="break_within" href="#Or.symm"><span class="name">Or</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#Or.comm"><span class="name">Or</span>.<span class="name">comm</span></a></div><div class="nav_link"><a class="break_within" href="#or_comm"><span class="name">or_comm</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.elim"><span class="name">Exists</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#decide_true_eq_true"><span class="name">decide_true_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#decide_false_eq_false"><span class="name">decide_false_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#toBoolUsing"><span class="name">toBoolUsing</span></a></div><div class="nav_link"><a class="break_within" href="#toBoolUsing_eq_true"><span class="name">toBoolUsing_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#ofBoolUsing_eq_true"><span class="name">ofBoolUsing_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#ofBoolUsing_eq_false"><span class="name">ofBoolUsing_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableTrue"><span class="name">instDecidableTrue</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableFalse"><span class="name">instDecidableFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.byCases"><span class="name">Decidable</span>.<span class="name">byCases</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.em"><span class="name">Decidable</span>.<span class="name">em</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.byContradiction"><span class="name">Decidable</span>.<span class="name">byContradiction</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.of_not_not"><span class="name">Decidable</span>.<span class="name">of_not_not</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.not_and_iff_or_not"><span class="name">Decidable</span>.<span class="name">not_and_iff_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#decidable_of_decidable_of_iff"><span class="name">decidable_of_decidable_of_iff</span></a></div><div class="nav_link"><a class="break_within" href="#decidable_of_decidable_of_eq"><span class="name">decidable_of_decidable_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableForall"><span class="name">instDecidableForall</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableIff"><span class="name">instDecidableIff</span></a></div><div class="nav_link"><a class="break_within" href="#if_pos"><span class="name">if_pos</span></a></div><div class="nav_link"><a class="break_within" href="#if_neg"><span class="name">if_neg</span></a></div><div class="nav_link"><a class="break_within" href="#iteInduction"><span class="name">iteInduction</span></a></div><div class="nav_link"><a class="break_within" href="#dif_pos"><span class="name">dif_pos</span></a></div><div class="nav_link"><a class="break_within" href="#dif_neg"><span class="name">dif_neg</span></a></div><div class="nav_link"><a class="break_within" href="#dif_eq_if"><span class="name">dif_eq_if</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableIte"><span class="name">instDecidableIte</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableDite"><span class="name">instDecidableDite</span></a></div><div class="nav_link"><a class="break_within" href="#noConfusionTypeEnum"><span class="name">noConfusionTypeEnum</span></a></div><div class="nav_link"><a class="break_within" href="#noConfusionEnum"><span class="name">noConfusionEnum</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedProp"><span class="name">instInhabitedProp</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedNonScalar"><span class="name">instInhabitedNonScalar</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedTrue"><span class="name">instInhabitedTrue</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedPNonScalar"><span class="name">instInhabitedPNonScalar</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedForInStep_1"><span class="name">instInhabitedForInStep_1</span></a></div><div class="nav_link"><a class="break_within" href="#nonempty_of_exists"><span class="name">nonempty_of_exists</span></a></div><div class="nav_link"><a class="break_within" href="#Subsingleton"><span class="name">Subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Subsingleton.allEq"><span class="name">Subsingleton</span>.<span class="name">allEq</span></a></div><div class="nav_link"><a class="break_within" href="#Subsingleton.elim"><span class="name">Subsingleton</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#Subsingleton.helim"><span class="name">Subsingleton</span>.<span class="name">helim</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingleton"><span class="name">instSubsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonEmpty"><span class="name">instSubsingletonEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonPEmpty"><span class="name">instSubsingletonPEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonProd"><span class="name">instSubsingletonProd</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonDecidable"><span class="name">instSubsingletonDecidable</span></a></div><div class="nav_link"><a class="break_within" href="#recSubsingleton"><span class="name">recSubsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Equivalence"><span class="name">Equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#Equivalence.refl"><span class="name">Equivalence</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#Equivalence.symm"><span class="name">Equivalence</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#Equivalence.trans"><span class="name">Equivalence</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#emptyRelation"><span class="name">emptyRelation</span></a></div><div class="nav_link"><a class="break_within" href="#Subrelation"><span class="name">Subrelation</span></a></div><div class="nav_link"><a class="break_within" href="#InvImage"><span class="name">InvImage</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen"><span class="name">Relation</span>.<span class="name">TransGen</span></a></div><div class="nav_link"><a class="break_within" href="#TC"><span class="name">TC</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.existsOfSubtype"><span class="name">Subtype</span>.<span class="name">existsOfSubtype</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.eq"><span class="name">Subtype</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.eta"><span class="name">Subtype</span>.<span class="name">eta</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.instDecidableEq"><span class="name">Subtype</span>.<span class="name">instDecidableEq</span></a></div><div class="nav_link"><a class="break_within" href="#Sum.inhabitedLeft"><span class="name">Sum</span>.<span class="name">inhabitedLeft</span></a></div><div class="nav_link"><a class="break_within" href="#Sum.inhabitedRight"><span class="name">Sum</span>.<span class="name">inhabitedRight</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqSum"><span class="name">instDecidableEqSum</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedProd"><span class="name">instInhabitedProd</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedMProd"><span class="name">instInhabitedMProd</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedPProd"><span class="name">instInhabitedPProd</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqProd"><span class="name">instDecidableEqProd</span></a></div><div class="nav_link"><a class="break_within" href="#instBEqProd"><span class="name">instBEqProd</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.lexLt"><span class="name">Prod</span>.<span class="name">lexLt</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.lexLtDec"><span class="name">Prod</span>.<span class="name">lexLtDec</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.lexLt_def"><span class="name">Prod</span>.<span class="name">lexLt_def</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.eta"><span class="name">Prod</span>.<span class="name">eta</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.map"><span class="name">Prod</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.map_apply"><span class="name">Prod</span>.<span class="name">map_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.map_fst"><span class="name">Prod</span>.<span class="name">map_fst</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.map_snd"><span class="name">Prod</span>.<span class="name">map_snd</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.of_psigma_prop"><span class="name">Exists</span>.<span class="name">of_psigma_prop</span></a></div><div class="nav_link"><a class="break_within" href="#ex_of_PSigma"><span class="name">ex_of_PSigma</span></a></div><div class="nav_link"><a class="break_within" href="#PSigma.eta"><span class="name">PSigma</span>.<span class="name">eta</span></a></div><div class="nav_link"><a class="break_within" href="#PUnit.subsingleton"><span class="name">PUnit</span>.<span class="name">subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#PUnit.eq_punit"><span class="name">PUnit</span>.<span class="name">eq_punit</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonPUnit"><span class="name">instSubsingletonPUnit</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedPUnit"><span class="name">instInhabitedPUnit</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqPUnit"><span class="name">instDecidableEqPUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Setoid"><span class="name">Setoid</span></a></div><div class="nav_link"><a class="break_within" href="#Setoid.iseqv"><span class="name">Setoid</span>.<span class="name">iseqv</span></a></div><div class="nav_link"><a class="break_within" href="#instHasEquivOfSetoid"><span class="name">instHasEquivOfSetoid</span></a></div><div class="nav_link"><a class="break_within" href="#Setoid.refl"><span class="name">Setoid</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#Setoid.symm"><span class="name">Setoid</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#Setoid.trans"><span class="name">Setoid</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#propext"><span class="name">propext</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.propIntro"><span class="name">Eq</span>.<span class="name">propIntro</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqOfIff"><span class="name">instDecidableEqOfIff</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.succ.inj"><span class="name">Nat</span>.<span class="name">succ</span>.<span class="name">inj</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.succ.injEq"><span class="name">Nat</span>.<span class="name">succ</span>.<span class="name">injEq</span></a></div><div class="nav_link"><a class="break_within" href="#beq_iff_eq"><span class="name">beq_iff_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Not.elim"><span class="name">Not</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#And.elim"><span class="name">And</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.elim"><span class="name">Iff</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.subst"><span class="name">Iff</span>.<span class="name">subst</span></a></div><div class="nav_link"><a class="break_within" href="#Not.intro"><span class="name">Not</span>.<span class="name">intro</span></a></div><div class="nav_link"><a class="break_within" href="#Not.imp"><span class="name">Not</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#not_congr"><span class="name">not_congr</span></a></div><div class="nav_link"><a class="break_within" href="#not_not_not"><span class="name">not_not_not</span></a></div><div class="nav_link"><a class="break_within" href="#iff_of_true"><span class="name">iff_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#iff_of_false"><span class="name">iff_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#iff_true_left"><span class="name">iff_true_left</span></a></div><div class="nav_link"><a class="break_within" href="#iff_true_right"><span class="name">iff_true_right</span></a></div><div class="nav_link"><a class="break_within" href="#iff_false_left"><span class="name">iff_false_left</span></a></div><div class="nav_link"><a class="break_within" href="#iff_false_right"><span class="name">iff_false_right</span></a></div><div class="nav_link"><a class="break_within" href="#of_iff_true"><span class="name">of_iff_true</span></a></div><div class="nav_link"><a class="break_within" href="#iff_true_intro"><span class="name">iff_true_intro</span></a></div><div class="nav_link"><a class="break_within" href="#eq_iff_true_of_subsingleton"><span class="name">eq_iff_true_of_subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#not_of_iff_false"><span class="name">not_of_iff_false</span></a></div><div class="nav_link"><a class="break_within" href="#iff_false_intro"><span class="name">iff_false_intro</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff_false_intro"><span class="name">not_iff_false_intro</span></a></div><div class="nav_link"><a class="break_within" href="#not_true"><span class="name">not_true</span></a></div><div class="nav_link"><a class="break_within" href="#not_false_iff"><span class="name">not_false_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.to_iff"><span class="name">Eq</span>.<span class="name">to_iff</span></a></div><div class="nav_link"><a class="break_within" href="#iff_of_eq"><span class="name">iff_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#neq_of_not_iff"><span class="name">neq_of_not_iff</span></a></div><div class="nav_link"><a class="break_within" href="#iff_iff_eq"><span class="name">iff_iff_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_iff_iff"><span class="name">eq_iff_iff</span></a></div><div class="nav_link"><a class="break_within" href="#eq_self_iff_true"><span class="name">eq_self_iff_true</span></a></div><div class="nav_link"><a class="break_within" href="#ne_self_iff_false"><span class="name">ne_self_iff_false</span></a></div><div class="nav_link"><a class="break_within" href="#false_of_true_iff_false"><span class="name">false_of_true_iff_false</span></a></div><div class="nav_link"><a class="break_within" href="#false_of_true_eq_false"><span class="name">false_of_true_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#true_eq_false_of_false"><span class="name">true_eq_false_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#iff_def"><span class="name">iff_def</span></a></div><div class="nav_link"><a class="break_within" href="#iff_def'"><span class="name">iff_def'</span></a></div><div class="nav_link"><a class="break_within" href="#true_iff_false"><span class="name">true_iff_false</span></a></div><div class="nav_link"><a class="break_within" href="#false_iff_true"><span class="name">false_iff_true</span></a></div><div class="nav_link"><a class="break_within" href="#iff_not_self"><span class="name">iff_not_self</span></a></div><div class="nav_link"><a class="break_within" href="#heq_self_iff_true"><span class="name">heq_self_iff_true</span></a></div><div class="nav_link"><a class="break_within" href="#not_not_of_not_imp"><span class="name">not_not_of_not_imp</span></a></div><div class="nav_link"><a class="break_within" href="#not_of_not_imp"><span class="name">not_of_not_imp</span></a></div><div class="nav_link"><a class="break_within" href="#imp_not_self"><span class="name">imp_not_self</span></a></div><div class="nav_link"><a class="break_within" href="#imp_intro"><span class="name">imp_intro</span></a></div><div class="nav_link"><a class="break_within" href="#imp_imp_imp"><span class="name">imp_imp_imp</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_right"><span class="name">imp_iff_right</span></a></div><div class="nav_link"><a class="break_within" href="#imp_true_iff"><span class="name">imp_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#false_imp_iff"><span class="name">false_imp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#true_imp_iff"><span class="name">true_imp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#imp_self"><span class="name">imp_self</span></a></div><div class="nav_link"><a class="break_within" href="#imp_false"><span class="name">imp_false</span></a></div><div class="nav_link"><a class="break_within" href="#imp.swap"><span class="name">imp</span>.<span class="name">swap</span></a></div><div class="nav_link"><a class="break_within" href="#imp_not_comm"><span class="name">imp_not_comm</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr_left"><span class="name">imp_congr_left</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr_right"><span class="name">imp_congr_right</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr_ctx"><span class="name">imp_congr_ctx</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr"><span class="name">imp_congr</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_not"><span class="name">imp_iff_not</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.sound"><span class="name">Quot</span>.<span class="name">sound</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.liftBeta"><span class="name">Quot</span>.<span class="name">liftBeta</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.indBeta"><span class="name">Quot</span>.<span class="name">indBeta</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.liftOn"><span class="name">Quot</span>.<span class="name">liftOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.inductionOn"><span class="name">Quot</span>.<span class="name">inductionOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.exists_rep"><span class="name">Quot</span>.<span class="name">exists_rep</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.indep"><span class="name">Quot</span>.<span class="name">indep</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.indepCoherent"><span class="name">Quot</span>.<span class="name">indepCoherent</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.liftIndepPr1"><span class="name">Quot</span>.<span class="name">liftIndepPr1</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.rec"><span class="name">Quot</span>.<span class="name">rec</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.recOn"><span class="name">Quot</span>.<span class="name">recOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.recOnSubsingleton"><span class="name">Quot</span>.<span class="name">recOnSubsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.hrecOn"><span class="name">Quot</span>.<span class="name">hrecOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient"><span class="name">Quotient</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.mk"><span class="name">Quotient</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.mk'"><span class="name">Quotient</span>.<span class="name">mk'</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.sound"><span class="name">Quotient</span>.<span class="name">sound</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.lift"><span class="name">Quotient</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.ind"><span class="name">Quotient</span>.<span class="name">ind</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.liftOn"><span class="name">Quotient</span>.<span class="name">liftOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.inductionOn"><span class="name">Quotient</span>.<span class="name">inductionOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.exists_rep"><span class="name">Quotient</span>.<span class="name">exists_rep</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.rec"><span class="name">Quotient</span>.<span class="name">rec</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.recOn"><span class="name">Quotient</span>.<span class="name">recOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.recOnSubsingleton"><span class="name">Quotient</span>.<span class="name">recOnSubsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.hrecOn"><span class="name">Quotient</span>.<span class="name">hrecOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.lift₂"><span class="name">Quotient</span>.<span class="name">lift₂</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.liftOn₂"><span class="name">Quotient</span>.<span class="name">liftOn₂</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.ind₂"><span class="name">Quotient</span>.<span class="name">ind₂</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.inductionOn₂"><span class="name">Quotient</span>.<span class="name">inductionOn₂</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.inductionOn₃"><span class="name">Quotient</span>.<span class="name">inductionOn₃</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.exact"><span class="name">Quotient</span>.<span class="name">exact</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.recOnSubsingleton₂"><span class="name">Quotient</span>.<span class="name">recOnSubsingleton₂</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqQuotientOfDecidableEquiv"><span class="name">instDecidableEqQuotientOfDecidableEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#funext"><span class="name">funext</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonForall"><span class="name">instSubsingletonForall</span></a></div><div class="nav_link"><a class="break_within" href="#Squash"><span class="name">Squash</span></a></div><div class="nav_link"><a class="break_within" href="#Squash.mk"><span class="name">Squash</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#Squash.ind"><span class="name">Squash</span>.<span class="name">ind</span></a></div><div class="nav_link"><a class="break_within" href="#Squash.lift"><span class="name">Squash</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonSquash"><span class="name">instSubsingletonSquash</span></a></div><div class="nav_link"><a class="break_within" href="#Antisymm"><span class="name">Antisymm</span></a></div><div class="nav_link"><a class="break_within" href="#Antisymm.antisymm"><span class="name">Antisymm</span>.<span class="name">antisymm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.trustCompiler"><span class="name">Lean</span>.<span class="name">trustCompiler</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.reduceBool"><span class="name">Lean</span>.<span class="name">reduceBool</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.reduceNat"><span class="name">Lean</span>.<span class="name">reduceNat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.ofReduceBool"><span class="name">Lean</span>.<span class="name">ofReduceBool</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.ofReduceNat"><span class="name">Lean</span>.<span class="name">ofReduceNat</span></a></div><div class="nav_link"><a class="break_within" href="#ge_iff_le"><span class="name">ge_iff_le</span></a></div><div class="nav_link"><a class="break_within" href="#gt_iff_lt"><span class="name">gt_iff_lt</span></a></div><div class="nav_link"><a class="break_within" href="#le_of_eq_of_le"><span class="name">le_of_eq_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#le_of_le_of_eq"><span class="name">le_of_le_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#lt_of_eq_of_lt"><span class="name">lt_of_eq_of_lt</span></a></div><div class="nav_link"><a class="break_within" href="#lt_of_lt_of_eq"><span class="name">lt_of_lt_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Associative"><span class="name">Std</span>.<span class="name">Associative</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Associative.assoc"><span class="name">Std</span>.<span class="name">Associative</span>.<span class="name">assoc</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Commutative"><span class="name">Std</span>.<span class="name">Commutative</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Commutative.comm"><span class="name">Std</span>.<span class="name">Commutative</span>.<span class="name">comm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.IdempotentOp"><span class="name">Std</span>.<span class="name">IdempotentOp</span></a></div><div class="nav_link"><a class="break_within" href="#Std.IdempotentOp.idempotent"><span class="name">Std</span>.<span class="name">IdempotentOp</span>.<span class="name">idempotent</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LeftIdentity"><span class="name">Std</span>.<span class="name">LeftIdentity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LawfulLeftIdentity"><span class="name">Std</span>.<span class="name">LawfulLeftIdentity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LawfulLeftIdentity.left_id"><span class="name">Std</span>.<span class="name">LawfulLeftIdentity</span>.<span class="name">left_id</span></a></div><div class="nav_link"><a class="break_within" href="#Std.RightIdentity"><span class="name">Std</span>.<span class="name">RightIdentity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LawfulRightIdentity"><span class="name">Std</span>.<span class="name">LawfulRightIdentity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LawfulRightIdentity.right_id"><span class="name">Std</span>.<span class="name">LawfulRightIdentity</span>.<span class="name">right_id</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Identity"><span class="name">Std</span>.<span class="name">Identity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LawfulIdentity"><span class="name">Std</span>.<span class="name">LawfulIdentity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.LawfulCommIdentity"><span class="name">Std</span>.<span class="name">LawfulCommIdentity</span></a></div><div class="nav_link"><a class="break_within" href="#Std.instCommutativeOr"><span class="name">Std</span>.<span class="name">instCommutativeOr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.instCommutativeAnd"><span class="name">Std</span>.<span class="name">instCommutativeAnd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.instCommutativeIff"><span class="name">Std</span>.<span class="name">instCommutativeIff</span></a></div></nav><main>
<div class="decl" id="inline"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L20-L20">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#inline"><span class="name">inline</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><code><a href=".././Init/Core.html#inline">inline</a> (f x)</code> is an indication to the compiler to inline the definition of <code>f</code>
at the application site itself (by comparison to the <code>@[inline]</code> attribute,
which applies to all applications of the function).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#inline">inline</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></li></ul></details><details id="instances-for-list-inline" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="id_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L22-L22">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#id_def"><span class="name">id_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#id">id</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="flip"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L30-L31">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#flip"><span class="name">flip</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{φ : <a href=".././foundational_types.html">Sort</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">φ</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">α</span> → <span class="fn">φ</span></span></span></div></div><p><code><a href=".././Init/Core.html#flip">flip</a> f a b</code> is <code>f b a</code>. It is useful for &quot;point-free&quot; programming,
since it can sometimes be used to avoid introducing variables.
For example, <code>(·&lt;·)</code> is the less-than relation,
and <code><a href=".././Init/Core.html#flip">flip</a> (·&lt;·)</code> is the greater-than relation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#flip">flip</a> <span class="fn">f</span> <span class="fn">b</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span></span></li></ul></details><details id="instances-for-list-flip" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Function.const_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L33-L33">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Function.const_apply"><span class="name">Function</span>.<span class="name">const_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Function.const">Function.const</a> <span class="fn">α</span> <span class="fn">y</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Function.comp_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L35-L35">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Function.comp_apply"><span class="name">Function</span>.<span class="name">comp_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <a href=".././Init/Prelude.html#Function.comp">∘</a> <span class="fn">g</span>)</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">g</span> <span class="fn">x</span>)</span></span></span></div></div></div></div><div class="decl" id="Function.comp_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L37-L37">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Function.comp_def"><span class="name">Function</span>.<span class="name">comp_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href=".././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <a href=".././Init/Prelude.html#Function.comp">∘</a> <span class="fn">g</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">g</span> <span class="fn">x</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Empty.elim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L47-L47">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Empty.elim"><span class="name">Empty</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Empty">Empty</a> → <span class="fn">C</span></span></div></div><p><code><a href=".././Init/Core.html#Empty.elim">Empty.elim</a> : <a href=".././Init/Prelude.html#Empty">Empty</a> → C</code> says that a value of any type can be constructed from
<code><a href=".././Init/Prelude.html#Empty">Empty</a></code>. This can be thought of as a compiler-checked assertion that a code path is unreachable.</p><p>This is a non-dependent variant of <code><a href=".././Init/Prelude.html#Empty.rec">Empty.rec</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">t</span>.elim</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Empty.rec">Empty.rec</a> <span class="fn">(fun (<span class="fn">x</span> : <a href=".././Init/Prelude.html#Empty">Empty</a>) =&gt; <span class="fn">C</span>)</span> <span class="fn">t</span></span></span></li></ul></details><details id="instances-for-list-Empty.elim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L50-L50">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqEmpty"><span class="name">instDecidableEqEmpty</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#Empty">Empty</a></span></div></div><p>Decidable equality for Empty</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#instDecidableEqEmpty">instDecidableEqEmpty</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a</span>.elim</span></span></li></ul></details></div></div><div class="decl" id="PEmpty.elim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L58-L58">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PEmpty.elim"><span class="name">PEmpty</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#PEmpty">PEmpty</a> → <span class="fn">C</span></span></div></div><p><code><a href=".././Init/Core.html#PEmpty.elim">PEmpty.elim</a> : <a href=".././Init/Prelude.html#Empty">Empty</a> → C</code> says that a value of any type can be constructed from
<code><a href=".././Init/Prelude.html#PEmpty">PEmpty</a></code>. This can be thought of as a compiler-checked assertion that a code path is unreachable.</p><p>This is a non-dependent variant of <code><a href=".././Init/Prelude.html#PEmpty.rec">PEmpty.rec</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">a</span>.elim</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">nomatch <span class="fn">a</span></span></span></li></ul></details><details id="instances-for-list-PEmpty.elim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqPEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L61-L61">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqPEmpty"><span class="name">instDecidableEqPEmpty</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#PEmpty">PEmpty</a></span></div></div><p>Decidable equality for PEmpty</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#instDecidableEqPEmpty">instDecidableEqPEmpty</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a</span>.elim</span></span></li></ul></details></div></div><div class="decl" id="Thunk"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L67-L72">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk"><span class="name">Thunk</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Thunks are &quot;lazy&quot; values that are evaluated when first accessed using <code>Thunk.get/map/bind</code>.
The value is then stored and not recomputed for all further accesses.</p><ul class="structure_fields" id="Thunk.mk"><li id="Thunk.fn" class="structure_field"><div class="structure_field_info">fn : <span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">α</span></span></div></li></ul><details id="instances-for-list-Thunk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Thunk.pure"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L77-L78">source</a></div><div class="attributes">@[extern  lean_thunk_pure]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk.pure"><span class="name">Thunk</span>.<span class="name">pure</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span></div></div><p>Store a value in a thunk. Note that the value has already been computed, so there is no laziness.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Thunk.pure">Thunk.pure</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">fn</span> := <span class="fn">fun (<span class="fn">x</span> : <a href=".././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn">a</span></span> }</span></span></li></ul></details><details id="instances-for-list-Thunk.pure" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Thunk.get"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L86-L87">source</a></div><div class="attributes">@[extern  lean_thunk_get_own]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk.get"><span class="name">Thunk</span>.<span class="name">get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Forces a thunk to extract the value. This will cache the result,
so a second call to the same function will return the value in O(1)
instead of calling the stored getter function.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x</span>.get</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">x</span>.fn</span> <a href=".././Init/Prelude.html#Unit.unit">()</a></span></span></li></ul></details><details id="instances-for-list-Thunk.get" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Thunk.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L90-L91">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk.map"><span class="name">Thunk</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">β</span></span></div></div><p>Map a function over a thunk.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Thunk.map">Thunk.map</a> <span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">fn</span> := <span class="fn">fun (<span class="fn">x_1</span> : <a href=".././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.get</span></span></span> }</span></span></li></ul></details><details id="instances-for-list-Thunk.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Thunk.bind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L93-L94">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk.bind"><span class="name">Thunk</span>.<span class="name">bind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">β</span></span></div></div><p>Constructs a thunk that applies <code>f</code> to the result of <code>x</code> when forced.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.bind</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">fn</span> := <span class="fn">fun (<span class="fn">x_1</span> : <a href=".././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">x</span>.get</span>)</span>.get</span></span> }</span></span></li></ul></details><details id="instances-for-list-Thunk.bind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Thunk.sizeOf_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L96-L97">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk.sizeOf_eq"><span class="name">Thunk</span>.<span class="name">sizeOf_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/SizeOf.html#SizeOf">SizeOf</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/SizeOf.html#SizeOf.sizeOf">sizeOf</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">1</span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href=".././Init/SizeOf.html#SizeOf.sizeOf">sizeOf</a> <span class="fn"><span class="fn">a</span>.get</span></span></span></span></div></div></div></div><div class="decl" id="thunkCoe"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L99-L101">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#thunkCoe"><span class="name">thunkCoe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Coe.html#CoeTail">CoeTail</a> <span class="fn">α</span> <span class="fn">(<a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">thunkCoe</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">coe</span> := <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn">{ <span class="fn">fn</span> := <span class="fn">fun (<span class="fn">x</span> : <a href=".././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn">a</span></span> }</span></span> }</span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="definitions">definitions <a class="hover-link" href="#definitions">#</a></h1></div><div class="decl" id="Iff"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L114-L120">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff"><span class="name">Iff</span></a></span><span class="decl_args">
<span class="fn">(a : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>If and only if, or logical bi-implication. <code>a ↔ b</code> means that <code>a</code> implies <code>b</code> and vice versa.
By <code><a href=".././Init/Core.html#propext">propext</a></code>, this implies that <code>a</code> and <code>b</code> are equal and hence any expression involving <code>a</code>
is equivalent to the corresponding expression with <code>b</code> instead.</p><ul class="structure_ext"><li id="Iff.intro" class="structure_ext_ctor">intro :: (</li><ul class="structure_ext_fields"><li id="Iff.mp" class="structure_field"><div class="structure_field_info">mp : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span></div><div class="structure_field_doc"><p>Modus ponens for if and only if. If <code>a ↔ b</code> and <code>a</code>, then <code>b</code>.</p></div></li><li id="Iff.mpr" class="structure_field"><div class="structure_field_info">mpr : <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span></div><div class="structure_field_doc"><p>Modus ponens for if and only if, reversed. If <code>a ↔ b</code> and <code>b</code>, then <code>a</code>.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-Iff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Iff.mp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L118-L118">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.mp"><span class="name">Iff</span>.<span class="name">mp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span></div></div><p>Modus ponens for if and only if. If <code>a ↔ b</code> and <code>a</code>, then <code>b</code>.</p></div></div><div class="decl" id="Iff.mpr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L120-L120">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.mpr"><span class="name">Iff</span>.<span class="name">mpr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span></div></div><p>Modus ponens for if and only if, reversed. If <code>a ↔ b</code> and <code>b</code>, then <code>a</code>.</p></div></div><div class="decl" id="«term_&lt;-&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L122-L122">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_&lt;-&gt;_»"><span class="name">«term_&lt;-&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>If and only if, or logical bi-implication. <code>a ↔ b</code> means that <code>a</code> implies <code>b</code> and vice versa.
By <code><a href=".././Init/Core.html#propext">propext</a></code>, this implies that <code>a</code> and <code>b</code> are equal and hence any expression involving <code>a</code>
is equivalent to the corresponding expression with <code>b</code> instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_&lt;-&gt;_»">«term_&lt;-&gt;_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_&lt;-&gt;_</span> <span class="fn">20</span> <span class="fn">21</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; &lt;-&gt; &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">21</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term_&lt;-&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_↔_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L123-L123">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_↔_»"><span class="name">«term_↔_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>If and only if, or logical bi-implication. <code>a ↔ b</code> means that <code>a</code> implies <code>b</code> and vice versa.
By <code><a href=".././Init/Core.html#propext">propext</a></code>, this implies that <code>a</code> and <code>b</code> are equal and hence any expression involving <code>a</code>
is equivalent to the corresponding expression with <code>b</code> instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_↔_»">«term_↔_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_↔_</span> <span class="fn">20</span> <span class="fn">21</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ↔ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">21</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term_↔_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sum"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L130-L134">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sum"><span class="name">Sum</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p><code><a href=".././Init/Core.html#Sum">Sum</a> α β</code>, or <code>α ⊕ β</code>, is the disjoint union of types <code>α</code> and <code>β</code>.
An element of <code>α ⊕ β</code> is either of the form <code>.<a href=".././Init/Core.html#Sum.inl">inl</a> a</code> where <code>a : α</code>,
or <code>.<a href=".././Init/Core.html#Sum.inr">inr</a> b</code> where <code>b : β</code>.</p><ul class="constructors"><li class="constructor" id="Sum.inl">inl: <span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v} → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span></span></span></span></span><div class="inductive_ctor_doc"><p>Left injection into the sum type <code>α ⊕ β</code>. If <code>a : α</code> then <code>.<a href=".././Init/Core.html#Sum.inl">inl</a> a : α ⊕ β</code>.</p></div></li><li class="constructor" id="Sum.inr">inr: <span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v} → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span></span></span></span></span><div class="inductive_ctor_doc"><p>Right injection into the sum type <code>α ⊕ β</code>. If <code>b : β</code> then <code>.<a href=".././Init/Core.html#Sum.inr">inr</a> b : α ⊕ β</code>.</p></div></li></ul><details id="instances-for-list-Sum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_⊕_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L136-L136">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_⊕_»"><span class="name">«term_⊕_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code><a href=".././Init/Core.html#Sum">Sum</a> α β</code>, or <code>α ⊕ β</code>, is the disjoint union of types <code>α</code> and <code>β</code>.
An element of <code>α ⊕ β</code> is either of the form <code>.<a href=".././Init/Core.html#Sum.inl">inl</a> a</code> where <code>a : α</code>,
or <code>.<a href=".././Init/Core.html#Sum.inr">inr</a> b</code> where <code>b : β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_⊕_»">«term_⊕_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_⊕_</span> <span class="fn">30</span> <span class="fn">31</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ⊕ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">30</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term_⊕_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="PSum"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L149-L153">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PSum"><span class="name">PSum</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href=".././foundational_types.html">Sort</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max (max 1 u) v)</div></div><p><code><a href=".././Init/Core.html#PSum">PSum</a> α β</code>, or <code>α ⊕' β</code>, is the disjoint union of types <code>α</code> and <code>β</code>.
It differs from <code>α ⊕ β</code> in that it allows <code>α</code> and <code>β</code> to have arbitrary sorts
<code>Sort u</code> and <code>Sort v</code>, instead of restricting to <code>Type u</code> and <code>Type v</code>. This means
that it can be used in situations where one side is a proposition, like <code><a href=".././Init/Prelude.html#True">True</a> ⊕' <a href=".././Init/Prelude.html#Nat">Nat</a></code>.</p><p>The reason this is not the default is that this type lives in the universe <code>Sort (max 1 u v)</code>,
which can cause problems for universe level unification,
because the equation <code><a href=".././Init/Core.html#Task.Priority.max">max</a> 1 u v = ?u + 1</code> has no solution in level arithmetic.
<code><a href=".././Init/Core.html#PSum">PSum</a></code> is usually only used in automation that constructs sums of arbitrary types.</p><ul class="constructors"><li class="constructor" id="PSum.inl">inl: <span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u} → <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v} → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">α</span> <a href=".././Init/Core.html#PSum">⊕'</a> <span class="fn">β</span></span></span></span></span><div class="inductive_ctor_doc"><p>Left injection into the sum type <code>α ⊕' β</code>. If <code>a : α</code> then <code>.<a href=".././Init/Core.html#Sum.inl">inl</a> a : α ⊕' β</code>.</p></div></li><li class="constructor" id="PSum.inr">inr: <span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u} → <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v} → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">α</span> <a href=".././Init/Core.html#PSum">⊕'</a> <span class="fn">β</span></span></span></span></span><div class="inductive_ctor_doc"><p>Right injection into the sum type <code>α ⊕' β</code>. If <code>b : β</code> then <code>.<a href=".././Init/Core.html#Sum.inr">inr</a> b : α ⊕' β</code>.</p></div></li></ul><details id="instances-for-list-PSum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_⊕'_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L155-L155">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_⊕'_»"><span class="name">«term_⊕'_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code><a href=".././Init/Core.html#PSum">PSum</a> α β</code>, or <code>α ⊕' β</code>, is the disjoint union of types <code>α</code> and <code>β</code>.
It differs from <code>α ⊕ β</code> in that it allows <code>α</code> and <code>β</code> to have arbitrary sorts
<code>Sort u</code> and <code>Sort v</code>, instead of restricting to <code>Type u</code> and <code>Type v</code>. This means
that it can be used in situations where one side is a proposition, like <code><a href=".././Init/Prelude.html#True">True</a> ⊕' <a href=".././Init/Prelude.html#Nat">Nat</a></code>.</p><p>The reason this is not the default is that this type lives in the universe <code>Sort (max 1 u v)</code>,
which can cause problems for universe level unification,
because the equation <code><a href=".././Init/Core.html#Task.Priority.max">max</a> 1 u v = ?u + 1</code> has no solution in level arithmetic.
<code><a href=".././Init/Core.html#PSum">PSum</a></code> is usually only used in automation that constructs sums of arbitrary types.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_⊕'_»">«term_⊕'_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_⊕'_</span> <span class="fn">30</span> <span class="fn">31</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ⊕' &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">30</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term_⊕'_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instInhabitedPSum"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L157-L157">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedPSum"><span class="name">instInhabitedPSum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">α</span> <a href=".././Init/Core.html#PSum">⊕'</a> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedPSum</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#PSum.inl">PSum.inl</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedPSum_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L159-L159">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedPSum_1"><span class="name">instInhabitedPSum_1</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">α</span> <a href=".././Init/Core.html#PSum">⊕'</a> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedPSum_1</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#PSum.inr">PSum.inr</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Sigma"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L169-L177">source</a></div><div class="attributes">@[unbox]</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sigma"><span class="name">Sigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(β : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p><code><a href=".././Init/Core.html#Sigma">Sigma</a> β</code>, also denoted <code>Σ a : α, β a</code> or <code>(a : α) × β a</code>, is the type of dependent pairs
whose first component is <code>a : α</code> and whose second component is <code>b : β a</code>
(so the type of the second component can depend on the value of the first component).
It is sometimes known as the dependent sum type, since it is the type level version
of an indexed summation.</p><ul class="structure_fields" id="Sigma.mk"><li id="Sigma.fst" class="structure_field"><div class="structure_field_info">fst : <span class="fn">α</span></div><div class="structure_field_doc"><p>The first component of a dependent pair. If <code>p : @Sigma α β</code> then <code>p.1 : α</code>.</p></div></li><li id="Sigma.snd" class="structure_field"><div class="structure_field_info">snd : <span class="fn"><span class="fn">β</span> <span class="fn"><span class="fn">self</span>.fst</span></span></div><div class="structure_field_doc"><p>The second component of a dependent pair. If <code>p : <a href=".././Init/Core.html#Sigma">Sigma</a> β</code> then <code>p.2 : β p.1</code>.</p></div></li></ul><details id="instances-for-list-Sigma" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="PSigma"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L195-L203">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PSigma"><span class="name">PSigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(β : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max (max 1 u) v)</div></div><p><code><a href=".././Init/Core.html#PSigma">PSigma</a> β</code>, also denoted <code>Σ' a : α, β a</code> or <code>(a : α) ×' β a</code>, is the type of dependent pairs
whose first component is <code>a : α</code> and whose second component is <code>b : β a</code>
(so the type of the second component can depend on the value of the first component).
It differs from <code>Σ a : α, β a</code> in that it allows <code>α</code> and <code>β</code> to have arbitrary sorts
<code>Sort u</code> and <code>Sort v</code>, instead of restricting to <code>Type u</code> and <code>Type v</code>. This means
that it can be used in situations where one side is a proposition, like <code>(p : Nat) ×' p = p</code>.</p><p>The reason this is not the default is that this type lives in the universe <code>Sort (max 1 u v)</code>,
which can cause problems for universe level unification,
because the equation <code><a href=".././Init/Core.html#Task.Priority.max">max</a> 1 u v = ?u + 1</code> has no solution in level arithmetic.
<code><a href=".././Init/Core.html#PSigma">PSigma</a></code> is usually only used in automation that constructs pairs of arbitrary types.</p><ul class="structure_fields" id="PSigma.mk"><li id="PSigma.fst" class="structure_field"><div class="structure_field_info">fst : <span class="fn">α</span></div><div class="structure_field_doc"><p>The first component of a dependent pair. If <code>p : @Sigma α β</code> then <code>p.1 : α</code>.</p></div></li><li id="PSigma.snd" class="structure_field"><div class="structure_field_info">snd : <span class="fn"><span class="fn">β</span> <span class="fn"><span class="fn">self</span>.fst</span></span></div><div class="structure_field_doc"><p>The second component of a dependent pair. If <code>p : <a href=".././Init/Core.html#Sigma">Sigma</a> β</code> then <code>p.2 : β p.1</code>.</p></div></li></ul><details id="instances-for-list-PSigma" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Exists"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L230-L233">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Exists"><span class="name">Exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>Existential quantification. If <code>p : α → Prop</code> is a predicate, then <code>∃ x : α, p x</code>
asserts that there is some <code>x</code> of type <code>α</code> such that <code>p x</code> holds.
To create an existential proof, use the <code>exists</code> tactic,
or the anonymous constructor notation <code>⟨x, h⟩</code>.
To unpack an existential, use <code>cases h</code> where <code>h</code> is a proof of <code>∃ x : α, p x</code>,
or <code>let ⟨x, hx⟩ := h</code> where `.</p><p>Because Lean has proof irrelevance, any two proofs of an existential are
definitionally equal. One consequence of this is that it is impossible to recover the
witness of an existential from the mere fact of its existence.
For example, the following does not compile:</p><pre><code>example (h : ∃ x : Nat, x = x) : <a href=".././Init/Prelude.html#Nat">Nat</a> :=
  let ⟨x, _⟩ := h  -- fail, because the goal is `Nat : Type`
  x
</code></pre><p>The error message <code>recursor 'Exists.casesOn' can only eliminate into Prop</code> means
that this only works when the current goal is another proposition:</p><pre><code>example (h : ∃ x : Nat, x = x) : <a href=".././Init/Prelude.html#True">True</a> :=
  let ⟨x, _⟩ := h  -- ok, because the goal is `True : Prop`
  <a href=".././Init/Core.html#trivial">trivial</a>
</code></pre><ul class="constructors"><li class="constructor" id="Exists.intro">intro: <span class="fn">∀ {<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u} {<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>} (<span class="fn">w</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">w</span></span> → <span class="fn"><a href=".././Init/Core.html#Exists">Exists</a> <span class="fn">p</span></span></span></span><div class="inductive_ctor_doc"><p>Existential introduction. If <code>a : α</code> and <code>h : p a</code>,
then <code>⟨a, h⟩</code> is a proof that <code>∃ x : α, p x</code>.</p></div></li></ul><details id="instances-for-list-Exists" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ForInStep"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L246-L253">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ForInStep"><span class="name">ForInStep</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Auxiliary type used to compile <code>for x in xs</code> notation.</p><p>This is the return value of the body of a <code><a href=".././Init/Core.html#ForIn">ForIn</a></code> call,
representing the body of a for loop. It can be:</p><ul>
<li><code>.<a href=".././Init/Core.html#ForInStep.yield">yield</a> (a : α)</code>, meaning that we should continue the loop and <code>a</code> is the new state.
<code>.<a href=".././Init/Core.html#ForInStep.yield">yield</a></code> is produced by <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> and reaching the bottom of the loop body.</li>
<li><code>.<a href=".././Init/Core.html#ForInStep.done">done</a> (a : α)</code>, meaning that we should early-exit the loop with state <code>a</code>.
<code>.<a href=".././Init/Core.html#ForInStep.done">done</a></code> is produced by calls to <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> or <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a></code> in the loop,</li>
</ul><ul class="constructors"><li class="constructor" id="ForInStep.done">done: <span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">α</span></span></span></span><div class="inductive_ctor_doc"><p><code>.<a href=".././Init/Core.html#ForInStep.done">done</a> a</code> means that we should early-exit the loop.
<code>.<a href=".././Init/Core.html#ForInStep.done">done</a></code> is produced by calls to <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> or <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a></code> in the loop.</p></div></li><li class="constructor" id="ForInStep.yield">yield: <span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">α</span></span></span></span><div class="inductive_ctor_doc"><p><code>.<a href=".././Init/Core.html#ForInStep.yield">yield</a> a</code> means that we should continue the loop.
<code>.<a href=".././Init/Core.html#ForInStep.yield">yield</a></code> is produced by <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> and reaching the bottom of the loop body.</p></div></li></ul><details id="instances-for-list-ForInStep" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instInhabitedForInStep"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L253-L253">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedForInStep"><span class="name">instInhabitedForInStep</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Type</a> u_1} → <span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">a</span></span>] → <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">a</span>)</span></span></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedForInStep</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#ForInStep.done">ForInStep.done</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="ForIn"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L261-L282">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ForIn"><span class="name">ForIn</span></a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href=".././foundational_types.html">Type</a> u₁ → <a href=".././foundational_types.html">Type</a> u₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(ρ : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> v)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max (max u (u₁ + 1)) u₂) v)</div></div><p><code><a href=".././Init/Core.html#ForIn">ForIn</a> m ρ α</code> is the typeclass which supports <code>for x in xs</code> notation.
Here <code>xs : ρ</code> is the type of the collection to iterate over, <code>x : α</code>
is the element type which is made available inside the loop, and <code>m</code> is the monad
for the encompassing <code>do</code> block.</p><ul class="structure_fields" id="ForIn.mk"><li id="ForIn.forIn" class="structure_field"><div class="structure_field_info">forIn : <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u₁} → <span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>] → <span class="fn"><span class="fn">ρ</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">(<span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">β</span>)</span></span></span>)</span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span></span></span></span></span></div><div class="structure_field_doc"><p><code><a href=".././Init/Core.html#ForIn.forIn">forIn</a> x b f : m β</code> runs a for-loop in the monad <code>m</code> with additional state <code>β</code>.
This traverses over the &quot;contents&quot; of <code>x</code>, and passes the elements <code>a : α</code> to
<code>f : α → β → m (ForInStep β)</code>. <code>b : β</code> is the initial state, and the return value
of <code>f</code> is the new state as well as a directive <code>.<a href=".././Init/Core.html#ForInStep.done">done</a></code> or <code>.<a href=".././Init/Core.html#ForInStep.yield">yield</a></code>
which indicates whether to abort early or continue iteration.</p><p>The expression</p><pre><code>let mut b := ...
for x in xs do
  b ← foo x b
</code></pre><p>in a <code>do</code> block is syntactic sugar for:</p><pre><code>let b := ...
let b ← <a href=".././Init/Core.html#ForIn.forIn">forIn</a> xs b (fun x b =&gt; do
  let b ← foo x b
  <a href=".././Init/Core.html#DoResultPRBC.return">return</a> .<a href=".././Init/Core.html#ForInStep.yield">yield</a> b)
</code></pre><p>(Here <code>b</code> corresponds to the variables mutated in the loop.)</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-ForIn" class="instances-list"></ul></details></div></div><div class="decl" id="ForIn'"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L291-L298">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ForIn'"><span class="name">ForIn'</span></a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href=".././foundational_types.html">Type</a> u₁ → <a href=".././foundational_types.html">Type</a> u₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(ρ : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> v)</span>)</span></span>
<span class="decl_args">
<span class="fn">(d : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">(<a href=".././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">ρ</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max (max (max u (u₁ + 1)) u₂) v)</div></div><p><code><a href=".././Init/Core.html#ForIn'">ForIn'</a> m ρ α d</code> is a variation on the <code><a href=".././Init/Core.html#ForIn">ForIn</a> m ρ α</code> typeclass which supports the
<code>for h : x in xs</code> notation. It is the same as <code>for x in xs</code> except that <code>h : x ∈ xs</code>
is provided as an additional argument to the body of the for-loop.</p><ul class="structure_fields" id="ForIn'.mk"><li id="ForIn'.forIn'" class="structure_field"><div class="structure_field_info">forIn' : <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u₁} → <span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>] → <span class="fn">(<span class="fn">x</span> : <span class="fn">ρ</span>) → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">x</span></span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">β</span>)</span></span></span></span>)</span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span></span></span></span></span></div><div class="structure_field_doc"><p><code><a href=".././Init/Core.html#ForIn'.forIn'">forIn'</a> x b f : m β</code> runs a for-loop in the monad <code>m</code> with additional state <code>β</code>.
This traverses over the &quot;contents&quot; of <code>x</code>, and passes the elements <code>a : α</code> along
with a proof that <code>a ∈ x</code> to <code>f : (a : α) → a ∈ x → β → m (ForInStep β)</code>.
<code>b : β</code> is the initial state, and the return value
of <code>f</code> is the new state as well as a directive <code>.<a href=".././Init/Core.html#ForInStep.done">done</a></code> or <code>.<a href=".././Init/Core.html#ForInStep.yield">yield</a></code>
which indicates whether to abort early or continue iteration.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-ForIn'" class="instances-list"></ul></details></div></div><div class="decl" id="DoResultPRBC"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L316-L326">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#DoResultPRBC"><span class="name">DoResultPRBC</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(σ : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Auxiliary type used to compile <code>do</code> notation. It is used when compiling a do block
nested inside a combinator like <code>tryCatch</code>. It encodes the possible ways the
block can exit:</p><ul>
<li><code><a href=".././Init/Core.html#Thunk.pure">pure</a> (a : α) s</code> means that the block exited normally with return value <code>a</code>.</li>
<li><code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> (b : β) s</code> means that the block exited via a <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> b</code> early-exit command.</li>
<li><code><a href=".././Init/Core.html#DoResultPRBC.break">break</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> was called, meaning that we should exit
from the containing loop.</li>
<li><code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> was called, meaning that we should continue
to the next iteration of the containing loop.</li>
</ul><p>All cases return a value <code>s : σ</code> which bundles all the mutable variables of the do-block.</p><ul class="constructors"><li class="constructor" id="DoResultPRBC.pure">pure: <span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#Thunk.pure">pure</a> (a : α) s</code> means that the block exited normally with return value <code>a</code></p></div></li><li class="constructor" id="DoResultPRBC.return">return: <span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> (b : β) s</code> means that the block exited via a <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> b</code> early-exit command</p></div></li><li class="constructor" id="DoResultPRBC.break">break: <span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.break">break</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> was called, meaning that we should exit
from the containing loop</p></div></li><li class="constructor" id="DoResultPRBC.continue">continue: <span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> was called, meaning that we should continue
to the next iteration of the containing loop</p></div></li></ul><details id="instances-for-list-DoResultPRBC" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="DoResultPR"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L333-L337">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#DoResultPR"><span class="name">DoResultPR</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(σ : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Auxiliary type used to compile <code>do</code> notation. It is the same as
<code><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> α β σ</code> except that <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> and <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> are not available
because we are not in a loop context.</p><ul class="constructors"><li class="constructor" id="DoResultPR.pure">pure: <span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPR">DoResultPR</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#Thunk.pure">pure</a> (a : α) s</code> means that the block exited normally with return value <code>a</code></p></div></li><li class="constructor" id="DoResultPR.return">return: <span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPR">DoResultPR</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> (b : β) s</code> means that the block exited via a <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> b</code> early-exit command</p></div></li></ul><details id="instances-for-list-DoResultPR" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="DoResultBC"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L344-L350">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#DoResultBC"><span class="name">DoResultBC</span></a></span><span class="decl_args">
<span class="fn">(σ : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Auxiliary type used to compile <code>do</code> notation. It is an optimization of
<code><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <a href=".././Init/Prelude.html#PEmpty">PEmpty</a> <a href=".././Init/Prelude.html#PEmpty">PEmpty</a> σ</code> to remove the impossible cases,
used when neither <code><a href=".././Init/Core.html#Thunk.pure">pure</a></code> nor <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a></code> are possible exit paths.</p><ul class="constructors"><li class="constructor" id="DoResultBC.break">break: <span class="fn">{<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultBC">DoResultBC</a> <span class="fn">σ</span></span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.break">break</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> was called, meaning that we should exit
from the containing loop</p></div></li><li class="constructor" id="DoResultBC.continue">continue: <span class="fn">{<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultBC">DoResultBC</a> <span class="fn">σ</span></span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> was called, meaning that we should continue
to the next iteration of the containing loop</p></div></li></ul><details id="instances-for-list-DoResultBC" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="DoResultSBC"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L357-L369">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#DoResultSBC"><span class="name">DoResultSBC</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(σ : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Auxiliary type used to compile <code>do</code> notation. It is an optimization of
either <code><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> α <a href=".././Init/Prelude.html#PEmpty">PEmpty</a> σ</code> or <code><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <a href=".././Init/Prelude.html#PEmpty">PEmpty</a> α σ</code> to remove the
impossible case, used when either <code><a href=".././Init/Core.html#Thunk.pure">pure</a></code> or <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a></code> is never used.</p><ul class="constructors"><li class="constructor" id="DoResultSBC.pureReturn">pureReturn: <span class="fn">{<span class="fn">α </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultSBC">DoResultSBC</a> <span class="fn">α</span> <span class="fn">σ</span></span></span></span></span><div class="inductive_ctor_doc"><p>This encodes either <code><a href=".././Init/Core.html#Thunk.pure">pure</a> (a : α)</code> or <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> (a : α)</code>:</p><ul>
<li><code><a href=".././Init/Core.html#Thunk.pure">pure</a> (a : α) s</code> means that the block exited normally with return value <code>a</code></li>
<li><code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> (b : β) s</code> means that the block exited via a <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> b</code> early-exit command</li>
</ul><p>The one that is actually encoded depends on the context of use.</p></div></li><li class="constructor" id="DoResultSBC.break">break: <span class="fn">{<span class="fn">α </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultSBC">DoResultSBC</a> <span class="fn">α</span> <span class="fn">σ</span></span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.break">break</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> was called, meaning that we should exit
from the containing loop</p></div></li><li class="constructor" id="DoResultSBC.continue">continue: <span class="fn">{<span class="fn">α </span><span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultSBC">DoResultSBC</a> <span class="fn">α</span> <span class="fn">σ</span></span></span></span><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> was called, meaning that we should continue
to the next iteration of the containing loop</p></div></li></ul><details id="instances-for-list-DoResultSBC" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="HasEquiv"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L372-L375">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HasEquiv"><span class="name">HasEquiv</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max u (v + 1))</div></div><p><code><a href=".././Init/Core.html#HasEquiv">HasEquiv</a> α</code> is the typeclass which supports the notation <code>x ≈ y</code> where <code>x y : α</code>.</p><ul class="structure_fields" id="HasEquiv.mk"><li id="HasEquiv.Equiv" class="structure_field"><div class="structure_field_info">Equiv : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span></div><div class="structure_field_doc"><p><code>x ≈ y</code> says that <code>x</code> and <code>y</code> are equivalent. Because this is a typeclass,
the notion of equivalence is type-dependent.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HasEquiv" class="instances-list"></ul></details></div></div><div class="decl" id="«term_≈_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L377-L377">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_≈_»"><span class="name">«term_≈_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>x ≈ y</code> says that <code>x</code> and <code>y</code> are equivalent. Because this is a typeclass,
the notion of equivalence is type-dependent.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_≈_»">«term_≈_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_≈_</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ≈ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term_≈_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="set-notation">set notation <a class="hover-link" href="#set-notation">#</a></h1></div><div class="decl" id="HasSubset"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L382-L384">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HasSubset"><span class="name">HasSubset</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Notation type class for the subset relation <code>⊆</code>.</p><ul class="structure_fields" id="HasSubset.mk"><li id="HasSubset.Subset" class="structure_field"><div class="structure_field_info">Subset : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div><div class="structure_field_doc"><p>Subset relation: <code>a ⊆ b</code></p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HasSubset" class="instances-list"></ul></details></div></div><div class="decl" id="HasSSubset"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L388-L390">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HasSSubset"><span class="name">HasSSubset</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Notation type class for the strict subset relation <code>⊂</code>.</p><ul class="structure_fields" id="HasSSubset.mk"><li id="HasSSubset.SSubset" class="structure_field"><div class="structure_field_info">SSubset : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div><div class="structure_field_doc"><p>Strict subset relation: <code>a ⊂ b</code></p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-HasSSubset" class="instances-list"></ul></details></div></div><div class="decl" id="Superset"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L394-L394">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Superset"><span class="name">Superset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#HasSubset">HasSubset</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>Superset relation: <code>a ⊇ b</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Superset">⊇</a> <span class="fn">b</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">b</span> <a href=".././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">a</span>)</span></span></li></ul></details><details id="instances-for-list-Superset" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="SSuperset"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L397-L397">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#SSuperset"><span class="name">SSuperset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#HasSSubset">HasSSubset</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>Strict superset relation: <code>a ⊃ b</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#SSuperset">⊃</a> <span class="fn">b</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">b</span> <a href=".././Init/Core.html#HasSSubset.SSubset">⊂</a> <span class="fn">a</span>)</span></span></li></ul></details><details id="instances-for-list-SSuperset" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Union"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L400-L402">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Union"><span class="name">Union</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Notation type class for the union operation <code>∪</code>.</p><ul class="structure_fields" id="Union.mk"><li id="Union.union" class="structure_field"><div class="structure_field_info">union : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p><code>a ∪ b</code> is the union of<code>a</code> and <code>b</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Union" class="instances-list"></ul></details></div></div><div class="decl" id="Inter"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L405-L407">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Inter"><span class="name">Inter</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Notation type class for the intersection operation <code>∩</code>.</p><ul class="structure_fields" id="Inter.mk"><li id="Inter.inter" class="structure_field"><div class="structure_field_info">inter : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p><code>a ∩ b</code> is the intersection of<code>a</code> and <code>b</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Inter" class="instances-list"></ul></details></div></div><div class="decl" id="SDiff"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L410-L415">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#SDiff"><span class="name">SDiff</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p>Notation type class for the set difference <code>\</code>.</p><ul class="structure_fields" id="SDiff.mk"><li id="SDiff.sdiff" class="structure_field"><div class="structure_field_info">sdiff : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div><div class="structure_field_doc"><p><code>a \ b</code> is the set difference of <code>a</code> and <code>b</code>,
consisting of all elements in <code>a</code> that are not in <code>b</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-SDiff" class="instances-list"></ul></details></div></div><div class="decl" id="«term_⊆_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L417-L418">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_⊆_»"><span class="name">«term_⊆_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Subset relation: <code>a ⊆ b</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_⊆_»">«term_⊆_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_⊆_</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ⊆ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term_⊆_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_⊂_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L420-L421">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_⊂_»"><span class="name">«term_⊂_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Strict subset relation: <code>a ⊂ b</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_⊂_»">«term_⊂_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_⊂_</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ⊂ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term_⊂_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_⊇_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L423-L424">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_⊇_»"><span class="name">«term_⊇_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Superset relation: <code>a ⊇ b</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_⊇_»">«term_⊇_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_⊇_</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ⊇ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term_⊇_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_⊃_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L426-L427">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_⊃_»"><span class="name">«term_⊃_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Strict superset relation: <code>a ⊃ b</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_⊃_»">«term_⊃_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_⊃_</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ⊃ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term_⊃_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_∪_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L429-L430">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_∪_»"><span class="name">«term_∪_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a ∪ b</code> is the union of<code>a</code> and <code>b</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_∪_»">«term_∪_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_∪_</span> <span class="fn">65</span> <span class="fn">65</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ∪ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">66</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term_∪_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_∩_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L432-L433">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_∩_»"><span class="name">«term_∩_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a ∩ b</code> is the intersection of<code>a</code> and <code>b</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_∩_»">«term_∩_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_∩_</span> <span class="fn">70</span> <span class="fn">70</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ∩ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">71</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term_∩_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_\_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L435-L439">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_\_»"><span class="name">«term_\_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a \ b</code> is the set difference of <code>a</code> and <code>b</code>,
consisting of all elements in <code>a</code> that are not in <code>b</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_\_»">«term_\_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_\_</span> <span class="fn">70</span> <span class="fn">71</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; \\ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">71</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term_\_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="collections">collections <a class="hover-link" href="#collections">#</a></h1></div><div class="decl" id="EmptyCollection"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L444-L447">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#EmptyCollection"><span class="name">EmptyCollection</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p><code><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a> α</code> is the typeclass which supports the notation <code>∅</code>, also written as <code>{}</code>.</p><ul class="structure_fields" id="EmptyCollection.mk"><li id="EmptyCollection.emptyCollection" class="structure_field"><div class="structure_field_info">emptyCollection : <span class="fn">α</span></div><div class="structure_field_doc"><p><code>∅</code> or <code>{}</code> is the empty set or empty collection.
It is supported by the <code><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a></code> typeclass.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-EmptyCollection" class="instances-list"></ul></details></div></div><div class="decl" id="«term{}»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L449-L449">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term{}»"><span class="name">«term{}»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>∅</code> or <code>{}</code> is the empty set or empty collection.
It is supported by the <code><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a></code> typeclass.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term{}»">«term{}»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`term{}</span> <span class="fn">1024</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;{&quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;}&quot;</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term{}»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term∅»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L450-L450">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term∅»"><span class="name">«term∅»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>∅</code> or <code>{}</code> is the empty set or empty collection.
It is supported by the <code><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a></code> typeclass.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term∅»">«term∅»</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`term∅</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;∅&quot;</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term∅»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Insert"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L456-L458">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Insert"><span class="name">Insert</span></a></span><span class="decl_args">
<span class="fn">(α : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p>Type class for the <code><a href=".././Init/Core.html#Insert.insert">insert</a></code> operation.
Used to implement the <code>{ a, b, c }</code> syntax.</p><ul class="structure_fields" id="Insert.mk"><li id="Insert.insert" class="structure_field"><div class="structure_field_info">insert : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p><code><a href=".././Init/Core.html#Insert.insert">insert</a> x xs</code> inserts the element <code>x</code> into the collection <code>xs</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Insert" class="instances-list"></ul></details></div></div><div class="decl" id="Singleton"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L465-L467">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Singleton"><span class="name">Singleton</span></a></span><span class="decl_args">
<span class="fn">(α : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p>Type class for the <code><a href=".././Init/Core.html#Singleton.singleton">singleton</a></code> operation.
Used to implement the <code>{ a, b, c }</code> syntax.</p><ul class="structure_fields" id="Singleton.mk"><li id="Singleton.singleton" class="structure_field"><div class="structure_field_info">singleton : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span></div><div class="structure_field_doc"><p><code><a href=".././Init/Core.html#Singleton.singleton">singleton</a> x</code> is a collection with the single element <code>x</code> (notation: <code>{x}</code>).</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Singleton" class="instances-list"></ul></details></div></div><div class="decl" id="LawfulSingleton"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L471-L474">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#LawfulSingleton"><span class="name">LawfulSingleton</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Insert">Insert</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Singleton">Singleton</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Insert.insert">insert</a> x ∅ = {x}</code></p><ul class="structure_fields" id="LawfulSingleton.mk"><li id="LawfulSingleton.insert_emptyc_eq" class="structure_field"><div class="structure_field_info">insert_emptyc_eq : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href=".././Init/Core.html#Insert.insert">insert</a> <span class="fn">x</span> <a href=".././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{<span class="fn">x</span>}</span></span></span></div><div class="structure_field_doc"><p><code><a href=".././Init/Core.html#Insert.insert">insert</a> x ∅ = {x}</code></p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-LawfulSingleton" class="instances-list"></ul></details></div></div><div class="decl" id="LawfulSingleton.insert_emptyc_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L474-L474">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#LawfulSingleton.insert_emptyc_eq"><span class="name">LawfulSingleton</span>.<span class="name">insert_emptyc_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Insert">Insert</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Singleton">Singleton</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href=".././Init/Core.html#LawfulSingleton">LawfulSingleton</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Insert.insert">insert</a> <span class="fn">x</span> <a href=".././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{<span class="fn">x</span>}</span></span></div></div><p><code><a href=".././Init/Core.html#Insert.insert">insert</a> x ∅ = {x}</code></p></div></div><div class="decl" id="Sep"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L480-L482">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sep"><span class="name">Sep</span></a></span><span class="decl_args">
<span class="fn">(α : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <a href=".././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max u v)</div></div><p>Type class used to implement the notation <code>{ a ∈ c | p a }</code></p><ul class="structure_fields" id="Sep.mk"><li id="Sep.sep" class="structure_field"><div class="structure_field_info">sep : <span class="fn"><span class="fn">(<span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a>)</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">γ</span></span></span></div><div class="structure_field_doc"><p>Computes <code>{ a ∈ c | p a }</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Sep" class="instances-list"></ul></details></div></div><div class="decl" id="Task"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L492-L498">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task"><span class="name">Task</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p><code><a href=".././Init/Core.html#Task">Task</a> α</code> is a primitive for asynchronous computation.
It represents a computation that will resolve to a value of type <code>α</code>,
possibly being computed on another thread. This is similar to <code>Future</code> in Scala,
<code>Promise</code> in Javascript, and <code>JoinHandle</code> in Rust.</p><p>The tasks have an overridden representation in the runtime.</p><ul class="structure_ext"><li id="Task.pure" class="structure_ext_ctor">pure :: (</li><ul class="structure_ext_fields"><li id="Task.get" class="structure_field"><div class="structure_field_info">get : <span class="fn">α</span></div><div class="structure_field_doc"><p>If <code>task : <a href=".././Init/Core.html#Task">Task</a> α</code> then <code>task.<a href=".././Init/Core.html#Thunk.get">get</a> : α</code> blocks the current thread until the
value is available, and then returns the result of the task.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-Task" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instInhabitedTask"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L498-L498">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedTask"><span class="name">instInhabitedTask</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Type</a> u_1} → <span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">a</span></span>] → <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Core.html#Task">Task</a> <span class="fn">a</span>)</span></span></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedTask</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">get</span> := <span class="fn">default</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="instNonemptyTask"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L498-L498">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instNonemptyTask"><span class="name">instNonemptyTask</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1} [<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>], <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href=".././Init/Core.html#Task">Task</a> <span class="fn">α</span>)</span></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Task.Priority"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L505-L505">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.Priority"><span class="name">Task</span>.<span class="name">Priority</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Task priority. Tasks with higher priority will always be scheduled before ones with lower priority.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Task.Priority">Task.Priority</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></li></ul></details><details id="instances-for-list-Task.Priority" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Task.Priority.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L508-L508">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.Priority.default"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Core.html#Task.Priority">Task.Priority</a></div></div><p>The default priority for spawned tasks, also the lowest priority: <code>0</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Task.Priority.default">Task.Priority.default</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></li></ul></details><details id="instances-for-list-Task.Priority.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Task.Priority.max"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L517-L517">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.Priority.max"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">max</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Core.html#Task.Priority">Task.Priority</a></div></div><p>The highest regular priority for spawned tasks: <code>8</code>.</p><p>Spawning a task with a priority higher than <code><a href=".././Init/Core.html#Task.Priority.max">Task.Priority.max</a></code> is not an error but
will spawn a dedicated worker for the task, see <code><a href=".././Init/Core.html#Task.Priority.dedicated">Task.Priority.dedicated</a></code>.
Regular priority tasks are placed in a thread pool and worked on according to the priority order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Task.Priority.max">Task.Priority.max</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">8</span></span></li></ul></details><details id="instances-for-list-Task.Priority.max" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Task.Priority.dedicated"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L524-L524">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.Priority.dedicated"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">dedicated</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Core.html#Task.Priority">Task.Priority</a></div></div><p>Any priority higher than <code><a href=".././Init/Core.html#Task.Priority.max">Task.Priority.max</a></code> will result in the task being scheduled
immediately on a dedicated thread. This is particularly useful for long-running and/or
I/O-bound tasks since Lean will by default allocate no more non-dedicated workers
than the number of cores to reduce context switches.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Task.Priority.dedicated">Task.Priority.dedicated</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">9</span></span></li></ul></details><details id="instances-for-list-Task.Priority.dedicated" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Task.spawn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L534-L535">source</a></div><div class="attributes">@[noinline, extern  lean_task_spawn]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.spawn"><span class="name">Task</span>.<span class="name">spawn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(fn : <span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prio : <span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Core.html#Task.Priority">Task.Priority</a> <a href=".././Init/Core.html#Task.Priority.default">Task.Priority.default</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">α</span></span></div></div><p><code><a href=".././Init/Core.html#Task.spawn">spawn</a> fn : <a href=".././Init/Core.html#Task">Task</a> α</code> constructs and immediately launches a new task for
evaluating the function <code>fn () : α</code> asynchronously.</p><p><code>prio</code>, if provided, is the priority of the task.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Task.spawn">Task.spawn</a> <span class="fn">fn</span> <span class="fn">prio</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">get</span> := <span class="fn"><span class="fn">fn</span> <a href=".././Init/Prelude.html#Unit.unit">()</a></span> }</span></span></li></ul></details><details id="instances-for-list-Task.spawn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Task.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L547-L548">source</a></div><div class="attributes">@[noinline, extern  lean_task_map]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.map"><span class="name">Task</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prio : <span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Core.html#Task.Priority">Task.Priority</a> <a href=".././Init/Core.html#Task.Priority.default">Task.Priority.default</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(sync : <span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Prelude.html#Bool">Bool</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">β</span></span></div></div><p><code><a href=".././Init/Core.html#Thunk.map">map</a> f x</code> maps function <code>f</code> over the task <code>x</code>: that is, it constructs
(and immediately launches) a new task which will wait for the value of <code>x</code> to
be available and then calls <code>f</code> on the result.</p><p><code>prio</code>, if provided, is the priority of the task.
If <code>sync</code> is set to true, <code>f</code> is executed on the current thread if <code>x</code> has already finished.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Task.map">Task.map</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">prio</span> <span class="fn">sync</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">get</span> := <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.get</span></span> }</span></span></li></ul></details><details id="instances-for-list-Task.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Task.bind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L561-L563">source</a></div><div class="attributes">@[noinline, extern  lean_task_bind]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.bind"><span class="name">Task</span>.<span class="name">bind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prio : <span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Core.html#Task.Priority">Task.Priority</a> <a href=".././Init/Core.html#Task.Priority.default">Task.Priority.default</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(sync : <span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Prelude.html#Bool">Bool</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">β</span></span></div></div><p><code><a href=".././Init/Core.html#Thunk.bind">bind</a> x f</code> does a monad &quot;bind&quot; operation on the task <code>x</code> with function <code>f</code>:
that is, it constructs (and immediately launches) a new task which will wait
for the value of <code>x</code> to be available and then calls <code>f</code> on the result,
resulting in a new task which is then run for a result.</p><p><code>prio</code>, if provided, is the priority of the task.
If <code>sync</code> is set to true, <code>f</code> is executed on the current thread if <code>x</code> has already finished.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.bind</span> <span class="fn">f</span> <span class="fn">prio</span> <span class="fn">sync</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">get</span> := <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">x</span>.get</span>)</span>.get</span> }</span></span></li></ul></details><details id="instances-for-list-Task.bind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="NonScalar"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L573-L575">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#NonScalar"><span class="name">NonScalar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p><code><a href=".././Init/Core.html#NonScalar">NonScalar</a></code> is a type that is not a scalar value in our runtime.
It is used as a stand-in for an arbitrary boxed value to avoid excessive
monomorphization, and it is only created using <code><a href=".././Init/Prelude.html#unsafeCast">unsafeCast</a></code>. It is somewhat
analogous to C <code>void*</code> in usage, but the type itself is not special.</p><ul class="structure_fields" id="NonScalar.mk"><li id="NonScalar.val" class="structure_field"><div class="structure_field_info">val : <a href=".././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>You should not use this function</p></div></li></ul><details id="instances-for-list-NonScalar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="PNonScalar"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L586-L588">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PNonScalar"><span class="name">PNonScalar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p><code><a href=".././Init/Core.html#PNonScalar">PNonScalar</a></code> is a type that is not a scalar value in our runtime.
It is used as a stand-in for an arbitrary boxed value to avoid excessive
monomorphization, and it is only created using <code><a href=".././Init/Prelude.html#unsafeCast">unsafeCast</a></code>. It is somewhat
analogous to C <code>void*</code> in usage, but the type itself is not special.</p><p>This is the universe-polymorphic version of <code><a href=".././Init/Core.html#PNonScalar">PNonScalar</a></code>; it is preferred to use
<code><a href=".././Init/Core.html#NonScalar">NonScalar</a></code> instead where applicable.</p><ul class="constructors"><li class="constructor" id="PNonScalar.mk">mk: <span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Core.html#PNonScalar">PNonScalar</a></span><div class="inductive_ctor_doc"><p>You should not use this function</p></div></li></ul><details id="instances-for-list-PNonScalar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Nat.add_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L590-L590">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Nat.add_zero"><span class="name">Nat</span>.<span class="name">add_zero</span></a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">n</span></span></div></div></div></div><div class="decl" id="optParam_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L592-L592">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#optParam_eq"><span class="name">optParam_eq</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args">
<span class="fn">(default : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <span class="fn">α</span> <span class="fn">default</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">α</span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Boolean-operators">Boolean operators <a class="hover-link" href="#Boolean-operators">#</a></h1></div><div class="decl" id="strictOr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L600-L600">source</a></div><div class="attributes">@[extern  lean_strict_or]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#strictOr"><span class="name">strictOr</span></a></span><span class="decl_args">
<span class="fn">(b₁ : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(b₂ : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p><code><a href=".././Init/Core.html#strictOr">strictOr</a></code> is the same as <code><a href=".././Init/Prelude.html#or">or</a></code>, but it does not use short-circuit evaluation semantics:
both sides are evaluated, even if the first value is <code>true</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#strictOr">strictOr</a> <span class="fn">b₁</span> <span class="fn">b₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">b₁</span> <a href=".././Init/Prelude.html#or">||</a> <span class="fn">b₂</span>)</span></span></li></ul></details><details id="instances-for-list-strictOr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="strictAnd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L606-L606">source</a></div><div class="attributes">@[extern  lean_strict_and]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#strictAnd"><span class="name">strictAnd</span></a></span><span class="decl_args">
<span class="fn">(b₁ : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(b₂ : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p><code><a href=".././Init/Core.html#strictAnd">strictAnd</a></code> is the same as <code><a href=".././Init/Prelude.html#and">and</a></code>, but it does not use short-circuit evaluation semantics:
both sides are evaluated, even if the first value is <code>false</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#strictAnd">strictAnd</a> <span class="fn">b₁</span> <span class="fn">b₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">b₁</span> <a href=".././Init/Prelude.html#and">&amp;&amp;</a> <span class="fn">b₂</span>)</span></span></li></ul></details><details id="instances-for-list-strictAnd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="bne"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L615-L616">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#bne"><span class="name">bne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p><code>x != y</code> is boolean not-equal. It is the negation of <code>x == y</code> which is supplied by
the <code><a href=".././Init/Prelude.html#BEq">BEq</a></code> typeclass.</p><p>Unlike <code>x ≠ y</code> (which is notation for <code><a href=".././Init/Core.html#Ne">Ne</a> x y</code>), this is <code><a href=".././Init/Prelude.html#Bool">Bool</a></code> valued instead of
<code>Prop</code> valued. It is mainly intended for programming applications.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#bne">!=</a> <span class="fn">b</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#not">!</a><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span></span></span></span></li></ul></details><details id="instances-for-list-bne" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_!=_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L618-L618">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_!=_»"><span class="name">«term_!=_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>x != y</code> is boolean not-equal. It is the negation of <code>x == y</code> which is supplied by
the <code><a href=".././Init/Prelude.html#BEq">BEq</a></code> typeclass.</p><p>Unlike <code>x ≠ y</code> (which is notation for <code><a href=".././Init/Core.html#Ne">Ne</a> x y</code>), this is <code><a href=".././Init/Prelude.html#Bool">Bool</a></code> valued instead of
<code>Prop</code> valued. It is mainly intended for programming applications.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_!=_»">«term_!=_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_!=_</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; != &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term_!=_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="LawfulBEq"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L625-L629">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#LawfulBEq"><span class="name">LawfulBEq</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> α</code> is a typeclass which asserts that the <code><a href=".././Init/Prelude.html#BEq">BEq</a> α</code> implementation
(which supplies the <code>a == b</code> notation) coincides with logical equality <code>a = b</code>.
In other words, <code>a == b</code> implies <code>a = b</code>, and <code>a == a</code> is true.</p><ul class="structure_fields" id="LawfulBEq.mk"><li id="LawfulBEq.eq_of_beq" class="structure_field"><div class="structure_field_info">eq_of_beq : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span> → <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></div><div class="structure_field_doc"><p>If <code>a == b</code> evaluates to <code>true</code>, then <code>a</code> and <code>b</code> are equal in the logic.</p></div></li><li id="LawfulBEq.rfl" class="structure_field"><div class="structure_field_info">rfl : <span class="fn">∀ {<span class="fn">a</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></span></div><div class="structure_field_doc"><p><code>==</code> is reflexive, that is, <code>(a == a) = true</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-LawfulBEq" class="instances-list"></ul></details></div></div><div class="decl" id="LawfulBEq.eq_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L627-L627">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#LawfulBEq.eq_of_beq"><span class="name">LawfulBEq</span>.<span class="name">eq_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span> → <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div><p>If <code>a == b</code> evaluates to <code>true</code>, then <code>a</code> and <code>b</code> are equal in the logic.</p></div></div><div class="decl" id="LawfulBEq.rfl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L629-L629">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#LawfulBEq.rfl"><span class="name">LawfulBEq</span>.<span class="name">rfl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></div></div><p><code>==</code> is reflexive, that is, <code>(a == a) = true</code>.</p></div></div><div class="decl" id="instLawfulBEqBool"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L633-L635">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instLawfulBEqBool"><span class="name">instLawfulBEqBool</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instLawfulBEqBool">instLawfulBEqBool</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="instLawfulBEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L637-L639">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instLawfulBEq"><span class="name">instLawfulBEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="instLawfulBEqChar"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L641-L641">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instLawfulBEqChar"><span class="name">instLawfulBEqChar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <a href=".././Init/Prelude.html#Char">Char</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instLawfulBEqChar">instLawfulBEqChar</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="instLawfulBEqString"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L643-L643">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instLawfulBEqString"><span class="name">instLawfulBEqString</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <a href=".././Init/Prelude.html#String">String</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instLawfulBEqString">instLawfulBEqString</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Logical-connectives-and-equality">Logical connectives and equality <a class="hover-link" href="#Logical-connectives-and-equality">#</a></h1></div><div class="decl" id="trivial"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L647-L647">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#trivial"><span class="name">trivial</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#True">True</a></div></div><p><code><a href=".././Init/Prelude.html#True">True</a></code> is true, and <code><a href=".././Init/Prelude.html#True.intro">True.intro</a></code> (or more commonly, <code><a href=".././Init/Core.html#trivial">trivial</a></code>)
is the proof.</p></div></div><div class="decl" id="mt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L649-L650">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#mt"><span class="name">mt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L652-L652">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_false"><span class="name">not_false</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="not_not_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L654-L655">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_not_intro"><span class="name">not_not_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">p</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div></div></div><div class="decl" id="proof_irrel"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L658-L658">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#proof_irrel"><span class="name">proof_irrel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn">a</span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">h₁</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">h₂</span></span></div></div></div></div><div class="decl" id="Eq.mp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L667-L668">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.mp"><span class="name">Eq</span>.<span class="name">mp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>If <code>h : α = β</code> is a proof of type equality, then <code>h.<a href=".././Init/Core.html#Iff.mp">mp</a> : α → β</code> is the induced
&quot;cast&quot; operation, mapping elements of <code>α</code> to elements of <code>β</code>.</p><p>You can prove theorems about the resulting element by induction on <code>h</code>, since
<code>rfl.<a href=".././Init/Core.html#Iff.mp">mp</a></code> is definitionally the identity function.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">h</span>.mp</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">h</span> ▸ <span class="fn">a</span></span></span></li></ul></details><details id="instances-for-list-Eq.mp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Eq.mpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L677-L678">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.mpr"><span class="name">Eq</span>.<span class="name">mpr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>If <code>h : α = β</code> is a proof of type equality, then <code>h.<a href=".././Init/Core.html#Iff.mpr">mpr</a> : β → α</code> is the induced
&quot;cast&quot; operation in the reverse direction, mapping elements of <code>β</code> to elements of <code>α</code>.</p><p>You can prove theorems about the resulting element by induction on <code>h</code>, since
<code>rfl.<a href=".././Init/Core.html#Iff.mpr">mpr</a></code> is definitionally the identity function.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">h</span>.mpr</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span> ▸ <span class="fn">b</span></span></span></li></ul></details><details id="instances-for-list-Eq.mpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Eq.substr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L681-L682">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.substr"><span class="name">Eq</span>.<span class="name">substr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="cast_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L684-L685">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#cast_eq"><span class="name">cast_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#cast">cast</a> <span class="fn">h</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Ne"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L691-L692">source</a></div><div class="attributes">@[reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Ne"><span class="name">Ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code>a ≠ b</code>, or <code><a href=".././Init/Core.html#Ne">Ne</a> a b</code> is defined as <code>¬ (a = b)</code> or <code>a = b → <a href=".././Init/Prelude.html#False">False</a></code>,
and asserts that <code>a</code> and <code>b</code> are not equal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></li></ul></details><details id="instances-for-list-Ne" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_≠_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L694-L694">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_≠_»"><span class="name">«term_≠_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a ≠ b</code>, or <code><a href=".././Init/Core.html#Ne">Ne</a> a b</code> is defined as <code>¬ (a = b)</code> or <code>a = b → <a href=".././Init/Prelude.html#False">False</a></code>,
and asserts that <code>a</code> and <code>b</code> are not equal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_≠_»">«term_≠_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_≠_</span> <span class="fn">50</span> <span class="fn">51</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ≠ &quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-«term_≠_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ne.intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L700-L700">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Ne.intro"><span class="name">Ne</span>.<span class="name">intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Ne.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L702-L702">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Ne.elim"><span class="name">Ne</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="Ne.irrefl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L704-L704">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Ne.irrefl"><span class="name">Ne</span>.<span class="name">irrefl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="Ne.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L706-L706">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Ne.symm"><span class="name">Ne</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="ne_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L708-L708">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ne_comm"><span class="name">ne_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="false_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L710-L710">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#false_of_ne"><span class="name">false_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> → <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="ne_false_of_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L712-L713">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ne_false_of_self"><span class="name">ne_false_of_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> → <span class="fn"><span class="fn">p</span> <a href=".././Init/Core.html#Ne">≠</a> <a href=".././Init/Prelude.html#False">False</a></span></span></div></div></div></div><div class="decl" id="ne_true_of_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L715-L718">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ne_true_of_not"><span class="name">ne_true_of_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn"><span class="fn">p</span> <a href=".././Init/Core.html#Ne">≠</a> <a href=".././Init/Prelude.html#True">True</a></span></span></div></div></div></div><div class="decl" id="true_ne_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L720-L720">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#true_ne_false"><span class="name">true_ne_false</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><a href=".././Init/Prelude.html#True">True</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#False">False</a></span></span></div></div></div></div><div class="decl" id="false_ne_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L721-L721">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#false_ne_true"><span class="name">false_ne_true</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#False">False</a> <a href=".././Init/Core.html#Ne">≠</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="Bool.of_not_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L725-L727">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Bool.of_not_eq_true"><span class="name">Bool</span>.<span class="name">of_not_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></span> → <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="Bool.of_not_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L729-L731">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Bool.of_not_eq_false"><span class="name">Bool</span>.<span class="name">of_not_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></span> → <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="ne_of_beq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L733-L734">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ne_of_beq_false"><span class="name">ne_of_beq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="beq_false_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L736-L739">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#beq_false_of_ne"><span class="name">beq_false_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="HEq.ndrec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L745-L746">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.ndrec"><span class="name">HEq</span>.<span class="name">ndrec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u2} → <span class="fn"><span class="fn">β</span> → <a href=".././foundational_types.html">Sort</a> u1</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">motive</span> <span class="fn">a</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">b</span></span></div></div><p>Non-dependent recursor for <code><a href=".././Init/Prelude.html#HEq">HEq</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#HEq.ndrec">HEq.ndrec</a> <span class="fn">m</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#HEq.rec">HEq.rec</a> <span class="fn">m</span> <span class="fn">h</span></span></span></li></ul></details><details id="instances-for-list-HEq.ndrec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="HEq.ndrecOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L749-L750">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.ndrecOn"><span class="name">HEq</span>.<span class="name">ndrecOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u2} → <span class="fn"><span class="fn">β</span> → <a href=".././foundational_types.html">Sort</a> u1</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">motive</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">b</span></span></div></div><p><code><a href=".././Init/Core.html#HEq.ndrec">HEq.ndrec</a></code> variant</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#HEq.ndrecOn">HEq.ndrecOn</a> <span class="fn">h</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#HEq.rec">HEq.rec</a> <span class="fn">m</span> <span class="fn">h</span></span></span></li></ul></details><details id="instances-for-list-HEq.ndrecOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="HEq.elim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L753-L754">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.elim"><span class="name">HEq</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></div></div><p><code><a href=".././Init/Core.html#HEq.ndrec">HEq.ndrec</a></code> variant</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">h₁</span>.elim</span> <span class="fn">h₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span> ▸ <span class="fn">h₂</span></span></span></li></ul></details><details id="instances-for-list-HEq.elim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="HEq.subst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L756-L757">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.subst"><span class="name">HEq</span>.<span class="name">subst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">T</span> : <a href=".././foundational_types.html">Sort</a> u) → <span class="fn"><span class="fn">T</span> → <a href=".././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">p</span> <span class="fn">α</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">β</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="HEq.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L759-L760">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.symm"><span class="name">HEq</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="heq_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L762-L763">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_of_eq"><span class="name">heq_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">a'</span></span></div></div></div></div><div class="decl" id="HEq.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L765-L766">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.trans"><span class="name">HEq</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{φ : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">φ</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="heq_of_heq_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L768-L769">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_of_heq_of_eq"><span class="name">heq_of_heq_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b' : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b'</span></span></div></div></div></div><div class="decl" id="heq_of_eq_of_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L771-L772">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_of_eq_of_heq"><span class="name">heq_of_eq_of_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a'</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="type_eq_of_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L774-L775">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#type_eq_of_heq"><span class="name">type_eq_of_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span></span></div></div></div></div><div class="decl" id="eqRec_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L779-L780">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#eqRec_heq"><span class="name">eqRec_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{φ : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">φ</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<a href=".././Init/Prelude.html#Eq.recOn">Eq.recOn</a> <span class="fn">h</span> <span class="fn">p</span>)</span> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="heq_of_eqRec_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L782-L785">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_of_eqRec_eq"><span class="name">heq_of_eqRec_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn"><span class="fn">h₁</span> ▸ <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="cast_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L787-L788">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#cast_heq"><span class="name">cast_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<a href=".././Init/Prelude.html#cast">cast</a> <span class="fn">h</span> <span class="fn">a</span>)</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="iff_iff_implies_and_implies"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L792-L793">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_iff_implies_and_implies"><span class="name">iff_iff_implies_and_implies</span></a></span><span class="decl_args">
<span class="fn">(a : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn">b</span> → <span class="fn">a</span>)</span></span></span></div></div></div></div><div class="decl" id="Iff.refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L795-L796">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.refl"><span class="name">Iff</span>.<span class="name">refl</span></a></span><span class="decl_args">
<span class="fn">(a : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Iff.rfl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L798-L799">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.rfl"><span class="name">Iff</span>.<span class="name">rfl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Iff.of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L803-L803">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.of_eq"><span class="name">Iff</span>.<span class="name">of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Iff.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L805-L806">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.trans"><span class="name">Iff</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="instTransIff"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L809-L810">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instTransIff"><span class="name">instTransIff</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Trans">Trans</a> <a href=".././Init/Core.html#Iff">Iff</a> <a href=".././Init/Core.html#Iff">Iff</a> <a href=".././Init/Core.html#Iff">Iff</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instTransIff">instTransIff</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">trans</span> := <span class="fn">⋯</span> }</span></span></li></ul></details></div></div><div class="decl" id="Eq.comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L812-L812">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.comm"><span class="name">Eq</span>.<span class="name">comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="eq_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L813-L813">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#eq_comm"><span class="name">eq_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Iff.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L815-L815">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.symm"><span class="name">Iff</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Iff.comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L816-L816">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.comm"><span class="name">Iff</span>.<span class="name">comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span>)</span></span></div></div></div></div><div class="decl" id="iff_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L817-L817">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_comm"><span class="name">iff_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span>)</span></span></div></div></div></div><div class="decl" id="And.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L819-L819">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#And.symm"><span class="name">And</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="And.comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L820-L820">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#And.comm"><span class="name">And</span>.<span class="name">comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="and_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L821-L821">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#and_comm"><span class="name">and_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Or.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L823-L823">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Or.symm"><span class="name">Or</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Or.comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L824-L824">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Or.comm"><span class="name">Or</span>.<span class="name">comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="or_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L825-L825">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#or_comm"><span class="name">or_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">a</span></span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Exists">Exists <a class="hover-link" href="#Exists">#</a></h1></div><div class="decl" id="Exists.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L829-L832">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Exists.elim"><span class="name">Exists</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Decidable">Decidable <a class="hover-link" href="#Decidable">#</a></h1></div><div class="decl" id="decide_true_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L836-L839">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#decide_true_eq_true"><span class="name">decide_true_eq_true</span></a></span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <a href=".././Init/Prelude.html#True">True</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <a href=".././Init/Prelude.html#True">True</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="decide_false_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L841-L844">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#decide_false_eq_false"><span class="name">decide_false_eq_false</span></a></span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <a href=".././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <a href=".././Init/Prelude.html#False">False</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="toBoolUsing"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L847-L848">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#toBoolUsing"><span class="name">toBoolUsing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(d : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Similar to <code>decide</code>, but uses an explicit instance</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#toBoolUsing">toBoolUsing</a> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">p</span></span></span></li></ul></details><details id="instances-for-list-toBoolUsing" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="toBoolUsing_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L850-L851">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#toBoolUsing_eq_true"><span class="name">toBoolUsing_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(d : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">p</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Core.html#toBoolUsing">toBoolUsing</a> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="ofBoolUsing_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L853-L854">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ofBoolUsing_eq_true"><span class="name">ofBoolUsing_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href=".././Init/Core.html#toBoolUsing">toBoolUsing</a> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div></div></div><div class="decl" id="ofBoolUsing_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L856-L857">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ofBoolUsing_eq_false"><span class="name">ofBoolUsing_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href=".././Init/Core.html#toBoolUsing">toBoolUsing</a> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></div></div></div></div><div class="decl" id="instDecidableTrue"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L859-L860">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableTrue"><span class="name">instDecidableTrue</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instDecidableTrue">instDecidableTrue</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <a href=".././Init/Core.html#trivial">trivial</a></span></span></li></ul></details></div></div><div class="decl" id="instDecidableFalse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L862-L863">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableFalse"><span class="name">instDecidableFalse</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <a href=".././Init/Prelude.html#False">False</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instDecidableFalse">instDecidableFalse</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <a href=".././Init/Core.html#not_false">not_false</a></span></span></li></ul></details></div></div><div class="decl" id="Decidable.byCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L873-L876">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Decidable.byCases"><span class="name">Decidable</span>.<span class="name">byCases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dec : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h1 : <span class="fn"><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h2 : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">q</span></div></div><p>Synonym for <code><a href=".././Init/Prelude.html#dite">dite</a></code> (dependent if-then-else). We can construct an element <code>q</code>
(of any sort, not just a proposition) by cases on whether <code>p</code> is true or false,
provided <code>p</code> is decidable.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Decidable.byCases">Decidable.byCases</a> <span class="fn">h1</span> <span class="fn">h2</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">dec</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">h</span></span> =&gt; <span class="fn"><span class="fn">h1</span> <span class="fn">h</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">h</span></span> =&gt; <span class="fn"><span class="fn">h2</span> <span class="fn">h</span></span></span></span></li></ul></details><details id="instances-for-list-Decidable.byCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Decidable.em"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L878-L879">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Decidable.em"><span class="name">Decidable</span>.<span class="name">em</span></a></span><span class="decl_args">
<span class="fn">(p : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div></div></div><div class="decl" id="Decidable.byContradiction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L882-L883">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Decidable.byContradiction"><span class="name">Decidable</span>.<span class="name">byContradiction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dec : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div></div></div><div class="decl" id="Decidable.of_not_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L885-L886">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Decidable.of_not_not"><span class="name">Decidable</span>.<span class="name">of_not_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span> → <span class="fn">p</span></span></div></div></div></div><div class="decl" id="Decidable.not_and_iff_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L888-L896">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Decidable.not_and_iff_or_not"><span class="name">Decidable</span>.<span class="name">not_and_iff_or_not</span></a></span><span class="decl_args">
<span class="fn">(p : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(q : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[d₁ : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[d₂ : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">p</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">q</span>)</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">q</span></span></span></span></div></div></div></div><div class="decl" id="decidable_of_decidable_of_iff"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L903-L907">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#decidable_of_decidable_of_iff"><span class="name">decidable_of_decidable_of_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span></div></div><p>Transfer a decidability proof across an equivalence of propositions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#decidable_of_decidable_of_iff">decidable_of_decidable_of_iff</a> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if hp : <span class="fn">p</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></span></li></ul></details><details id="instances-for-list-decidable_of_decidable_of_iff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="decidable_of_decidable_of_eq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L910-L911">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#decidable_of_decidable_of_eq"><span class="name">decidable_of_decidable_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">p</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span></div></div><p>Transfer a decidability proof across an equality of propositions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#decidable_of_decidable_of_eq">decidable_of_decidable_of_eq</a> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#decidable_of_decidable_of_iff">decidable_of_decidable_of_iff</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-decidable_of_decidable_of_eq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableForall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L914-L918">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableForall"><span class="name">instDecidableForall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">p</span> → <span class="fn">q</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableForall</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if hp : <span class="fn">p</span> then <span class="fn">if hq : <span class="fn">q</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableIff"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L920-L930">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableIff"><span class="name">instDecidableIff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">q</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableIff</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if hp : <span class="fn">p</span> then <span class="fn">if hq : <span class="fn">q</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span> else <span class="fn">if hq : <span class="fn">q</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></span></span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="if-then-else-expression-theorems">if-then-else expression theorems <a class="hover-link" href="#if-then-else-expression-theorems">#</a></h1></div><div class="decl" id="if_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L934-L937">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#if_pos"><span class="name">if_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hc : <span class="fn">c</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if <span class="fn">c</span> then <span class="fn">t</span> else <span class="fn">e</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="if_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L939-L942">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#if_neg"><span class="name">if_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hnc : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if <span class="fn">c</span> then <span class="fn">t</span> else <span class="fn">e</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></span></div></div></div></div><div class="decl" id="iteInduction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L945-L949">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iteInduction"><span class="name">iteInduction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hpos : <span class="fn"><span class="fn">c</span> → <span class="fn"><span class="fn">motive</span> <span class="fn">t</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hneg : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span> → <span class="fn"><span class="fn">motive</span> <span class="fn">e</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">(if <span class="fn">c</span> then <span class="fn">t</span> else <span class="fn">e</span>)</span></span></div></div><p>Split an if-then-else into cases. The <code>split</code> tactic is generally easier to use than this theorem.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#iteInduction">iteInduction</a> <span class="fn">hpos</span> <span class="fn">hneg</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">inst</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">h</span></span> =&gt; <span class="fn"><span class="fn">hpos</span> <span class="fn">h</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">h</span></span> =&gt; <span class="fn"><span class="fn">hneg</span> <span class="fn">h</span></span></span></span></li></ul></details><details id="instances-for-list-iteInduction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="dif_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L951-L954">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#dif_pos"><span class="name">dif_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hc : <span class="fn">c</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><span class="fn">c</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#dite">dite</a> <span class="fn">c</span> <span class="fn">t</span> <span class="fn">e</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">t</span> <span class="fn">hc</span></span></span></div></div></div></div><div class="decl" id="dif_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L956-L959">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#dif_neg"><span class="name">dif_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hnc : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><span class="fn">c</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#dite">dite</a> <span class="fn">c</span> <span class="fn">t</span> <span class="fn">e</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span> <span class="fn">hnc</span></span></span></div></div></div></div><div class="decl" id="dif_eq_if"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L962-L965">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#dif_eq_if"><span class="name">dif_eq_if</span></a></span><span class="decl_args">
<span class="fn">(c : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(t : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if x : <span class="fn">c</span> then <span class="fn">t</span> else <span class="fn">e</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">c</span> then <span class="fn">t</span> else <span class="fn">e</span></span></span></div></div></div></div><div class="decl" id="instDecidableIte"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L967-L970">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableIte"><span class="name">instDecidableIte</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dC : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dT : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">t</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dE : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">e</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(if <span class="fn">c</span> then <span class="fn">t</span> else <span class="fn">e</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableIte</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">dC</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">h</span></span> =&gt; <span class="fn">dT</span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">h</span></span> =&gt; <span class="fn">dE</span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableDite"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L972-L975">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableDite"><span class="name">instDecidableDite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><span class="fn">c</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dC : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dT : <span class="fn">(<span class="fn">h</span> : <span class="fn">c</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">t</span> <span class="fn">h</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dE : <span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">e</span> <span class="fn">h</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(if h : <span class="fn">c</span> then <span class="fn"><span class="fn">t</span> <span class="fn">h</span></span> else <span class="fn"><span class="fn">e</span> <span class="fn">h</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableDite</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">dC</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">hc</span></span> =&gt; <span class="fn"><span class="fn">dT</span> <span class="fn">hc</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">hc</span></span> =&gt; <span class="fn"><span class="fn">dE</span> <span class="fn">hc</span></span></span></span></li></ul></details></div></div><div class="decl" id="noConfusionTypeEnum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L978-L981">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#noConfusionTypeEnum"><span class="name">noConfusionTypeEnum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(P : <a href=".././foundational_types.html">Sort</a> w)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> w</div></div><p>Auxiliary definition for generating compact <code>noConfusion</code> for enumeration types</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#noConfusionTypeEnum">noConfusionTypeEnum</a> <span class="fn">f</span> <span class="fn">P</span> <span class="fn">x</span> <span class="fn">y</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Decidable.casesOn">Decidable.casesOn</a> <span class="fn">(<span class="fn">inst</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">y</span>)</span>)</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span></span></span>) =&gt; <span class="fn">P</span>)</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span></span>) =&gt; <span class="fn"><span class="fn">P</span> → <span class="fn">P</span></span></span></span></span></li></ul></details><details id="instances-for-list-noConfusionTypeEnum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="noConfusionEnum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L984-L989">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#noConfusionEnum"><span class="name">noConfusionEnum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href=".././foundational_types.html">Sort</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">x</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#noConfusionTypeEnum">noConfusionTypeEnum</a> <span class="fn">f</span> <span class="fn">P</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div><p>Auxiliary definition for generating compact <code>noConfusion</code> for enumeration types</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#noConfusionEnum">noConfusionEnum</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Decidable.casesOn">Decidable.casesOn</a> <span class="fn">(<span class="fn">inst</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">y</span>)</span>)</span> <span class="fn">(fun (<span class="fn">h'</span> : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span></span></span>) =&gt; <span class="fn"><span class="fn">⋯</span>.elim</span>)</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span></span>) (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">x</span></span></span></span></li></ul></details><details id="instances-for-list-noConfusionEnum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Inhabited">Inhabited <a class="hover-link" href="#Inhabited">#</a></h1></div><div class="decl" id="instInhabitedProp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L993-L994">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedProp"><span class="name">instInhabitedProp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././foundational_types.html">Prop</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instInhabitedProp">instInhabitedProp</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href=".././Init/Prelude.html#True">True</a> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedNonScalar"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L996-L996">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedNonScalar"><span class="name">instInhabitedNonScalar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Core.html#NonScalar">NonScalar</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instInhabitedNonScalar">instInhabitedNonScalar</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">val</span> := <span class="fn">default</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedTrue"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L996-L996">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedTrue"><span class="name">instInhabitedTrue</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instInhabitedTrue">instInhabitedTrue</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href=".././Init/Prelude.html#True.intro">True.intro</a> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedPNonScalar"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L996-L996">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedPNonScalar"><span class="name">instInhabitedPNonScalar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Core.html#PNonScalar">PNonScalar</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instInhabitedPNonScalar">instInhabitedPNonScalar</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#PNonScalar.mk">PNonScalar.mk</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedForInStep_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L996-L996">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedForInStep_1"><span class="name">instInhabitedForInStep_1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Type</a> u_1} → <span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">a</span></span>] → <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">a</span>)</span></span></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedForInStep_1</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#ForInStep.done">ForInStep.done</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="nonempty_of_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L998-L999">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#nonempty_of_exists"><span class="name">nonempty_of_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> → <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Subsingleton">Subsingleton <a class="hover-link" href="#Subsingleton">#</a></h1></div><div class="decl" id="Subsingleton"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1011-L1015">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subsingleton"><span class="name">Subsingleton</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>A &quot;subsingleton&quot; is a type with at most one element.
In other words, it is either empty, or has a unique element.
All propositions are subsingletons because of proof irrelevance, but some other types
are subsingletons as well and they inherit many of the same properties as propositions.
<code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> α</code> is a typeclass, so it is usually used as an implicit argument and
inferred by typeclass inference.</p><ul class="structure_ext"><li id="Subsingleton.intro" class="structure_ext_ctor">intro :: (</li><ul class="structure_ext_fields"><li id="Subsingleton.allEq" class="structure_field"><div class="structure_field_info">allEq : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div><div class="structure_field_doc"><p>Any two elements of a subsingleton are equal.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Subsingleton" class="instances-list"></ul></details></div></div><div class="decl" id="Subsingleton.allEq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1015-L1015">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subsingleton.allEq"><span class="name">Subsingleton</span>.<span class="name">allEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div><p>Any two elements of a subsingleton are equal.</p></div></div><div class="decl" id="Subsingleton.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1017-L1018">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subsingleton.elim"><span class="name">Subsingleton</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Subsingleton.helim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1020-L1023">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subsingleton.helim"><span class="name">Subsingleton</span>.<span class="name">helim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h₁ : <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="instSubsingleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1025-L1025">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingleton"><span class="name">instSubsingleton</span></a></span><span class="decl_args">
<span class="fn">(p : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">p</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="instSubsingletonEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1027-L1027">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonEmpty"><span class="name">instSubsingletonEmpty</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <a href=".././Init/Prelude.html#Empty">Empty</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instSubsingletonEmpty">instSubsingletonEmpty</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="instSubsingletonPEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1028-L1028">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonPEmpty"><span class="name">instSubsingletonPEmpty</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <a href=".././Init/Prelude.html#PEmpty">PEmpty</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instSubsingletonPEmpty">instSubsingletonPEmpty</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="instSubsingletonProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1030-L1031">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonProd"><span class="name">instSubsingletonProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="instSubsingletonDecidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1033-L1040">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonDecidable"><span class="name">instSubsingletonDecidable</span></a></span><span class="decl_args">
<span class="fn">(p : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="recSubsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1045-L1054">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#recSubsingleton"><span class="name">recSubsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h₁ : <span class="fn"><span class="fn">p</span> → <a href=".././foundational_types.html">Sort</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h₂ : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <a href=".././foundational_types.html">Sort</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h₃ : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">h₁</span> <span class="fn">h</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h₄ : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">h₂</span> <span class="fn">h</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<a href=".././Init/Prelude.html#Decidable.casesOn">Decidable.casesOn</a> <span class="fn">h</span> <span class="fn">h₂</span> <span class="fn">h₁</span>)</span></span></div></div></div></div><div class="decl" id="Equivalence"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1067-L1073">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Equivalence"><span class="name">Equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>An equivalence relation <code>~ : α → α → Prop</code> is a relation that is:</p><ul>
<li>reflexive: <code>x ~ x</code></li>
<li>symmetric: <code>x ~ y</code> implies <code>y ~ x</code></li>
<li>transitive: <code>x ~ y</code> and <code>y ~ z</code> implies <code>x ~ z</code></li>
</ul><p>Equality is an equivalence relation, and equivalence relations share many of
the properties of equality. In particular, <code><a href=".././Init/Prelude.html#Quot">Quot</a> α <a href=".././Init/Core.html#Setoid.r">r</a></code> is most well behaved
when <code><a href=".././Init/Core.html#Setoid.r">r</a></code> is an equivalence relation, and in this case we use <code><a href=".././Init/Core.html#Quotient">Quotient</a></code> instead.</p><ul class="structure_fields" id="Equivalence.mk"><li id="Equivalence.refl" class="structure_field"><div class="structure_field_info">refl : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">x</span></span></span></div><div class="structure_field_doc"><p>An equivalence relation is reflexive: <code>x ~ x</code></p></div></li><li id="Equivalence.symm" class="structure_field"><div class="structure_field_info">symm : <span class="fn">∀ {<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">y</span> <span class="fn">x</span></span></span></span></div><div class="structure_field_doc"><p>An equivalence relation is symmetric: <code>x ~ y</code> implies <code>y ~ x</code></p></div></li><li id="Equivalence.trans" class="structure_field"><div class="structure_field_info">trans : <span class="fn">∀ {<span class="fn">x </span><span class="fn">y </span><span class="fn">z</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">y</span> <span class="fn">z</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">z</span></span></span></span></span></div><div class="structure_field_doc"><p>An equivalence relation is transitive: <code>x ~ y</code> and <code>y ~ z</code> implies <code>x ~ z</code></p></div></li></ul><details id="instances-for-list-Equivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Equivalence.refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1069-L1069">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Equivalence.refl"><span class="name">Equivalence</span>.<span class="name">refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href=".././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">x</span></span></div></div><p>An equivalence relation is reflexive: <code>x ~ x</code></p></div></div><div class="decl" id="Equivalence.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1071-L1071">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Equivalence.symm"><span class="name">Equivalence</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href=".././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">y</span> <span class="fn">x</span></span></span></div></div><p>An equivalence relation is symmetric: <code>x ~ y</code> implies <code>y ~ x</code></p></div></div><div class="decl" id="Equivalence.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1073-L1073">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Equivalence.trans"><span class="name">Equivalence</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href=".././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{z : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">y</span> <span class="fn">z</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">z</span></span></span></span></div></div><p>An equivalence relation is transitive: <code>x ~ y</code> and <code>y ~ z</code> implies <code>x ~ z</code></p></div></div><div class="decl" id="emptyRelation"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1076-L1077">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#emptyRelation"><span class="name">emptyRelation</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div></div><p>The empty relation is the relation on <code>α</code> which is always <code><a href=".././Init/Prelude.html#False">False</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#emptyRelation">emptyRelation</a> <span class="fn">x✝</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#False">False</a></span></li></ul></details><details id="instances-for-list-emptyRelation" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Subrelation"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1083-L1084">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subrelation"><span class="name">Subrelation</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Subrelation">Subrelation</a> q <a href=".././Init/Core.html#Setoid.r">r</a></code> means that <code>q ⊆ <a href=".././Init/Core.html#Setoid.r">r</a></code> or <code>∀ x y, q x y → <a href=".././Init/Core.html#Setoid.r">r</a> x y</code>.
It is the analogue of the subset relation on relations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Subrelation">Subrelation</a> <span class="fn">q</span> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">∀ {<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span></span></li></ul></details><details id="instances-for-list-Subrelation" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="InvImage"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1090-L1091">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#InvImage"><span class="name">InvImage</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div></div><p>The inverse image of <code><a href=".././Init/Core.html#Setoid.r">r</a> : β → β → Prop</code> by a function <code>α → β</code> is the relation
<code>s : α → α → Prop</code> defined by <code>s a b = <a href=".././Init/Core.html#Setoid.r">r</a> (f a) (f b)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#InvImage">InvImage</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">a₁</span> <span class="fn">a₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">r</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a₁</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a₂</span>)</span></span></span></li></ul></details><details id="instances-for-list-InvImage" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.TransGen"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1098-L1102">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Relation.TransGen"><span class="name">Relation</span>.<span class="name">TransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div></div><p>The transitive closure <code><a href=".././Init/Core.html#Relation.TransGen">TransGen</a> <a href=".././Init/Core.html#Setoid.r">r</a></code> of a relation <code><a href=".././Init/Core.html#Setoid.r">r</a></code> is the smallest relation which is
transitive and contains <code><a href=".././Init/Core.html#Setoid.r">r</a></code>. <code><a href=".././Init/Core.html#Relation.TransGen">TransGen</a> <a href=".././Init/Core.html#Setoid.r">r</a> a z</code> if and only if there exists a sequence
<code>a <a href=".././Init/Core.html#Setoid.r">r</a> b <a href=".././Init/Core.html#Setoid.r">r</a> ... <a href=".././Init/Core.html#Setoid.r">r</a> z</code> of length at least 1 connecting <code>a</code> to <code>z</code>.</p><ul class="constructors"><li class="constructor" id="Relation.TransGen.single">single: <span class="fn">∀ {<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>} {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href=".././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span><div class="inductive_ctor_doc"><p>If <code><a href=".././Init/Core.html#Setoid.r">r</a> a b</code> then <code><a href=".././Init/Core.html#Relation.TransGen">TransGen</a> <a href=".././Init/Core.html#Setoid.r">r</a> a b</code>. This is the base case of the transitive closure.</p></div></li><li class="constructor" id="Relation.TransGen.tail">tail: <span class="fn">∀ {<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>} {<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href=".././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><a href=".././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></span></span></span><div class="inductive_ctor_doc"><p>The transitive closure is transitive.</p></div></li></ul><details id="instances-for-list-Relation.TransGen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="TC"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1105-L1105">source</a></div><div class="attributes">@[reducible, inline, deprecated Relation.TransGen]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#TC"><span class="name">TC</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div></div><p>Deprecated synonym for <code><a href=".././Init/Core.html#Relation.TransGen">Relation.TransGen</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#TC">@<a href=".././Init/Core.html#TC">TC</a></a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#Relation.TransGen">@<a href=".././Init/Core.html#Relation.TransGen">Relation.TransGen</a></a></span></li></ul></details><details id="instances-for-list-TC" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Subtype">Subtype <a class="hover-link" href="#Subtype">#</a></h1></div><div class="decl" id="Subtype.existsOfSubtype"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1111-L1112">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.existsOfSubtype"><span class="name">Subtype</span>.<span class="name">existsOfSubtype</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">{ <span class="fn">x</span> : <span class="fn">α</span> // <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> }</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="Subtype.eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1116-L1117">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.eq"><span class="name">Subtype</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a1 : <span class="fn">{ <span class="fn">x</span> : <span class="fn">α</span> // <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> }</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a2 : <span class="fn">{ <span class="fn">x</span> : <span class="fn">α</span> // <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> }</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a1</span>.val</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a2</span>.val</span></span> → <span class="fn"><span class="fn">a1</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a2</span></span></span></div></div></div></div><div class="decl" id="Subtype.eta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1119-L1121">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.eta"><span class="name">Subtype</span>.<span class="name">eta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">{ <span class="fn">x</span> : <span class="fn">α</span> // <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> }</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">p</span> <span class="fn"><span class="fn">a</span>.val</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⟨<span class="fn"><span class="fn">a</span>.val</span>, <span class="fn">h</span>⟩</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Subtype.instDecidableEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1123-L1126">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.instDecidableEq"><span class="name">Subtype</span>.<span class="name">instDecidableEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">{ <span class="fn">x</span> : <span class="fn">α</span> // <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> }</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x✝</span>.instDecidableEq</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x✝</span> with
  | <span class="fn">⟨<span class="fn">a</span>, <span class="fn">h₁</span>⟩</span> =&gt;
    <span class="fn">match <span class="fn">x</span> with
    | <span class="fn">⟨<span class="fn">b</span>, <span class="fn">h₂</span>⟩</span> =&gt; <span class="fn">if h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></span></span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Sum">Sum <a class="hover-link" href="#Sum">#</a></h1></div><div class="decl" id="Sum.inhabitedLeft"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1135-L1136">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sum.inhabitedLeft"><span class="name">Sum</span>.<span class="name">inhabitedLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Sum.inhabitedLeft</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#Sum.inl">Sum.inl</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Sum.inhabitedRight"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1138-L1139">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sum.inhabitedRight"><span class="name">Sum</span>.<span class="name">inhabitedRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Sum.inhabitedRight</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#Sum.inr">Sum.inr</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instDecidableEqSum"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1141-L1150">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqSum"><span class="name">instDecidableEqSum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">(<span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Product">Product <a class="hover-link" href="#Product">#</a></h1></div><div class="decl" id="instInhabitedProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1156-L1157">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedProd"><span class="name">instInhabitedProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedProd</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">(<span class="fn">default</span>, <span class="fn">default</span>)</span> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedMProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1159-L1160">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedMProd"><span class="name">instInhabitedMProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href=".././Init/Prelude.html#MProd">MProd</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedMProd</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">⟨<span class="fn">default</span>, <span class="fn">default</span>⟩</span> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedPProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1162-L1163">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedPProd"><span class="name">instInhabitedPProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">α</span> <a href=".././Init/Prelude.html#PProd">×'</a> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedPProd</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">⟨<span class="fn">default</span>, <span class="fn">default</span>⟩</span> }</span></span></li></ul></details></div></div><div class="decl" id="instDecidableEqProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1165-L1172">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqProd"><span class="name">instDecidableEqProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">(<span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="instBEqProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1174-L1175">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instBEqProd"><span class="name">instBEqProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">(<span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instBEqProd</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">{
    <span class="fn">beq</span> := <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>) =&gt;
      <span class="fn">match <span class="fn">x</span> with
      | <span class="fn">(<span class="fn">a₁</span>, <span class="fn">b₁</span>)</span> =&gt;
        <span class="fn">match <span class="fn">x_1</span> with
        | <span class="fn">(<span class="fn">a₂</span>, <span class="fn">b₂</span>)</span> =&gt; <span class="fn"><span class="fn"><span class="fn">a₁</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a₂</span></span> <a href=".././Init/Prelude.html#and">&amp;&amp;</a> <span class="fn"><span class="fn">b₁</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b₂</span></span></span></span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Prod.lexLt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1178-L1179">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.lexLt"><span class="name">Prod</span>.<span class="name">lexLt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>Lexicographical order for products</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.lexLt</span> <span class="fn">t</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">s</span>.fst</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">t</span>.fst</span></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.fst</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">t</span>.fst</span></span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">s</span>.snd</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">t</span>.snd</span></span></span>)</span></span></li></ul></details><details id="instances-for-list-Prod.lexLt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Prod.lexLtDec"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1181-L1185">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.lexLtDec"><span class="name">Prod</span>.<span class="name">lexLtDec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">β</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><span class="fn">s</span>.lexLt</span> <span class="fn">t</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x✝</span>.lexLtDec</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">x✝</span>.fst</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">x</span>.fst</span></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">x✝</span>.fst</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span>.fst</span></span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">x✝</span>.snd</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">x</span>.snd</span></span></span>)</span>)</span></span></span></li></ul></details></div></div><div class="decl" id="Prod.lexLt_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1187-L1188">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.lexLt_def"><span class="name">Prod</span>.<span class="name">lexLt_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.lexLt</span> <span class="fn">t</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">s</span>.fst</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">t</span>.fst</span></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.fst</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">t</span>.fst</span></span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">s</span>.snd</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">t</span>.snd</span></span></span>)</span></span></div></div></div></div><div class="decl" id="Prod.eta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1190-L1190">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.eta"><span class="name">Prod</span>.<span class="name">eta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">p</span>.fst</span>, <span class="fn"><span class="fn">p</span>.snd</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="Prod.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1196-L1198">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.map"><span class="name">Prod</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α₁ : <a href=".././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α₂ : <a href=".././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β₁ : <a href=".././foundational_types.html">Type</a> v₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β₂ : <a href=".././foundational_types.html">Type</a> v₂}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α₁</span> → <span class="fn">α₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">β₁</span> → <span class="fn">β₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">α₁</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β₁</span></span> → <span class="fn"><span class="fn">α₂</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β₂</span></span></span></div></div><p><code><a href=".././Init/Core.html#Prod.map">Prod.map</a> f g : α₁ × β₁ → α₂ × β₂</code> maps across a pair
by applying <code>f</code> to the first component and <code>g</code> to the second.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Prod.map">Prod.map</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <span class="fn">(<span class="fn">a</span>, <span class="fn">b</span>)</span> =&gt; <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">a</span></span>, <span class="fn"><span class="fn">g</span> <span class="fn">b</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Prod.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Prod.map_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1200-L1201">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.map_apply"><span class="name">Prod</span>.<span class="name">map_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href=".././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href=".././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">γ</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn">γ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Prod.map">Prod.map</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">(<span class="fn">x</span>, <span class="fn">y</span>)</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">g</span> <span class="fn">y</span></span>)</span></span></div></div></div></div><div class="decl" id="Prod.map_fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1202-L1202">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.map_fst"><span class="name">Prod</span>.<span class="name">map_fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href=".././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href=".././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">γ</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">γ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href=".././Init/Core.html#Prod.map">Prod.map</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">x</span>)</span>.fst</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.fst</span></span></span></div></div></div></div><div class="decl" id="Prod.map_snd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1203-L1203">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.map_snd"><span class="name">Prod</span>.<span class="name">map_snd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href=".././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href=".././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">γ</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">γ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href=".././Init/Core.html#Prod.map">Prod.map</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">x</span>)</span>.snd</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn"><span class="fn">x</span>.snd</span></span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Dependent-products">Dependent products <a class="hover-link" href="#Dependent-products">#</a></h1></div><div class="decl" id="Exists.of_psigma_prop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1207-L1208">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Exists.of_psigma_prop"><span class="name">Exists</span>.<span class="name">of_psigma_prop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) ×' <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="ex_of_PSigma"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1211-L1212">source</a></div><div class="attributes">@[deprecated Exists.of_psigma_prop]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ex_of_PSigma"><span class="name">ex_of_PSigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) ×' <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="PSigma.eta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1214-L1218">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PSigma.eta"><span class="name">PSigma</span>.<span class="name">eta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <span class="fn"><span class="fn">β</span> <span class="fn">a₁</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <span class="fn"><span class="fn">β</span> <span class="fn">a₂</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a₁</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn"><span class="fn">h₁</span> ▸ <span class="fn">b₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⟨<span class="fn">a₁</span>, <span class="fn">b₁</span>⟩</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⟨<span class="fn">a₂</span>, <span class="fn">b₂</span>⟩</span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Universe-polymorphic-unit">Universe polymorphic unit <a class="hover-link" href="#Universe-polymorphic-unit">#</a></h1></div><div class="decl" id="PUnit.subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1222-L1223">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PUnit.subsingleton"><span class="name">PUnit</span>.<span class="name">subsingleton</span></a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#PUnit">PUnit</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#PUnit">PUnit</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="PUnit.eq_punit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1225-L1226">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PUnit.eq_punit"><span class="name">PUnit</span>.<span class="name">eq_punit</span></a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#PUnit">PUnit</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="instSubsingletonPUnit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1228-L1229">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonPUnit"><span class="name">instSubsingletonPUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instSubsingletonPUnit">instSubsingletonPUnit</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedPUnit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1231-L1232">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedPUnit"><span class="name">instInhabitedPUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instInhabitedPUnit">instInhabitedPUnit</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a> }</span></span></li></ul></details></div></div><div class="decl" id="instDecidableEqPUnit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1234-L1235">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqPUnit"><span class="name">instDecidableEqPUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#instDecidableEqPUnit">instDecidableEqPUnit</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Setoid">Setoid <a class="hover-link" href="#Setoid">#</a></h1></div><div class="decl" id="Setoid"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1243-L1247">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Setoid"><span class="name">Setoid</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max 1 u)</div></div><p>A setoid is a type with a distinguished equivalence relation, denoted <code>≈</code>.
This is mainly used as input to the <code><a href=".././Init/Core.html#Quotient">Quotient</a></code> type constructor.</p><ul class="structure_fields" id="Setoid.mk"><li id="Setoid.r" class="structure_field"><div class="structure_field_info">r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div><div class="structure_field_doc"><p><code>x ≈ y</code> is the distinguished equivalence relation of a setoid.</p></div></li><li id="Setoid.iseqv" class="structure_field"><div class="structure_field_info">iseqv : <span class="fn"><a href=".././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">Setoid.r</span></span></div><div class="structure_field_doc"><p>The relation <code>x ≈ y</code> is an equivalence relation.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Setoid" class="instances-list"></ul></details></div></div><div class="decl" id="Setoid.iseqv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1247-L1247">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Setoid.iseqv"><span class="name">Setoid</span>.<span class="name">iseqv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">Setoid.r</span></span></div></div><p>The relation <code>x ≈ y</code> is an equivalence relation.</p></div></div><div class="decl" id="instHasEquivOfSetoid"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1249-L1250">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instHasEquivOfSetoid"><span class="name">instHasEquivOfSetoid</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#HasEquiv">HasEquiv</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHasEquivOfSetoid</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">Equiv</span> := <span class="fn">Setoid.r</span> }</span></span></li></ul></details></div></div><div class="decl" id="Setoid.refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1256-L1257">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Setoid.refl"><span class="name">Setoid</span>.<span class="name">refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Setoid.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1259-L1260">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Setoid.symm"><span class="name">Setoid</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Setoid.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1262-L1263">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Setoid.trans"><span class="name">Setoid</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><span class="fn">b</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">c</span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Propositional-extensionality">Propositional extensionality <a class="hover-link" href="#Propositional-extensionality">#</a></h1></div><div class="decl" id="propext"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1304-L1304">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#propext"><span class="name">propext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> → <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div><p>The axiom of <strong>propositional extensionality</strong>. It asserts that if propositions
<code>a</code> and <code>b</code> are logically equivalent (i.e. we can prove <code>a</code> from <code>b</code> and vice versa),
then <code>a</code> and <code>b</code> are <em>equal</em>, meaning that we can replace <code>a</code> with <code>b</code> in all
contexts.</p><p>For simple expressions like <code>a ∧ c ∨ d → e</code> we can prove that because all the logical
connectives respect logical equivalence, we can replace <code>a</code> with <code>b</code> in this expression
without using <code><a href=".././Init/Core.html#propext">propext</a></code>. However, for higher order expressions like <code>P a</code> where
<code>P : Prop → Prop</code> is unknown, or indeed for <code>a = b</code> itself, we cannot replace <code>a</code> with <code>b</code>
without an axiom which says exactly this.</p><p>This is a relatively uncontroversial axiom, which is intuitionistically valid.
It does however block computation when using <code>#reduce</code> to reduce proofs directly
(which is not recommended), meaning that canonicity,
the property that all closed terms of type <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> normalize to numerals,
fails to hold when this (or any) axiom is used:</p><pre><code>set_option pp.proofs true

def foo : <a href=".././Init/Prelude.html#Nat">Nat</a> := by
  have : (True → True) ↔ <a href=".././Init/Prelude.html#True">True</a> := ⟨λ _ =&gt; trivial, λ _ _ =&gt; trivial⟩
  have := <a href=".././Init/Core.html#propext">propext</a> this ▸ (2 : Nat)
  <a href=".././Init/Core.html#Quotient.exact">exact</a> this

#reduce foo
-- <a href=".././Init/Core.html#propext">propext</a> { <a href=".././Init/Core.html#Iff.mp">mp</a> := fun x x =&gt; True.intro, <a href=".././Init/Core.html#Iff.mpr">mpr</a> := fun x =&gt; <a href=".././Init/Prelude.html#True.intro">True.intro</a> } ▸ 2

#eval foo -- 2
</code></pre><p><code>#eval</code> can evaluate it to a numeral because the compiler erases casts and
does not evaluate proofs, so <code><a href=".././Init/Core.html#propext">propext</a></code>, whose return type is a proposition,
can never block it.</p></div></div><div class="decl" id="Eq.propIntro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1306-L1307">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.propIntro"><span class="name">Eq</span>.<span class="name">propIntro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="instDecidableEqOfIff"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1310-L1313">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqOfIff"><span class="name">instDecidableEqOfIff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[d : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">q</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">p</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableEqOfIff</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">d</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">h</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">h</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></span></li></ul></details></div></div><div class="decl" id="Nat.succ.inj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1330-L1331">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Nat.succ.inj"><span class="name">Nat</span>.<span class="name">succ</span>.<span class="name">inj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">m</span>.succ</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">n</span>.succ</span></span> → <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">n</span></span></span></div></div></div></div><div class="decl" id="Nat.succ.injEq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1333-L1334">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Nat.succ.injEq"><span class="name">Nat</span>.<span class="name">succ</span>.<span class="name">injEq</span></a></span><span class="decl_args">
<span class="fn">(u : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(v : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">u</span>.succ</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">v</span>.succ</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">u</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">v</span>)</span></span></div></div></div></div><div class="decl" id="beq_iff_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1336-L1337">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#beq_iff_eq"><span class="name">beq_iff_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Prop-lemmas">Prop lemmas <a class="hover-link" href="#Prop-lemmas">#</a></h1></div><div class="decl" id="Not.elim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1343-L1343">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Not.elim"><span class="name">Not</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(H1 : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H2 : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><em>Ex falso</em> for negation: from <code>¬a</code> and <code>a</code> anything follows. This is the same as <code><a href=".././Init/Prelude.html#absurd">absurd</a></code> with
the arguments flipped, but it is in the <code><a href=".././Init/Prelude.html#Not">Not</a></code> namespace so that projection notation can be used.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">H1</span>.elim</span> <span class="fn">H2</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#absurd">absurd</a> <span class="fn">H2</span> <span class="fn">H1</span></span></span></li></ul></details><details id="instances-for-list-Not.elim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="And.elim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1346-L1346">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#And.elim"><span class="name">And</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> → <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Non-dependent eliminator for <code><a href=".././Init/Prelude.html#And">And</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#And.elim">And.elim</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">⋯</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-And.elim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Iff.elim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1349-L1349">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.elim"><span class="name">Iff</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn"><span class="fn">(<span class="fn">b</span> → <span class="fn">a</span>)</span> → <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Non-dependent eliminator for <code><a href=".././Init/Core.html#Iff">Iff</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Iff.elim">Iff.elim</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">⋯</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Iff.elim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Iff.subst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1352-L1353">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.subst"><span class="name">Iff</span>.<span class="name">subst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><a href=".././foundational_types.html">Prop</a> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></div></div><p>Iff can now be used to do substitutions in a calculation</p></div></div><div class="decl" id="Not.intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1355-L1355">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Not.intro"><span class="name">Not</span>.<span class="name">intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></div></div></div></div><div class="decl" id="Not.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1357-L1357">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Not.imp"><span class="name">Not</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(H2 : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H1 : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1359-L1359">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_congr"><span class="name">not_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="not_not_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1361-L1361">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_not_not"><span class="name">not_not_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="iff_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1363-L1363">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_of_true"><span class="name">iff_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(ha : <span class="fn">a</span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="iff_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1364-L1364">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_of_false"><span class="name">iff_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(ha : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="iff_true_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1366-L1366">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_true_left"><span class="name">iff_true_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(ha : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="iff_true_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1367-L1367">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_true_right"><span class="name">iff_true_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(ha : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span>)</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="iff_false_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1369-L1369">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_false_left"><span class="name">iff_false_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(ha : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="iff_false_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1370-L1370">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_false_right"><span class="name">iff_false_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(ha : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span>)</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="of_iff_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1372-L1372">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#of_iff_true"><span class="name">of_iff_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span></div></div></div></div><div class="decl" id="iff_true_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1373-L1373">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_true_intro"><span class="name">iff_true_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="eq_iff_true_of_subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1375-L1376">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#eq_iff_true_of_subsingleton"><span class="name">eq_iff_true_of_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="not_of_iff_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1378-L1378">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_of_iff_false"><span class="name">not_of_iff_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a>)</span> → <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div></div></div><div class="decl" id="iff_false_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1379-L1379">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_false_intro"><span class="name">iff_false_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="not_iff_false_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1381-L1381">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_iff_false_intro"><span class="name">not_iff_false_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="not_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1382-L1382">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_true"><span class="name">not_true</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><a href=".././Init/Prelude.html#True">True</a></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="not_false_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1384-L1384">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_false_iff"><span class="name">not_false_iff</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><a href=".././Init/Prelude.html#False">False</a></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="Eq.to_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1386-L1386">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.to_iff"><span class="name">Eq</span>.<span class="name">to_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="iff_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1387-L1387">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_of_eq"><span class="name">iff_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="neq_of_not_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1388-L1388">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#neq_of_not_iff"><span class="name">neq_of_not_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span> → <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="iff_iff_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1390-L1390">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_iff_eq"><span class="name">iff_iff_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="eq_iff_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1391-L1391">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#eq_iff_iff"><span class="name">eq_iff_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="eq_self_iff_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1393-L1393">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#eq_self_iff_true"><span class="name">eq_self_iff_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="ne_self_iff_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1394-L1394">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ne_self_iff_false"><span class="name">ne_self_iff_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="false_of_true_iff_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1396-L1396">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#false_of_true_iff_false"><span class="name">false_of_true_iff_false</span></a></span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#True">True</a> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="false_of_true_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1397-L1397">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#false_of_true_eq_false"><span class="name">false_of_true_eq_false</span></a></span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#True">True</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="true_eq_false_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1399-L1399">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#true_eq_false_of_false"><span class="name">true_eq_false_of_false</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#False">False</a> → <span class="fn"><a href=".././Init/Prelude.html#True">True</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#False">False</a></span></span></div></div></div></div><div class="decl" id="iff_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1401-L1401">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_def"><span class="name">iff_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn">b</span> → <span class="fn">a</span>)</span></span></span></div></div></div></div><div class="decl" id="iff_def'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1402-L1402">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_def'"><span class="name">iff_def'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">b</span> → <span class="fn">a</span>)</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span></span></span></div></div></div></div><div class="decl" id="true_iff_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1404-L1404">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#true_iff_false"><span class="name">true_iff_false</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#True">True</a> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a>)</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="false_iff_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1405-L1405">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#false_iff_true"><span class="name">false_iff_true</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#False">False</a> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a>)</span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="iff_not_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1407-L1407">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_not_self"><span class="name">iff_not_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span>)</span></span></div></div></div></div><div class="decl" id="heq_self_iff_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1408-L1408">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_self_iff_true"><span class="name">heq_self_iff_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">a</span></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="mod_doc"><h2 class="markdown-heading" id="implies">implies <a class="hover-link" href="#implies">#</a></h2></div><div class="decl" id="not_not_of_not_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1412-L1412">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_not_of_not_imp"><span class="name">not_not_of_not_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span></span> → <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="not_of_not_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1414-L1414">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_of_not_imp"><span class="name">not_of_not_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span></span> → <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="imp_not_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1416-L1416">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_not_self"><span class="name">imp_not_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="imp_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1418-L1418">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_intro"><span class="name">imp_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span></div></div></div></div><div class="decl" id="imp_imp_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1420-L1420">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_imp_imp"><span class="name">imp_imp_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₀ : <span class="fn"><span class="fn">c</span> → <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">b</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span></span></div></div></div></div><div class="decl" id="imp_iff_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1422-L1422">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_iff_right"><span class="name">imp_iff_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(ha : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="imp_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1425-L1425">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_true_iff"><span class="name">imp_true_iff</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">α</span> → <a href=".././Init/Prelude.html#True">True</a></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="false_imp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1427-L1427">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#false_imp_iff"><span class="name">false_imp_iff</span></a></span><span class="decl_args">
<span class="fn">(a : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#False">False</a> → <span class="fn">a</span></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="true_imp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1429-L1429">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#true_imp_iff"><span class="name">true_imp_iff</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#True">True</a> → <span class="fn">α</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="imp_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1431-L1431">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_self"><span class="name">imp_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn">a</span></span> <a href=".././Init/Core.html#Iff">↔</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="imp_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1433-L1433">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_false"><span class="name">imp_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <a href=".././Init/Prelude.html#False">False</a></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="imp.swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1435-L1435">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp.swap"><span class="name">imp</span>.<span class="name">swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> → <span class="fn">c</span></span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> → <span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="imp_not_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1437-L1437">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_not_comm"><span class="name">imp_not_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> → <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="imp_congr_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1439-L1439">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_congr_left"><span class="name">imp_congr_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> → <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="imp_congr_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1441-L1442">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_congr_right"><span class="name">imp_congr_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> → <span class="fn">(<span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">c</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="imp_congr_ctx"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1444-L1445">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_congr_ctx"><span class="name">imp_congr_ctx</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">c</span> → <span class="fn">(<span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">d</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span></span></div></div></div></div><div class="decl" id="imp_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1447-L1447">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_congr"><span class="name">imp_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span></span></div></div></div></div><div class="decl" id="imp_iff_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1449-L1449">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#imp_iff_not"><span class="name">imp_iff_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Quotients">Quotients <a class="hover-link" href="#Quotients">#</a></h1></div><div class="decl" id="Quot.sound"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1484-L1484">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.sound"><span class="name">Quot</span>.<span class="name">sound</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">b</span></span></span></span></div></div><p>The <strong>quotient axiom</strong>, or at least the nontrivial part of the quotient
axiomatization. Quotient types are introduced by the <code>init_quot</code> command
in <code><a href=".././Init/Prelude.html">Init.Prelude</a></code> which introduces the axioms:</p><pre><code>opaque <a href=".././Init/Prelude.html#Quot">Quot</a> {α : Sort u} (r : α → α → Prop) : Sort u

opaque <a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> {α : Sort u} (r : α → α → Prop) (a : α) : <a href=".././Init/Prelude.html#Quot">Quot</a> <a href=".././Init/Core.html#Setoid.r">r</a>

opaque <a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> {α : Sort u} {r : α → α → Prop} {β : Sort v} (f : α → β) :
  (∀ a b : α, <a href=".././Init/Core.html#Setoid.r">r</a> a b → f a = f b) → <a href=".././Init/Prelude.html#Quot">Quot</a> <a href=".././Init/Core.html#Setoid.r">r</a> → β

opaque <a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a> {α : Sort u} {r : α → α → Prop} {β : <a href=".././Init/Prelude.html#Quot">Quot</a> <a href=".././Init/Core.html#Setoid.r">r</a> → Prop} :
  (∀ a : α, β (Quot.<a href=".././Init/Core.html#Thunk.mk">mk</a> <a href=".././Init/Core.html#Setoid.r">r</a> a)) → ∀ q : <a href=".././Init/Prelude.html#Quot">Quot</a> r, β q
</code></pre><p>All of these axioms are true if we assume <code><a href=".././Init/Prelude.html#Quot">Quot</a> α <a href=".././Init/Core.html#Setoid.r">r</a> = α</code> and <code><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a></code> and
<code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code> are identity functions, so they do not add much. However this axiom
cannot be explained in that way (it is false for that interpretation), so the
real power of quotient types come from this axiom.</p><p>It says that the quotient by <code><a href=".././Init/Core.html#Setoid.r">r</a></code> maps elements which are related by <code><a href=".././Init/Core.html#Setoid.r">r</a></code> to equal
values in the quotient. Together with <code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code> which says that functions
which respect <code><a href=".././Init/Core.html#Setoid.r">r</a></code> can be lifted to functions on the quotient, we can deduce that
<code><a href=".././Init/Prelude.html#Quot">Quot</a> α <a href=".././Init/Core.html#Setoid.r">r</a></code> exactly consists of the equivalence classes with respect to <code><a href=".././Init/Core.html#Setoid.r">r</a></code>.</p><p>It is important to note that <code><a href=".././Init/Core.html#Setoid.r">r</a></code> need not be an equivalence relation in this axiom.
When <code><a href=".././Init/Core.html#Setoid.r">r</a></code> is not an equivalence relation, we are actually taking a quotient with
respect to the equivalence relation generated by <code><a href=".././Init/Core.html#Setoid.r">r</a></code>.</p></div></div><div class="decl" id="Quot.liftBeta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1486-L1491">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.liftBeta"><span class="name">Quot</span>.<span class="name">liftBeta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">f</span> <span class="fn">c</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Quot.indBeta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1493-L1497">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.indBeta"><span class="name">Quot</span>.<span class="name">indBeta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Quot.liftOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1503-L1505">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.liftOn"><span class="name">Quot</span>.<span class="name">liftOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p><code><a href=".././Init/Core.html#Quot.liftOn">Quot.liftOn</a> q f h</code> is the same as <code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> f h q</code>. It just reorders
the argument <code>q : <a href=".././Init/Prelude.html#Quot">Quot</a> <a href=".././Init/Core.html#Setoid.r">r</a></code> to be first.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">q</span>.liftOn</span> <span class="fn">f</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">f</span> <span class="fn">c</span> <span class="fn">q</span></span></span></li></ul></details><details id="instances-for-list-Quot.liftOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quot.inductionOn"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1508-L1512">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.inductionOn"><span class="name">Quot</span>.<span class="name">inductionOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div></div></div><div class="decl" id="Quot.exists_rep"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1514-L1515">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.exists_rep"><span class="name">Quot</span>.<span class="name">exists_rep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></span></span></div></div></div></div><div class="decl" id="Quot.indep"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1524-L1525">source</a></div><div class="attributes">@[reducible, macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.indep"><span class="name">Quot</span>.<span class="name">indep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#PSigma">PSigma</a> <span class="fn">motive</span></span></div></div><p>Auxiliary definition for <code><a href=".././Init/Core.html#Quot.rec">Quot.rec</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⟨<span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span>, <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span>⟩</span></span></li></ul></details><details id="instances-for-list-Quot.indep" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quot.indepCoherent"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1527-L1531">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.indepCoherent"><span class="name">Quot</span>.<span class="name">indepCoherent</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">⋯</span> ▸ <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Quot.liftIndepPr1"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1533-L1539">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.liftIndepPr1"><span class="name">Quot</span>.<span class="name">liftIndepPr1</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">⋯</span> ▸ <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">(<a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span>)</span> <span class="fn">⋯</span> <span class="fn">q</span>)</span>.fst</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></span></div></div></div></div><div class="decl" id="Quot.rec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1549-L1553">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.rec"><span class="name">Quot</span>.<span class="name">rec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">⋯</span> ▸ <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>Dependent recursion principle for <code><a href=".././Init/Prelude.html#Quot">Quot</a></code>. This constructor can be tricky to use,
so you should consider the simpler versions if they apply:</p><ul>
<li><code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code>, for nondependent functions</li>
<li><code><a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a></code>, for theorems / proofs of propositions about quotients</li>
<li><code><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a></code>, when the target type is a <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code></li>
<li><code><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a></code>, which uses <code><a href=".././Init/Prelude.html#HEq">HEq</a> (f a) (f b)</code> instead of a <code><a href=".././Init/Core.html#Quot.sound">sound</a> p ▸ f a = f b</code> assummption</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quot.rec">Quot.rec</a> <span class="fn">f</span> <span class="fn">h</span> <span class="fn">q</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Eq.ndrecOn">Eq.ndrecOn</a> <span class="fn">⋯</span> <span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">(<a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span>)</span> <span class="fn">⋯</span> <span class="fn">q</span>)</span>.snd</span></span></span></li></ul></details><details id="instances-for-list-Quot.rec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quot.recOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1555-L1560">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.recOn"><span class="name">Quot</span>.<span class="name">recOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">⋯</span> ▸ <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>Dependent recursion principle for <code><a href=".././Init/Prelude.html#Quot">Quot</a></code>. This constructor can be tricky to use,
so you should consider the simpler versions if they apply:</p><ul>
<li><code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code>, for nondependent functions</li>
<li><code><a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a></code>, for theorems / proofs of propositions about quotients</li>
<li><code><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a></code>, when the target type is a <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code></li>
<li><code><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a></code>, which uses <code><a href=".././Init/Prelude.html#HEq">HEq</a> (f a) (f b)</code> instead of a <code><a href=".././Init/Core.html#Quot.sound">sound</a> p ▸ f a = f b</code> assummption</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quot.recOn">Quot.recOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.rec">Quot.rec</a> <span class="fn">f</span> <span class="fn">h</span> <span class="fn">q</span></span></span></li></ul></details><details id="instances-for-list-Quot.recOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quot.recOnSubsingleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1566-L1573">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.recOnSubsingleton"><span class="name">Quot</span>.<span class="name">recOnSubsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>Dependent induction principle for a quotient, when the target type is a <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code>.
In this case the quotient's side condition is trivial so any function can be lifted.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a> <span class="fn">q</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.rec">Quot.rec</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span>)</span> <span class="fn">⋯</span> <span class="fn">q</span></span></span></li></ul></details><details id="instances-for-list-Quot.recOnSubsingleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quot.hrecOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1580-L1587">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.hrecOn"><span class="name">Quot</span>.<span class="name">hrecOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>Heterogeneous dependent recursion principle for a quotient.
This may be easier to work with since it uses <code><a href=".././Init/Prelude.html#HEq">HEq</a></code> instead of
an <code><a href=".././Init/Prelude.html#Eq.ndrec">Eq.ndrec</a></code> in the hypothesis.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.recOn">Quot.recOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Quot.hrecOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1598-L1599">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient"><span class="name">Quotient</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> u</div></div><p><code><a href=".././Init/Core.html#Quotient">Quotient</a> α s</code> is the same as <code><a href=".././Init/Prelude.html#Quot">Quot</a> α <a href=".././Init/Core.html#Setoid.r">r</a></code>, but it is specialized to a setoid <code>s</code>
(that is, an equivalence relation) instead of an arbitrary relation.
Prefer <code><a href=".././Init/Core.html#Quotient">Quotient</a></code> over <code><a href=".././Init/Prelude.html#Quot">Quot</a></code> if your relation is actually an equivalence relation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">Setoid.r</span></span></span></li></ul></details><details id="instances-for-list-Quotient" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1605-L1606">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.mk"><span class="name">Quotient</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span></div></div><p>The canonical quotient map into a <code><a href=".././Init/Core.html#Quotient">Quotient</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">Setoid.r</span> <span class="fn">a</span></span></span></li></ul></details><details id="instances-for-list-Quotient.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.mk'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1612-L1613">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.mk'"><span class="name">Quotient</span>.<span class="name">mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span></div></div><p>The canonical quotient map into a <code><a href=".././Init/Core.html#Quotient">Quotient</a></code>.
(This synthesizes the setoid by typeclass inference.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.mk'">Quotient.mk'</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span></span></li></ul></details><details id="instances-for-list-Quotient.mk'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.sound"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1619-L1620">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.sound"><span class="name">Quotient</span>.<span class="name">sound</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">b</span></span></span></span></div></div><p>The analogue of <code><a href=".././Init/Core.html#Quot.sound">Quot.sound</a></code>: If <code>a</code> and <code>b</code> are related by the equivalence relation,
then they have equal equivalence classes.</p></div></div><div class="decl" id="Quotient.lift"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1626-L1627">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.lift"><span class="name">Quotient</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <span class="fn">β</span></span></span></div></div><p>The analogue of <code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code>: if <code>f : α → β</code> respects the equivalence relation <code>≈</code>,
then it lifts to a function on <code><a href=".././Init/Core.html#Quotient">Quotient</a> s</code> such that <code><a href=".././Init/Core.html#Quotient.lift">lift</a> f h (mk a) = f a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">f</span></span></span></li></ul></details><details id="instances-for-list-Quotient.lift" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.ind"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1630-L1631">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.ind"><span class="name">Quotient</span>.<span class="name">ind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span>)</span></span>)</span> → <span class="fn">∀ (<span class="fn">q</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>), <span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></span></span></div></div><p>The analogue of <code><a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a></code>: every element of <code><a href=".././Init/Core.html#Quotient">Quotient</a> s</code> is of the form <code><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> s a</code>.</p></div></div><div class="decl" id="Quotient.liftOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1637-L1638">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.liftOn"><span class="name">Quotient</span>.<span class="name">liftOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>The analogue of <code><a href=".././Init/Core.html#Quot.liftOn">Quot.liftOn</a></code>: if <code>f : α → β</code> respects the equivalence relation <code>≈</code>,
then it lifts to a function on <code><a href=".././Init/Core.html#Quotient">Quotient</a> s</code> such that <code><a href=".././Init/Core.html#Quotient.lift">lift</a> (mk a) f h = f a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">q</span>.liftOn</span> <span class="fn">f</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.liftOn">Quot.liftOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">c</span></span></span></li></ul></details><details id="instances-for-list-Quotient.liftOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.inductionOn"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1642-L1646">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.inductionOn"><span class="name">Quotient</span>.<span class="name">inductionOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>The analogue of <code><a href=".././Init/Core.html#Quot.inductionOn">Quot.inductionOn</a></code>: every element of <code><a href=".././Init/Core.html#Quotient">Quotient</a> s</code> is of the form <code><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> s a</code>.</p></div></div><div class="decl" id="Quotient.exists_rep"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1648-L1649">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.exists_rep"><span class="name">Quotient</span>.<span class="name">exists_rep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></span></span></div></div></div></div><div class="decl" id="Quotient.rec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1658-L1663">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.rec"><span class="name">Quotient</span>.<span class="name">rec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">⋯</span> ▸ <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>The analogue of <code><a href=".././Init/Core.html#Quot.rec">Quot.rec</a></code> for <code><a href=".././Init/Core.html#Quotient">Quotient</a></code>. See <code><a href=".././Init/Core.html#Quot.rec">Quot.rec</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.rec">Quotient.rec</a> <span class="fn">f</span> <span class="fn">h</span> <span class="fn">q</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.rec">Quot.rec</a> <span class="fn">f</span> <span class="fn">h</span> <span class="fn">q</span></span></span></li></ul></details><details id="instances-for-list-Quotient.rec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.recOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1667-L1672">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.recOn"><span class="name">Quotient</span>.<span class="name">recOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">⋯</span> ▸ <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>The analogue of <code><a href=".././Init/Core.html#Quot.recOn">Quot.recOn</a></code> for <code><a href=".././Init/Core.html#Quotient">Quotient</a></code>. See <code><a href=".././Init/Core.html#Quot.recOn">Quot.recOn</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.recOn">Quotient.recOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.recOn">Quot.recOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">h</span></span></span></li></ul></details><details id="instances-for-list-Quotient.recOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.recOnSubsingleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1676-L1681">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.recOnSubsingleton"><span class="name">Quotient</span>.<span class="name">recOnSubsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span>)</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>The analogue of <code><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a></code> for <code><a href=".././Init/Core.html#Quotient">Quotient</a></code>. See <code><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.recOnSubsingleton">Quotient.recOnSubsingleton</a> <span class="fn">q</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a> <span class="fn">q</span> <span class="fn">f</span></span></span></li></ul></details><details id="instances-for-list-Quotient.recOnSubsingleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.hrecOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1685-L1690">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.hrecOn"><span class="name">Quotient</span>.<span class="name">hrecOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span> → <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>The analogue of <code><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a></code> for <code><a href=".././Init/Core.html#Quotient">Quotient</a></code>. See <code><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.hrecOn">Quotient.hrecOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">c</span></span></span></li></ul></details><details id="instances-for-list-Quotient.hrecOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.lift₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1699-L1707">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.lift₂"><span class="name">Quotient</span>.<span class="name">lift₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{φ : <a href=".././foundational_types.html">Sort</a> uC}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">φ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">∀ (<span class="fn">a₁</span> : <span class="fn">α</span>) (<span class="fn">b₁</span> : <span class="fn">β</span>) (<span class="fn">a₂</span> : <span class="fn">α</span>) (<span class="fn">b₂</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">a₁</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">a₂</span></span> → <span class="fn"><span class="fn"><span class="fn">b₁</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b₂</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a₁</span> <span class="fn">b₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a₂</span> <span class="fn">b₂</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₁ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₂ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">φ</span></div></div><p>Lift a binary function to a quotient on both arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.lift₂">Quotient.lift₂</a> <span class="fn">f</span> <span class="fn">c</span> <span class="fn">q₁</span> <span class="fn">q₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a> <span class="fn">(fun (<span class="fn">a₁</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a> <span class="fn">(<span class="fn">f</span> <span class="fn">a₁</span>)</span> <span class="fn">⋯</span> <span class="fn">q₂</span></span>)</span> <span class="fn">⋯</span> <span class="fn">q₁</span></span></span></li></ul></details><details id="instances-for-list-Quotient.lift₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.liftOn₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1710-L1716">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.liftOn₂"><span class="name">Quotient</span>.<span class="name">liftOn₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{φ : <a href=".././foundational_types.html">Sort</a> uC}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q₁ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₂ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">φ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">∀ (<span class="fn">a₁</span> : <span class="fn">α</span>) (<span class="fn">b₁</span> : <span class="fn">β</span>) (<span class="fn">a₂</span> : <span class="fn">α</span>) (<span class="fn">b₂</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">a₁</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">a₂</span></span> → <span class="fn"><span class="fn"><span class="fn">b₁</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b₂</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a₁</span> <span class="fn">b₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a₂</span> <span class="fn">b₂</span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">φ</span></div></div><p>Lift a binary function to a quotient on both arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">q₁</span>.liftOn₂</span> <span class="fn">q₂</span> <span class="fn">f</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.lift₂">Quotient.lift₂</a> <span class="fn">f</span> <span class="fn">c</span> <span class="fn">q₁</span> <span class="fn">q₂</span></span></span></li></ul></details><details id="instances-for-list-Quotient.liftOn₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Quotient.ind₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1719-L1727">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.ind₂"><span class="name">Quotient</span>.<span class="name">ind₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span> → <a href=".././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₁</span> <span class="fn">a</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₂</span> <span class="fn">b</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₁ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₂ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q₁</span> <span class="fn">q₂</span></span></div></div></div></div><div class="decl" id="Quotient.inductionOn₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1730-L1738">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.inductionOn₂"><span class="name">Quotient</span>.<span class="name">inductionOn₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span> → <a href=".././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q₁ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₂ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₁</span> <span class="fn">a</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₂</span> <span class="fn">b</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q₁</span> <span class="fn">q₂</span></span></div></div></div></div><div class="decl" id="Quotient.inductionOn₃"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1741-L1752">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.inductionOn₃"><span class="name">Quotient</span>.<span class="name">inductionOn₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{φ : <a href=".././foundational_types.html">Sort</a> uC}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₃ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">φ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₃</span></span> → <a href=".././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q₁ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₂ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₃ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₃</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>) (<span class="fn">c</span> : <span class="fn">φ</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₁</span> <span class="fn">a</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₂</span> <span class="fn">b</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₃</span> <span class="fn">c</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q₁</span> <span class="fn">q₂</span> <span class="fn">q₃</span></span></div></div></div></div><div class="decl" id="Quotient.exact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1774-L1775">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.exact"><span class="name">Quotient</span>.<span class="name">exact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">b</span></span></span> → <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Quotient.recOnSubsingleton₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1786-L1799">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.recOnSubsingleton₂"><span class="name">Quotient</span>.<span class="name">recOnSubsingleton₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span> → <a href=".././foundational_types.html">Sort</a> uC</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[s : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₁</span> <span class="fn">a</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₂</span> <span class="fn">b</span>)</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(q₁ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₂ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₁</span> <span class="fn">a</span>)</span> <span class="fn">(<a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₂</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q₁</span> <span class="fn">q₂</span></span></div></div><p>Lift a binary function to a quotient on both arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.recOnSubsingleton₂">Quotient.recOnSubsingleton₂</a> <span class="fn">q₁</span> <span class="fn">q₂</span> <span class="fn">g</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a> <span class="fn">q₁</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a> <span class="fn">q₂</span> <span class="fn">fun (<span class="fn">a_1</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">a</span> <span class="fn">a_1</span></span></span></span></span></span></span></li></ul></details><details id="instances-for-list-Quotient.recOnSubsingleton₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqQuotientOfDecidableEquiv"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1808-L1814">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqQuotientOfDecidableEquiv"><span class="name">instDecidableEqQuotientOfDecidableEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[d : <span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">(<a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#instDecidableEqQuotientOfDecidableEquiv">instDecidableEqQuotientOfDecidableEquiv</a> <span class="fn">q₁</span> <span class="fn">q₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Core.html#Quotient.recOnSubsingleton₂">Quotient.recOnSubsingleton₂</a> <span class="fn">q₁</span> <span class="fn">q₂</span> <span class="fn">fun (<span class="fn">a₁</span> <span class="fn">a₂</span> : <span class="fn">α</span>) =&gt;
    <span class="fn">match <span class="fn"><span class="fn">d</span> <span class="fn">a₁</span> <span class="fn">a₂</span></span> with
    | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">h₁</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span>
    | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">h₂</span></span> =&gt; <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></span></span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Function-extensionality">Function extensionality <a class="hover-link" href="#Function-extensionality">#</a></h1></div><div class="decl" id="funext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1830-L1838">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#funext"><span class="name">funext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div><p><strong>Function extensionality</strong> is the statement that if two functions take equal values
every point, then the functions themselves are equal: <code>(∀ x, f x = g x) → f = g</code>.
It is called &quot;extensionality&quot; because it talks about how to prove two objects are equal
based on the properties of the object (compare with set extensionality,
which is <code>(∀ x, x ∈ s ↔ x ∈ t) → s = t</code>).</p><p>This is often an axiom in dependent type theory systems, because it cannot be proved
from the core logic alone. However in lean's type theory this follows from the existence
of quotient types (note the <code><a href=".././Init/Core.html#Quot.sound">Quot.sound</a></code> in the proof, as well as the <code>show</code> line
which makes use of the definitional equality <code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> f h (Quot.<a href=".././Init/Core.html#Thunk.mk">mk</a> x) = f x</code>).</p></div></div><div class="decl" id="instSubsingletonForall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1840-L1841">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonForall"><span class="name">instSubsingletonForall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Squash">Squash <a class="hover-link" href="#Squash">#</a></h1></div><div class="decl" id="Squash"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1859-L1859">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Squash"><span class="name">Squash</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p><code><a href=".././Init/Core.html#Squash">Squash</a> α</code> is the quotient of <code>α</code> by the always true relation.
It is empty if <code>α</code> is empty, otherwise it is a singleton.
(Thus it is unconditionally a <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code>.)
It is the &quot;universal <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code>&quot; mapped from <code>α</code>.</p><p>It is similar to <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code>, which has the same properties, but unlike
<code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a></code> this is a <code>Type u</code>, that is, it is &quot;data&quot;, and the compiler
represents an element of <code><a href=".././Init/Core.html#Squash">Squash</a> α</code> the same as <code>α</code> itself
(as compared to <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code>, whose elements are represented by a dummy value).</p><p><code><a href=".././Init/Core.html#Squash.lift">Squash.lift</a></code> will extract a value in any subsingleton <code>β</code> from a function on <code>α</code>,
while <code><a href=".././Init/Prelude.html#Nonempty.rec">Nonempty.rec</a></code> can only do the same when <code>β</code> is a proposition.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href=".././Init/Prelude.html#True">True</a></span></span></span></li></ul></details><details id="instances-for-list-Squash" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Squash.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1862-L1862">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Squash.mk"><span class="name">Squash</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span></div></div><p>The canonical quotient map into <code><a href=".././Init/Core.html#Squash">Squash</a> α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Squash.mk">Squash.mk</a> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">(fun (<span class="fn">x</span> <span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href=".././Init/Prelude.html#True">True</a>)</span> <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-Squash.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Squash.ind"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1864-L1865">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Squash.ind"><span class="name">Squash</span>.<span class="name">ind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">(<a href=".././Init/Core.html#Squash.mk">Squash.mk</a> <span class="fn">a</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div></div></div><div class="decl" id="Squash.lift"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1868-L1869">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Squash.lift"><span class="name">Squash</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>If <code>β</code> is a subsingleton, then a function <code>α → β</code> lifts to <code><a href=".././Init/Core.html#Squash">Squash</a> α → β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.lift</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">f</span> <span class="fn">⋯</span> <span class="fn">s</span></span></span></li></ul></details><details id="instances-for-list-Squash.lift" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instSubsingletonSquash"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1871-L1876">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonSquash"><span class="name">instSubsingletonSquash</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Relations">Relations <a class="hover-link" href="#Relations">#</a></h1></div><div class="decl" id="Antisymm"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1883-L1885">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Antisymm"><span class="name">Antisymm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Antisymm">Antisymm</a> (·≤·)</code> says that <code>(·≤·)</code> is antisymmetric, that is, <code>a ≤ b → b ≤ a → a = b</code>.</p><ul class="structure_fields" id="Antisymm.mk"><li id="Antisymm.antisymm" class="structure_field"><div class="structure_field_info">antisymm : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></span></div><div class="structure_field_doc"><p>An antisymmetric relation <code>(·≤·)</code> satisfies <code>a ≤ b → b ≤ a → a = b</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Antisymm" class="instances-list"></ul></details></div></div><div class="decl" id="Antisymm.antisymm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1885-L1885">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Antisymm.antisymm"><span class="name">Antisymm</span>.<span class="name">antisymm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href=".././Init/Core.html#Antisymm">Antisymm</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></div></div><p>An antisymmetric relation <code>(·≤·)</code> satisfies <code>a ≤ b → b ≤ a → a = b</code>.</p></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Kernel-reduction-hints">Kernel reduction hints <a class="hover-link" href="#Kernel-reduction-hints">#</a></h1></div><div class="decl" id="Lean.trustCompiler"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1893-L1893">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.trustCompiler"><span class="name">Lean</span>.<span class="name">trustCompiler</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#True">True</a></div></div><p>Depends on the correctness of the Lean compiler, interpreter, and all <code>[implemented_by ...]</code> and <code>[extern ...]</code> annotations.</p></div></div><div class="decl" id="Lean.reduceBool"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1914-L1917">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.reduceBool"><span class="name">Lean</span>.<span class="name">reduceBool</span></a></span><span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>When the kernel tries to reduce a term <code><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a> c</code>, it will invoke the Lean interpreter to evaluate <code>c</code>.
The kernel will not use the interpreter if <code>c</code> is not a constant.
This feature is useful for performing proofs by reflection.</p><p>Remark: the Lean frontend allows terms of the from <code><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a> t</code> where <code>t</code> is a term not containing
free variables. The frontend automatically declares a fresh auxiliary constant <code>c</code> and replaces the term with
<code><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a> c</code>. The main motivation is that the code for <code>t</code> will be pre-compiled.</p><p>Warning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.
This is extra 30k lines of code. More importantly, you will probably not be able to check your development using
external type checkers (e.g., Trepplein) that do not implement this feature.
Keep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.
So, you are mainly losing the capability of type checking your development using external checkers.</p><p>Recall that the compiler trusts the correctness of all <code>[implemented_by ...]</code> and <code>[extern ...]</code> annotations.
If an extern function is executed, then the trusted code base will also include the implementation of the associated
foreign function.</p></div></div><div class="decl" id="Lean.reduceNat"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1926-L1929">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.reduceNat"><span class="name">Lean</span>.<span class="name">reduceNat</span></a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Similar to <code><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a></code> for closed <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> terms.</p><p>Remark: we do not have plans for supporting a generic <code>reduceValue {α} (a : α) : α := a</code>.
The main issue is that it is non-trivial to convert an arbitrary runtime object back into a Lean expression.
We believe <code><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a></code> enables most interesting applications (e.g., proof by reflection).</p></div></div><div class="decl" id="Lean.ofReduceBool"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1945-L1945">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.ofReduceBool"><span class="name">Lean</span>.<span class="name">ofReduceBool</span></a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div><p>The axiom <code><a href=".././Init/Core.html#Lean.ofReduceBool">ofReduceBool</a></code> is used to perform proofs by reflection. See <code><a href=".././Init/Core.html#Lean.reduceBool">reduceBool</a></code>.</p><p>This axiom is usually not used directly, because it has some syntactic restrictions.
Instead, the <code>native_decide</code> tactic can be used to prove any proposition whose
decidability instance can be evaluated to <code>true</code> using the lean compiler / interpreter.</p><p>Warning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.
This is extra 30k lines of code. More importantly, you will probably not be able to check your development using
external type checkers (e.g., Trepplein) that do not implement this feature.
Keep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.
So, you are mainly losing the capability of type checking your development using external checkers.</p></div></div><div class="decl" id="Lean.ofReduceNat"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1956-L1956">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.ofReduceNat"><span class="name">Lean</span>.<span class="name">ofReduceNat</span></a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Lean.reduceNat">Lean.reduceNat</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div><p>The axiom <code><a href=".././Init/Core.html#Lean.ofReduceNat">ofReduceNat</a></code> is used to perform proofs by reflection. See <code><a href=".././Init/Core.html#Lean.reduceBool">reduceBool</a></code>.</p><p>Warning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.
This is extra 30k lines of code. More importantly, you will probably not be able to check your development using
external type checkers (e.g., Trepplein) that do not implement this feature.
Keep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.
So, you are mainly losing the capability of type checking your development using external checkers.</p></div></div><div class="decl" id="ge_iff_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1960-L1960">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ge_iff_le"><span class="name">ge_iff_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href=".././Init/Prelude.html#GE.ge">≥</a> <span class="fn">y</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">y</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="gt_iff_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1962-L1962">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#gt_iff_lt"><span class="name">gt_iff_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href=".././Init/Prelude.html#GT.gt">&gt;</a> <span class="fn">y</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">y</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="le_of_eq_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1964-L1964">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#le_of_eq_of_le"><span class="name">le_of_eq_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="le_of_le_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1966-L1966">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#le_of_le_of_eq"><span class="name">le_of_le_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="lt_of_eq_of_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1968-L1968">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#lt_of_eq_of_lt"><span class="name">lt_of_eq_of_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="lt_of_lt_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1970-L1970">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#lt_of_lt_of_eq"><span class="name">lt_of_lt_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Std.Associative"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1979-L1981">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.Associative"><span class="name">Std</span>.<span class="name">Associative</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(op : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.Associative">Associative</a> op</code> indicates <code>op</code> is an associative operation,
i.e. <code>(a ∘ b) ∘ c = a ∘ (b ∘ c)</code>.</p><ul class="structure_fields" id="Std.Associative.mk"><li id="Std.Associative.assoc" class="structure_field"><div class="structure_field_info">assoc : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">(<span class="fn">op</span> <span class="fn">a</span> <span class="fn">b</span>)</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">op</span> <span class="fn">a</span> <span class="fn">(<span class="fn">op</span> <span class="fn">b</span> <span class="fn">c</span>)</span></span></span></span></div><div class="structure_field_doc"><p>An associative operation satisfies <code>(a ∘ b) ∘ c = a ∘ (b ∘ c)</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.Associative" class="instances-list"></ul></details></div></div><div class="decl" id="Std.Associative.assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1981-L1981">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.Associative.assoc"><span class="name">Std</span>.<span class="name">Associative</span>.<span class="name">assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{op : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href=".././Init/Core.html#Std.Associative">Std.Associative</a> <span class="fn">op</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">(<span class="fn">op</span> <span class="fn">a</span> <span class="fn">b</span>)</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">op</span> <span class="fn">a</span> <span class="fn">(<span class="fn">op</span> <span class="fn">b</span> <span class="fn">c</span>)</span></span></span></div></div><p>An associative operation satisfies <code>(a ∘ b) ∘ c = a ∘ (b ∘ c)</code>.</p></div></div><div class="decl" id="Std.Commutative"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1987-L1989">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.Commutative"><span class="name">Std</span>.<span class="name">Commutative</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(op : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.Commutative">Commutative</a> op</code> says that <code>op</code> is a commutative operation,
i.e. <code>a ∘ b = b ∘ a</code>.</p><ul class="structure_fields" id="Std.Commutative.mk"><li id="Std.Commutative.comm" class="structure_field"><div class="structure_field_info">comm : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">op</span> <span class="fn">b</span> <span class="fn">a</span></span></span></span></div><div class="structure_field_doc"><p>A commutative operation satisfies <code>a ∘ b = b ∘ a</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.Commutative" class="instances-list"></ul></details></div></div><div class="decl" id="Std.Commutative.comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1989-L1989">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.Commutative.comm"><span class="name">Std</span>.<span class="name">Commutative</span>.<span class="name">comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{op : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href=".././Init/Core.html#Std.Commutative">Std.Commutative</a> <span class="fn">op</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">op</span> <span class="fn">b</span> <span class="fn">a</span></span></span></div></div><p>A commutative operation satisfies <code>a ∘ b = b ∘ a</code>.</p></div></div><div class="decl" id="Std.IdempotentOp"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1995-L1997">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.IdempotentOp"><span class="name">Std</span>.<span class="name">IdempotentOp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(op : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.IdempotentOp">IdempotentOp</a> op</code> indicates <code>op</code> is an idempotent binary operation.
i.e. <code>a ∘ a = a</code>.</p><ul class="structure_fields" id="Std.IdempotentOp.mk"><li id="Std.IdempotentOp.idempotent" class="structure_field"><div class="structure_field_info">idempotent : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">x</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></span></div><div class="structure_field_doc"><p>An idempotent operation satisfies <code>a ∘ a = a</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.IdempotentOp" class="instances-list"></ul></details></div></div><div class="decl" id="Std.IdempotentOp.idempotent"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L1997-L1997">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.IdempotentOp.idempotent"><span class="name">Std</span>.<span class="name">IdempotentOp</span>.<span class="name">idempotent</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{op : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href=".././Init/Core.html#Std.IdempotentOp">Std.IdempotentOp</a> <span class="fn">op</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">x</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></div></div><p>An idempotent operation satisfies <code>a ∘ a = a</code>.</p></div></div><div class="decl" id="Std.LeftIdentity"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L2005-L2005">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.LeftIdentity"><span class="name">Std</span>.<span class="name">LeftIdentity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(op : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(o : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code>LeftIdentify op o</code> indicates <code>o</code> is a left identity of <code>op</code>.</p><p>This class does not require a proof that <code>o</code> is an identity, and
is used primarily for infering the identity using class resoluton.</p><ul class="structure_fields" id="Std.LeftIdentity.mk"></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.LeftIdentity" class="instances-list"></ul></details></div></div><div class="decl" id="Std.LawfulLeftIdentity"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L2011-L2013">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.LawfulLeftIdentity"><span class="name">Std</span>.<span class="name">LawfulLeftIdentity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(op : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(o : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href=".././Init/Core.html#Std.LeftIdentity"><span class="name">Std</span>.<span class="name">LeftIdentity</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code>LawfulLeftIdentify op o</code> indicates <code>o</code> is a verified left identity of
<code>op</code>.</p><ul class="structure_fields" id="Std.LawfulLeftIdentity.mk"><li id="Std.LawfulLeftIdentity.left_id" class="structure_field"><div class="structure_field_info">left_id : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">o</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></div><div class="structure_field_doc"><p>Left identity <code>o</code> is an identity.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.LawfulLeftIdentity" class="instances-list"></ul></details></div></div><div class="decl" id="Std.LawfulLeftIdentity.left_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L2013-L2013">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.LawfulLeftIdentity.left_id"><span class="name">Std</span>.<span class="name">LawfulLeftIdentity</span>.<span class="name">left_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{op : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{o : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href=".././Init/Core.html#Std.LawfulLeftIdentity">Std.LawfulLeftIdentity</a> <span class="fn">op</span> <span class="fn">o</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">o</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div><p>Left identity <code>o</code> is an identity.</p></div></div><div class="decl" id="Std.RightIdentity"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L2021-L2021">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.RightIdentity"><span class="name">Std</span>.<span class="name">RightIdentity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(op : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(o : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code>RightIdentify op o</code> indicates <code>o</code> is a right identity <code>o</code> of <code>op</code>.</p><p>This class does not require a proof that <code>o</code> is an identity, and is used
primarily for infering the identity using class resoluton.</p><ul class="structure_fields" id="Std.RightIdentity.mk"></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.RightIdentity" class="instances-list"></ul></details></div></div><div class="decl" id="Std.LawfulRightIdentity"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L2027-L2029">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.LawfulRightIdentity"><span class="name">Std</span>.<span class="name">LawfulRightIdentity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(op : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(o : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href=".././Init/Core.html#Std.RightIdentity"><span class="name">Std</span>.<span class="name">RightIdentity</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code>LawfulRightIdentify op o</code> indicates <code>o</code> is a verified right identity of
<code>op</code>.</p><ul class="structure_fields" id="Std.LawfulRightIdentity.mk"><li id="Std.LawfulRightIdentity.right_id" class="structure_field"><div class="structure_field_info">right_id : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">a</span> <span class="fn">o</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></div><div class="structure_field_doc"><p>Right identity <code>o</code> is an identity.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.LawfulRightIdentity" class="instances-list"></ul></details></div></div><div class="decl" id="Std.LawfulRightIdentity.right_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L2029-L2029">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.LawfulRightIdentity.right_id"><span class="name">Std</span>.<span class="name">LawfulRightIdentity</span>.<span class="name">right_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{op : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{o : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href=".././Init/Core.html#Std.LawfulRightIdentity">Std.LawfulRightIdentity</a> <span class="fn">op</span> <span class="fn">o</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">a</span> <span class="fn">o</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div><p>Right identity <code>o</code> is an identity.</p></div></div><div class="decl" id="Std.Identity"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L2037-L2037">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.Identity"><span class="name">Std</span>.<span class="name">Identity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(op : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(o : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href=".././Init/Core.html#Std.LeftIdentity"><span class="name">Std</span>.<span class="name">LeftIdentity</span></a></span></span>
, <span class="decl_parent">
<span class="fn"><a class="break_within" href=".././Init/Core.html#Std.RightIdentity"><span class="name">Std</span>.<span class="name">RightIdentity</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.Identity">Identity</a> op o</code> indicates <code>o</code> is a left and right identity of <code>op</code>.</p><p>This class does not require a proof that <code>o</code> is an identity, and is used
primarily for infering the identity using class resoluton.</p><ul class="structure_fields" id="Std.Identity.mk"></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.Identity" class="instances-list"></ul></details></div></div><div class="decl" id="Std.LawfulIdentity"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L2043-L2043">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.LawfulIdentity"><span class="name">Std</span>.<span class="name">LawfulIdentity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(op : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(o : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href=".././Init/Core.html#Std.Identity"><span class="name">Std</span>.<span class="name">Identity</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.LawfulIdentity">LawfulIdentity</a> op o</code> indicates <code>o</code> is a verified left and right
identity of <code>op</code>.</p><ul class="structure_fields" id="Std.LawfulIdentity.mk"><li id="Std.LawfulIdentity.left_id" class="structure_field"><div class="structure_field_info">left_id : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">o</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></div><div class="structure_field_doc"><p>Left identity <code>o</code> is an identity.</p></div></li><li id="Std.LawfulIdentity.right_id" class="structure_field"><div class="structure_field_info">right_id : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">a</span> <span class="fn">o</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></div><div class="structure_field_doc"><p>Right identity <code>o</code> is an identity.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.LawfulIdentity" class="instances-list"></ul></details></div></div><div class="decl" id="Std.LawfulCommIdentity"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L2054-L2056">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.LawfulCommIdentity"><span class="name">Std</span>.<span class="name">LawfulCommIdentity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(op : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(o : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">α</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[hc : <span class="fn"><a href=".././Init/Core.html#Std.Commutative">Std.Commutative</a> <span class="fn">op</span></span>]</span></span>
</span><span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href=".././Init/Core.html#Std.LawfulIdentity"><span class="name">Std</span>.<span class="name">LawfulIdentity</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Std.LawfulCommIdentity">LawfulCommIdentity</a></code> can simplify defining instances of <code><a href=".././Init/Core.html#Std.LawfulIdentity">LawfulIdentity</a></code>
on commutative functions by requiring only a left or right identity
proof.</p><p>This class is intended for simplifying defining instances of
<code><a href=".././Init/Core.html#Std.LawfulIdentity">LawfulIdentity</a></code> and functions needed commutative operations with
identity should just add a <code><a href=".././Init/Core.html#Std.LawfulIdentity">LawfulIdentity</a></code> constraint.</p><ul class="structure_fields" id="Std.LawfulCommIdentity.mk"></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Std.LawfulCommIdentity" class="instances-list"></ul></details></div></div><div class="decl" id="Std.instCommutativeOr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L2058-L2058">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.instCommutativeOr"><span class="name">Std</span>.<span class="name">instCommutativeOr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Std.Commutative">Std.Commutative</a> <a href=".././Init/Prelude.html#Or">Or</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Std.instCommutativeOr">Std.instCommutativeOr</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Std.instCommutativeAnd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L2059-L2059">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.instCommutativeAnd"><span class="name">Std</span>.<span class="name">instCommutativeAnd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Std.Commutative">Std.Commutative</a> <a href=".././Init/Prelude.html#And">And</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Std.instCommutativeAnd">Std.instCommutativeAnd</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Std.instCommutativeIff"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Core.lean#L2060-L2060">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Std.instCommutativeIff"><span class="name">Std</span>.<span class="name">instCommutativeIff</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Std.Commutative">Std.Commutative</a> <a href=".././Init/Core.html#Iff">Iff</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Std.instCommutativeIff">Std.instCommutativeIff</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div></main>
<nav class="nav"><iframe src=".././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>