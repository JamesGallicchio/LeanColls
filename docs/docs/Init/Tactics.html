<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href=".././style.css"></link><link rel="icon" href=".././favicon.svg"></link><link rel="mask-icon" href=".././favicon.svg" color="#000000"></link><link rel="prefetch" href=".././/declarations/declaration-data.bmp" as="image"></link><title>Init.Tactics</title><script defer="true" src=".././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT=".././";</script><script>const MODULE_NAME="Init.Tactics";</script><script type="module" src=".././jump-src.js"></script><script type="module" src=".././search.js"></script><script type="module" src=".././expand-nav.js"></script><script type="module" src=".././how-about.js"></script><script type="module" src=".././instances.js"></script><script type="module" src=".././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Init</span>.<span class="name">Tactics</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href=".././Init/Notation.html">Init.Notation</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Tactics" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.withAnnotateState"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withAnnotateState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.intro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">intro</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.intros"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">intros</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rename"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rename</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.revert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">revert</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.clear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">clear</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.subst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">subst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.substVars"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">substVars</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.assumption"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">assumption</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.contradiction"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">contradiction</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.falseOrByContra"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">falseOrByContra</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.apply"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">apply</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.exact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">exact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.refine"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">refine</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.refine'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">refine'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticExfalso"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticExfalso</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.constructor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">constructor</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.left"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">left</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.right"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">right</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.case"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">case</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.case'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">case'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«tacticNext_=&gt;_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tacticNext_=&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.allGoals"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">allGoals</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.anyGoals"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">anyGoals</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.focus"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">focus</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.skip"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">skip</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.done"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">done</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.traceState"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">traceState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.traceMessage"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">traceMessage</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.failIfSuccess"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">failIfSuccess</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.paren"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">paren</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.withReducible"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withReducible</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.withReducibleAndInstances"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withReducibleAndInstances</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.withUnfoldingAll"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withUnfoldingAll</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.first"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">first</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rotateLeft"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rotateLeft</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rotateRight"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rotateRight</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticTry_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticTry_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«tactic_&lt;;&gt;_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tactic_&lt;;&gt;_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.fail"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">fail</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.eqRefl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">eqRefl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRfl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRfl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.applyRfl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">applyRfl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRfl'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRfl'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.acRfl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">acRfl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSorry"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSorry</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticAdmit"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticAdmit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticInfer_instance"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticInfer_instance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.config"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">config</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.locationWildcard"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">locationWildcard</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.locationHyp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">locationHyp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.location"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">location</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.change"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">change</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.changeWith"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">changeWith</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rwRule"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rwRule</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rwRuleSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rwRuleSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rewriteSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rewriteSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rwSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rwSeq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRwa__"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRwa__</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.injection"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">injection</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.injections"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">injections</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.discharger"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">discharger</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpPre"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpPre</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpPost"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpPost</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpLemma"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpLemma</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpErase"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpErase</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpStar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpStar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpAll"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpAll</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.dsimp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dsimp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpArgs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpArgs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.dsimpArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dsimpArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.dsimpArgs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dsimpArgs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpTraceArgsRest"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpTraceArgsRest</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSimp?!_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSimp?!_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpAllTraceArgsRest"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpAllTraceArgsRest</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpAllTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpAllTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSimp_all?!_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSimp_all?!_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.dsimpTraceArgsRest"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dsimpTraceArgsRest</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.dsimpTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dsimpTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticDsimp?!_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticDsimp?!_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpaArgsRest"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpaArgsRest</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.simpa"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpa</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSimpa!_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSimpa!_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSimpa?_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSimpa?_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSimpa?!_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSimpa?!_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.delta"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">delta</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.unfold"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">unfold</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRefine_lift_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRefine_lift_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticHave_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticHave_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticSuffices_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSuffices_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticLet_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticLet_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticShow_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticShow_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.letrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">letrec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRefine_lift'_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRefine_lift'_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticHave'_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticHave'_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«tacticHave'_:=_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tacticHave'_:=_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticLet'_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticLet'_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.inductionAltLHS"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">inductionAltLHS</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.inductionAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">inductionAlt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.inductionAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">inductionAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.induction"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">induction</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.generalizeArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">generalizeArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.generalize"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">generalize</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.casesTarget"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">casesTarget</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.cases"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">cases</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.renameI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">renameI</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticRepeat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRepeat_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.repeat'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">repeat'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.repeat1'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">repeat1'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticTrivial"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticTrivial</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.split"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">split</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.dbgTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dbgTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticStop_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticStop_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.specialize"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">specialize</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticUnhygienic_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticUnhygienic_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.checkpoint"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">checkpoint</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.save"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">save</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.sleep"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sleep</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«tacticExists_,,»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tacticExists_,,»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.congr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">congr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacDepIfThenElse"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacDepIfThenElse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacIfThenElse"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacIfThenElse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticNofun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticNofun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«tacticNomatch_,,»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tacticNomatch_,,»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.replace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">replace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticAnd_intros"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticAnd_intros</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.substEqs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">substEqs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.runTac"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">runTac</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticHaveI_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticHaveI_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticLetI_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticLetI_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.omega"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">omega</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticBv_omega"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticBv_omega</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.normCast0"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">normCast0</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticAssumption_mod_cast"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticAssumption_mod_cast</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.tacticNorm_cast_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticNorm_cast_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.pushCast"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">pushCast</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.normCastAddElim"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">normCastAddElim</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.symm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.symmSaturate"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">symmSaturate</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.SolveByElim.erase"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">erase</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.SolveByElim.star"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">star</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.SolveByElim.arg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">arg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.SolveByElim.args"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">args</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.SolveByElim.using_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">using_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.solveByElim"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">solveByElim</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.applyAssumption"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">applyAssumption</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.applyRules"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">applyRules</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.exact?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">exact?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.apply?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">apply?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rewrites_forbidden"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rewrites_forbidden</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.rewrites?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rewrites?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.showTerm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">showTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.showTermElab"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">showTermElab</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.by?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">by?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.simp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">simp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grind_norm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind_norm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.grind_norm_proc"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind_norm_proc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.normCastLabel"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">normCastLabel</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.norm_cast"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">norm_cast</span></a></div><div class="nav_link"><a class="break_within" href="#«term‹_›»"><span class="name">«term‹_›»</span></a></div><div class="nav_link"><a class="break_within" href="#tacticGet_elem_tactic_trivial"><span class="name">tacticGet_elem_tactic_trivial</span></a></div><div class="nav_link"><a class="break_within" href="#tacticGet_elem_tactic"><span class="name">tacticGet_elem_tactic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Syntax.exact?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Syntax</span>.<span class="name">exact?</span></a></div><div class="nav_link"><a class="break_within" href="#autoParam"><span class="name">autoParam</span></a></div></nav><main>
<div class="decl" id="Lean.Parser.Tactic.withAnnotateState"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L11-L16">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withAnnotateState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>with_annotate_state stx t</code> annotates the lexical range of <code>stx : Syntax</code> with
the initial and final state of running tactic <code>t</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.withAnnotateState" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.intro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L18-L39">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.intro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">intro</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal's target type must
be a <code>let</code> or function type.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a></code> by itself introduces one anonymous hypothesis, which can be accessed
by e.g. <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a> x y</code> introduces two hypotheses and names them. Individual hypotheses
can be anonymized via <code>_</code>, or matched against a pattern:<pre><code class="language-lean">-- ... ⊢ α × β → ...
<a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a> (a, b)
-- ..., a : α, b : β ⊢ ...
</code></pre>
</li>
<li>Alternatively, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a></code> can be combined with pattern matching much like <code>fun</code>:<pre><code class="language-lean"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a>
| n + 1, 0 =&gt; tac
| ...
</code></pre>
</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.intro" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.intros"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L41-L112">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.intros"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">intros</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Introduces zero or more hypotheses, optionally naming them.</p><ul>
<li><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intros">intros</a></code> is equivalent to repeatedly applying <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a></code>
until the goal is not an obvious candidate for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a></code>, which is to say
that so long as the goal is a <code>let</code> or a pi type (e.g. an implication, function, or universal quantifier),
the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intros">intros</a></code> tactic will introduce an anonymous hypothesis.
This tactic does not unfold definitions.</p>
</li>
<li><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intros">intros</a> x y ...</code> is equivalent to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a> x y ...</code>,
introducing hypotheses for each supplied argument and unfolding definitions as necessary.
Each argument can be either an identifier or a <code>_</code>.
An identifier indicates a name to use for the corresponding introduced hypothesis,
and a <code>_</code> indicates that the hypotheses should be introduced anonymously.</p>
</li>
</ul><h2 class="markdown-heading" id="Examples">Examples <a class="hover-link" href="#Examples">#</a></h2><p>Basic properties:</p><pre><code class="language-lean">def AllEven (f : <a href=".././Init/Prelude.html#Nat">Nat</a> → Nat) := ∀ n, f n % 2 = 0

-- Introduces the two obvious hypotheses automatically
example : ∀ (f : <a href=".././Init/Prelude.html#Nat">Nat</a> → Nat), AllEven f → AllEven (fun k =&gt; f (k + 1)) := by
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.intros">intros</a>
  /- Tactic state
     f✝ : <a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a>
     a✝ : AllEven f✝
     ⊢ AllEven fun k =&gt; f✝ (k + 1) -/
  sorry

-- Introduces exactly two hypotheses, naming only the <a href=".././Init/Tactics.html#Lean.Parser.Tactic.first">first</a>
example : ∀ (f : <a href=".././Init/Prelude.html#Nat">Nat</a> → Nat), AllEven f → AllEven (fun k =&gt; f (k + 1)) := by
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.intros">intros</a> g _
  /- Tactic state
     g : <a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a>
     a✝ : AllEven g
     ⊢ AllEven fun k =&gt; g (k + 1) -/
  sorry

-- Introduces exactly three hypotheses, which requires unfolding `AllEven`
example : ∀ (f : <a href=".././Init/Prelude.html#Nat">Nat</a> → Nat), AllEven f → AllEven (fun k =&gt; f (k + 1)) := by
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.intros">intros</a> f h n
  /- Tactic state
     f : <a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a>
     h : AllEven f
     n : <a href=".././Init/Prelude.html#Nat">Nat</a>
     ⊢ (fun k =&gt; f (k + 1)) n % 2 = 0 -/
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a> h
</code></pre><p>Implications:</p><pre><code class="language-lean">example (p q : Prop) : p → q → p := by
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.intros">intros</a>
  /- Tactic state
     a✝¹ : p
     a✝ : q
     ⊢ p      -/
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a>
</code></pre><p>Let bindings:</p><pre><code class="language-lean">example : let n := 1; let k := 2; n + k = 3 := by
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.intros">intros</a>
  /- n✝ : <a href=".././Init/Prelude.html#Nat">Nat</a> := 1
     k✝ : <a href=".././Init/Prelude.html#Nat">Nat</a> := 2
     ⊢ n✝ + k✝ = 3 -/
  <a href=".././Init/Prelude.html#rfl">rfl</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.intros" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rename"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L114-L118">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rename"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rename</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.rename">rename</a> t =&gt; x</code> renames the most recent hypothesis whose type matches <code>t</code>
(which may contain placeholders) to <code>x</code>, or fails if no such hypothesis could be found.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rename" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.revert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L120-L124">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.revert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">revert</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.revert">revert</a> x...</code> is the inverse of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a> x...</code>: it moves the given hypotheses
into the main goal's target type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.revert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.clear"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L126-L130">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.clear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">clear</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.clear">clear</a> x...</code> removes the given hypotheses, or fails if there are remaining
references to a hypothesis.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.clear" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.subst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L132-L137">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.subst"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">subst</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.subst">subst</a> x...</code> substitutes each <code>x</code> with <code>e</code> in the goal if there is a hypothesis
of type <code>x = e</code> or <code>e = x</code>.
If <code>x</code> is itself a hypothesis of type <code>y = e</code> or <code>e = y</code>, <code>y</code> is substituted instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.subst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.substVars"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L139-L142">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.substVars"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">substVars</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Applies <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.subst">subst</a></code> to all hypotheses of the form <code>h : x = t</code> or <code>h : t = x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.substVars">Lean.Parser.Tactic.substVars</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.substVars</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;subst_vars&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.substVars" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.assumption"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L144-L148">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">assumption</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code> tries to solve the main goal using a hypothesis of compatible type, or else fails.
Note also the <code>‹t›</code> term notation, which is a shorthand for <code>show t by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">Lean.Parser.Tactic.assumption</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.assumption</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;assumption&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.assumption" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.contradiction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L150-L173">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">contradiction</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a></code> closes the main goal if its hypotheses are &quot;trivially contradictory&quot;.</p><ul>
<li>Inductive type/family with no applicable constructors</li>
</ul><pre><code class="language-lean">example (h : False) : p := by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a>
</code></pre><ul>
<li>Injectivity of constructors</li>
</ul><pre><code class="language-lean">example (h : none = some true) : p := by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a>  --
</code></pre><ul>
<li>Decidable false proposition</li>
</ul><pre><code class="language-lean">example (h : 2 + 2 = 3) : p := by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a>
</code></pre><ul>
<li>Contradictory hypotheses</li>
</ul><pre><code class="language-lean">example (h : p) (h' : ¬ p) : q := by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a>
</code></pre><ul>
<li>Other simple contradictions such as</li>
</ul><pre><code class="language-lean">example (x : Nat) (h : x ≠ x) : p := by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">Lean.Parser.Tactic.contradiction</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.contradiction</span> <span class="fn">1024</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;contradiction&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.contradiction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.falseOrByContra"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L175-L186">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.falseOrByContra"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">falseOrByContra</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Changes the goal to <code><a href=".././Init/Prelude.html#False">False</a></code>, retaining as much information as possible:</p><ul>
<li>If the goal is <code><a href=".././Init/Prelude.html#False">False</a></code>, do nothing.</li>
<li>If the goal is an implication or a function type, introduce the argument and restart.
(In particular, if the goal is <code>x ≠ y</code>, introduce <code>x = y</code>.)</li>
<li>Otherwise, for a propositional goal <code>P</code>, replace it with <code>¬ ¬ P</code>
(attempting to find a <code><a href=".././Init/Prelude.html#Decidable">Decidable</a></code> instance, but otherwise falling back to working classically)
and introduce <code>¬ P</code>.</li>
<li>For a non-propositional goal use <code><a href=".././Init/Prelude.html#False.elim">False.elim</a></code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.falseOrByContra">Lean.Parser.Tactic.falseOrByContra</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.falseOrByContra</span> <span class="fn">1024</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;false_or_by_contra&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.falseOrByContra" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.apply"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L188-L197">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.apply"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">apply</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a> e</code> tries to match the current goal against the conclusion of <code>e</code>'s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.</p><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a></code> tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.apply" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.exact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L199-L202">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.exact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">exact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> e</code> closes the main goal if its target type matches that of <code>e</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.exact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.refine"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L204-L209">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.refine"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">refine</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine">refine</a> e</code> behaves like <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> e</code>, except that named (<code>?x</code>) or unnamed (<code>?_</code>)
holes in <code>e</code> that are not solved by unification with the main goal's target type
are converted into new goals, using the hole's name, if any, as the goal case name.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.refine" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.refine'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L211-L215">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">refine'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a> e</code> behaves like <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine">refine</a> e</code>, except that unsolved placeholders (<code>_</code>)
and implicit parameters are also converted into new goals.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.refine'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticExfalso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L218-L218">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticExfalso"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticExfalso</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>exfalso</code> converts a goal <code>⊢ tgt</code> into <code>⊢ <a href=".././Init/Prelude.html#False">False</a></code> by applying <code><a href=".././Init/Prelude.html#False.elim">False.elim</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticExfalso">Lean.Parser.Tactic.tacticExfalso</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticExfalso</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;exfalso&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticExfalso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.constructor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L220-L224">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.constructor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">constructor</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>If the main goal's target type is an inductive type, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.constructor">constructor</a></code> solves it with
the first matching constructor, or else fails.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.constructor">Lean.Parser.Tactic.constructor</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.constructor</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;constructor&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.constructor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.left"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L226-L235">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.left"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">left</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Applies the first constructor when
the goal is an inductive type with exactly two constructors, or fails otherwise.</p><pre><code>example : <a href=".././Init/Prelude.html#True">True</a> ∨ <a href=".././Init/Prelude.html#False">False</a> := by
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.left">left</a>
  <a href=".././Init/Core.html#trivial">trivial</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.left">Lean.Parser.Tactic.left</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.left</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;left&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.left" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.right"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L237-L246">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.right"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">right</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Applies the second constructor when
the goal is an inductive type with exactly two constructors, or fails otherwise.</p><pre><code>example {p q : Prop} (h : q) : p ∨ q := by
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.right">right</a>
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> h
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.right">Lean.Parser.Tactic.right</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.right</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;right&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.right" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.case"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L248-L255">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.case"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">case</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a> tag =&gt; tac</code> focuses on the goal with case name <code>tag</code> and solves it using <code>tac</code>,
or else fails.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a> tag x₁ ... xₙ =&gt; tac</code> additionally renames the <code>n</code> most recent hypotheses
with inaccessible names to the given names.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a> tag₁ | tag₂ =&gt; tac</code> is equivalent to <code>(case tag₁ =&gt; tac); (case tag₂ =&gt; tac)</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.case" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.case'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L257-L263">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.case'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">case'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case'">case'</a></code> is similar to the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a> tag =&gt; tac</code> tactic, but does not ensure the goal
has been solved after applying <code>tac</code>, nor admits the goal if <code>tac</code> failed.
Recall that <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a></code> closes the goal using <code>sorry</code> when <code>tac</code> fails, and
the tactic execution is not interrupted.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.case'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«tacticNext_=&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L270-L272">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.«tacticNext_=&gt;_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tacticNext_=&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>next =&gt; tac</code> focuses on the next goal and solves it using <code>tac</code>, or else fails.
<code>next x₁ ... xₙ =&gt; tac</code> additionally renames the <code>n</code> most recent hypotheses with
inaccessible names to the given names.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«tacticNext_=&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.allGoals"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L274-L275">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.allGoals"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">allGoals</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>all_goals tac</code> runs <code>tac</code> on each goal, concatenating the resulting goals, if any.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.allGoals" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.anyGoals"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L277-L281">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.anyGoals"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">anyGoals</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>any_goals tac</code> applies the tactic <code>tac</code> to every goal, and succeeds if at
least one application succeeds.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.anyGoals" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.focus"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L283-L287">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.focus"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">focus</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.focus">focus</a> tac</code> focuses on the main goal, suppressing all other goals, and runs <code>tac</code> on it.
Usually <code>· tac</code>, which enforces that the goal is closed by <code>tac</code>, should be preferred.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.focus" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.skip"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L289-L290">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.skip"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">skip</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.skip">skip</a></code> does nothing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.skip">Lean.Parser.Tactic.skip</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.skip</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;skip&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.skip" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.done"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L292-L293">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.done"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">done</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.done">done</a></code> succeeds iff there are no remaining goals.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.done">Lean.Parser.Tactic.done</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.done</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;done&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.done" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.traceState"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L295-L296">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.traceState"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">traceState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>trace_state</code> displays the current state in the info view.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.traceState">Lean.Parser.Tactic.traceState</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.traceState</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;trace_state&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.traceState" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.traceMessage"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L298-L299">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.traceMessage"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">traceMessage</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>trace msg</code> displays <code>msg</code> in the info view.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.traceMessage" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.failIfSuccess"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L301-L302">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.failIfSuccess"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">failIfSuccess</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>fail_if_success t</code> fails if the tactic <code>t</code> succeeds.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.failIfSuccess" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.paren"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L304-L309">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.paren"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">paren</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>(tacs)</code> executes a list of tactics in sequence, without requiring that
the goal be closed at the end like <code>· tacs</code>. Like <code>by</code> itself, the tactics
can be either separated by newlines or <code>;</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.paren" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.withReducible"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L311-L315">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.withReducible"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withReducible</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>with_reducible tacs</code> executes <code>tacs</code> using the reducible transparency setting.
In this setting only definitions tagged as <code>[reducible]</code> are unfolded.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.withReducible" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.withReducibleAndInstances"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L317-L321">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.withReducibleAndInstances"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withReducibleAndInstances</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>with_reducible_and_instances tacs</code> executes <code>tacs</code> using the <code>.instances</code> transparency setting.
In this setting only definitions tagged as <code>[reducible]</code> or type class instances are unfolded.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.withReducibleAndInstances" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.withUnfoldingAll"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L323-L327">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingAll"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">withUnfoldingAll</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>with_unfolding_all tacs</code> executes <code>tacs</code> using the <code>.all</code> transparency setting.
In this setting all definitions that are not opaque are unfolded.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.withUnfoldingAll" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.first"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L329-L330">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.first"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">first</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.first">first</a> | tac | ...</code> runs each <code>tac</code> until one succeeds, or else fails.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.first" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rotateLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L332-L337">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rotateLeft"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rotateLeft</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rotate_left n</code> rotates goals to the left by <code>n</code>. That is, <code>rotate_left 1</code>
takes the main goal and puts it to the back of the subgoal list.
If <code>n</code> is omitted, it defaults to <code>1</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rotateLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rotateRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L339-L343">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rotateRight"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rotateRight</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Rotate the goals to the right by <code>n</code>. That is, take the goal at the back
and push it to the front <code>n</code> times. If <code>n</code> is omitted, it defaults to <code>1</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rotateRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticTry_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L346-L346">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticTry_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticTry_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>try tac</code> runs <code>tac</code> and succeeds even if <code>tac</code> failed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticTry_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«tactic_&lt;;&gt;_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L352-L357">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.«tactic_&lt;;&gt;_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tactic_&lt;;&gt;_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>tac &lt;;&gt; tac'</code> runs <code>tac</code> on the main goal and <code>tac'</code> on each produced goal,
concatenating all goals produced by <code>tac'</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«tactic_&lt;;&gt;_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.fail"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L359-L360">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.fail"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">fail</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.fail">fail</a> msg</code> is a tactic that always fails, and produces an error using the given message.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.fail" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.eqRefl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L362-L363">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.eqRefl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">eqRefl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>eq_refl</code> is equivalent to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> <a href=".././Init/Prelude.html#rfl">rfl</a></code>, but has a few optimizations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.eqRefl">Lean.Parser.Tactic.eqRefl</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.eqRefl</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;eq_refl&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.eqRefl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRfl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L373-L377">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRfl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRfl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Prelude.html#rfl">rfl</a></code> tries to close the current goal using reflexivity.
This is supposed to be an extensible tactic and users can add their own support
for new reflexive relations.</p><p>Remark: <code><a href=".././Init/Prelude.html#rfl">rfl</a></code> is an extensible tactic. We later add <code>macro_rules</code> to try different
reflexivity theorems (e.g., <code><a href=".././Init/Core.html#Iff.rfl">Iff.rfl</a></code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRfl">Lean.Parser.Tactic.tacticRfl</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticRfl</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;rfl&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticRfl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.applyRfl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L382-L387">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.applyRfl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">applyRfl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>This tactic applies to a goal whose target has the form <code>x ~ x</code>,
where <code>~</code> is a reflexive relation other than <code>=</code>,
that is, a relation which has a reflexive lemma tagged with the attribute @[refl].</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.applyRfl">Lean.Parser.Tactic.applyRfl</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.applyRfl</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;apply_rfl&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.applyRfl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRfl'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L395-L395">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRfl'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRfl'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rfl'</code> is similar to <code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, but disables smart unfolding and unfolds all kinds of definitions,
theorems included (relevant for declarations defined by well-founded recursion).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRfl'">Lean.Parser.Tactic.tacticRfl'</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticRfl'</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;rfl'&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticRfl'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.acRfl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L397-L406">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.acRfl"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">acRfl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>ac_rfl</code> proves equalities up to application of an associative and commutative operator.</p><pre><code>instance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩
instance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩

example (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.acRfl">Lean.Parser.Tactic.acRfl</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.acRfl</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;ac_rfl&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.acRfl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSorry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L415-L415">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticSorry"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSorry</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code>sorry</code> tactic closes the goal using <code><a href=".././Init/Prelude.html#sorryAx">sorryAx</a></code>. This is intended for stubbing out incomplete
parts of a proof while still having a syntactically correct proof skeleton. Lean will give
a warning whenever a proof uses <code>sorry</code>, so you aren't likely to miss it, but
you can double check if a theorem depends on <code>sorry</code> by using
<code>#print axioms my_thm</code> and looking for <code><a href=".././Init/Prelude.html#sorryAx">sorryAx</a></code> in the axiom list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticSorry">Lean.Parser.Tactic.tacticSorry</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticSorry</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;sorry&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSorry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticAdmit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L418-L418">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticAdmit"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticAdmit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>admit</code> is a shorthand for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> sorry</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticAdmit">Lean.Parser.Tactic.tacticAdmit</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticAdmit</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;admit&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticAdmit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticInfer_instance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L424-L424">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticInfer_instance"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticInfer_instance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>infer_instance</code> is an abbreviation for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> <a href=".././Init/Prelude.html#inferInstance">inferInstance</a></code>.
It synthesizes a value of any target type by typeclass inference.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticInfer_instance">Lean.Parser.Tactic.tacticInfer_instance</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticInfer_instance</span> <span class="fn">1024</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;infer_instance&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticInfer_instance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.config"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L426-L427">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.config"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">config</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Optional configuration option for tactics</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.config" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.locationWildcard"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L429-L430">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.locationWildcard"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">locationWildcard</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code>*</code> location refers to all hypotheses and the goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.locationWildcard">Lean.Parser.Tactic.locationWildcard</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;locationWildcard&quot;</span> <span class="fn">`Lean.Parser.Tactic.locationWildcard</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; *&quot;</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.locationWildcard" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.locationHyp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L432-L436">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.locationHyp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">locationHyp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A hypothesis location specification consists of 1 or more hypothesis references
and optionally <code>⊢</code> denoting the goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.locationHyp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.location"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L438-L447">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.location"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">location</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:</p><ul>
<li>'empty' is not actually present in this syntax, but most tactics use
<code>(location)?</code> matchers. It means to target the goal only.</li>
<li><code>at h₁ ... hₙ</code>: target the hypotheses <code>h₁</code>, ..., <code>hₙ</code></li>
<li><code>at h₁ h₂ ⊢</code>: target the hypotheses <code>h₁</code> and <code>h₂</code>, and the goal</li>
<li><code>at *</code>: target all hypotheses and the goal</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.location" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.change"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L449-L455">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.change"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">change</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.change">change</a> tgt'</code> will change the goal from <code>tgt</code> to <code>tgt'</code>,
assuming these are definitionally equal.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.change">change</a> t' at h</code> will change hypothesis <code>h : t</code> to have type <code>t'</code>, assuming
assuming <code>t</code> and <code>t'</code> are definitionally equal.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.change" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.changeWith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L457-L462">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.changeWith"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">changeWith</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.change">change</a> a with b</code> will change occurrences of <code>a</code> to <code>b</code> in the goal,
assuming <code>a</code> and <code>b</code> are are definitionally equal.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.change">change</a> a with b at h</code> similarly changes <code>a</code> to <code>b</code> in the type of hypothesis <code>h</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.changeWith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rwRule"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L464-L469">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rwRule"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rwRule</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>If <code>thm</code> is a theorem <code>a = b</code>, then as a rewrite rule,</p><ul>
<li><code>thm</code> means to replace <code>a</code> with <code>b</code>, and</li>
<li><code>← thm</code> means to replace <code>b</code> with <code>a</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rwRule" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rwRuleSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L470-L471">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rwRuleSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq">rwRuleSeq</a></code> is a list of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.rwRule">rwRule</a></code> in brackets.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rwRuleSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rewriteSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L473-L492">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rewriteSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rewriteSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rewrite [e]</code> applies identity <code>e</code> as a rewrite rule to the target of the main goal.
If <code>e</code> is preceded by left arrow (<code>←</code> or <code>&lt;-</code>), the rewrite is applied in the reverse direction.
If <code>e</code> is a defined constant, then the equational theorems associated with <code>e</code> are used.
This provides a convenient way to unfold <code>e</code>.</p><ul>
<li><code>rewrite [e₁, ..., eₙ]</code> applies the given rules sequentially.</li>
<li><code>rewrite [e] at l</code> rewrites <code>e</code> at location(s) <code>l</code>, where <code>l</code> is either <code>*</code> or a
list of hypotheses in the local context. In the latter case, a turnstile <code>⊢</code> or <code>|-</code>
can also be used, to signify the target of the goal.</li>
</ul><p>Using <code>rw (config := {occs := .pos L}) [e]</code>,
where <code>L : <a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Nat">Nat</a></code>, you can control which &quot;occurrences&quot; are rewritten.
(This option applies to each rule, so usually this will only be used with a single rule.)
Occurrences count from <code>1</code>.
At each allowed occurrence, arguments of the rewrite rule <code>e</code> may be instantiated,
restricting which later rewrites can be found.
(Disallowed occurrences do not result in instantiation.)
<code>{occs := .neg L}</code> allows skipping specified occurrences.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rewriteSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rwSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L497-L502">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rwSeq"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rwSeq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rw</code> is like <code>rewrite</code>, but also tries to close the goal by &quot;cheap&quot; (reducible) <code><a href=".././Init/Prelude.html#rfl">rfl</a></code> afterwards.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rwSeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRwa__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L505-L506">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRwa__"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRwa__</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rwa</code> calls <code>rw</code>, then closes any remaining goals using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticRwa__" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.injection"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L508-L521">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.injection"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">injection</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a></code> tactic is based on the fact that constructors of inductive data
types are injections.
That means that if <code>c</code> is a constructor of an inductive datatype, and if <code>(c t₁)</code>
and <code>(c t₂)</code> are two terms that are equal then  <code>t₁</code> and <code>t₂</code> are equal too.
If <code>q</code> is a proof of a statement of conclusion <code>t₁ = t₂</code>, then injection applies
injectivity to derive the equality of all arguments of <code>t₁</code> and <code>t₂</code> placed in
the same positions. For example, from <code>(a::b) = (c::d)</code> we derive <code>a=c</code> and <code>b=d</code>.
To use this tactic <code>t₁</code> and <code>t₂</code> should be constructor applications of the same constructor.
Given <code>h : a::b = c::d</code>, the tactic <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a> h</code> adds two new hypothesis with types
<code>a = c</code> and <code>b = d</code> to the main goal.
The tactic <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a> h with h₁ h₂</code> uses the names <code>h₁</code> and <code>h₂</code> to name the new hypotheses.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.injection" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.injections"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L523-L527">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.injections"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">injections</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injections">injections</a></code> applies <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a></code> to all hypotheses recursively
(since <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a></code> can produce new hypotheses). Useful for destructing nested
constructor equalities like <code>(a::b::c) = (d::e::f)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.injections" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.discharger"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L529-L533">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.discharger"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">discharger</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The discharger clause of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> and related tactics.
This is a tactic used to discharge the side conditions on conditional rewrite rules.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.discharger" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpPre"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L535-L536">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpPre"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpPre</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Use this rewrite rule before entering the subterms</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpPre">Lean.Parser.Tactic.simpPre</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;simpPre&quot;</span> <span class="fn">`Lean.Parser.Tactic.simpPre</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;↓&quot;</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.simpPre" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpPost"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L537-L538">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpPost"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpPost</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Use this rewrite rule after entering the subterms</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpPost">Lean.Parser.Tactic.simpPost</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;simpPost&quot;</span> <span class="fn">`Lean.Parser.Tactic.simpPost</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;↑&quot;</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.simpPost" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpLemma"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L539-L545">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpLemma"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpLemma</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A simp lemma specification is:</p><ul>
<li>optional <code>↑</code> or <code>↓</code> to specify use before or after entering the subterm</li>
<li>optional <code>←</code> to use the lemma backward</li>
<li><code>thm</code> for the theorem to rewrite with</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.simpLemma" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpErase"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L546-L547">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpErase"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpErase</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>An erasure specification <code>-thm</code> says to remove <code>thm</code> from the simp set</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.simpErase" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpStar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L548-L549">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpStar"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpStar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The simp lemma specification <code>*</code> means to rewrite with all hypotheses</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpStar">Lean.Parser.Tactic.simpStar</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;simpStar&quot;</span> <span class="fn">`Lean.Parser.Tactic.simpStar</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;*&quot;</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.simpStar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L550-L571">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> simplifies the main goal target using lemmas tagged with the attribute <code>[simp]</code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [h₁, h₂, ..., hₙ]</code> simplifies the main goal target using the lemmas tagged
with the attribute <code>[simp]</code> and the given <code>hᵢ</code>'s, where the <code>hᵢ</code>'s are expressions.
If an <code>hᵢ</code> is a defined constant <code>f</code>, then the equational lemmas associated with
<code>f</code> are used. This provides a convenient way to unfold <code>f</code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [*]</code> simplifies the main goal target using the lemmas tagged with the
attribute <code>[simp]</code> and all hypotheses.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only [h₁, h₂, ..., hₙ]</code> is like <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [h₁, h₂, ..., hₙ]</code> but does not use <code>[simp]</code> lemmas.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [-id₁, ..., -idₙ]</code> simplifies the main goal target using the lemmas tagged
with the attribute <code>[simp]</code>, but removes the ones named <code>idᵢ</code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> at h₁ h₂ ... hₙ</code> simplifies the hypotheses <code>h₁ : T₁</code> ... <code>hₙ : Tₙ</code>. If
the target or another hypothesis depends on <code>hᵢ</code>, a new simplified hypothesis
<code>hᵢ</code> is introduced, but the old one remains in the local context.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> at *</code> simplifies all the hypotheses and the target.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [*] at *</code> simplifies target and all (propositional) hypotheses using the
other hypotheses.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.simp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpAll"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L572-L578">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpAll"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpAll</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>simp_all</code> is a stronger version of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> [*] at *</code> where the hypotheses and target
are simplified multiple times until no simplification is applicable.
Only non-dependent propositional hypotheses are considered.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.simpAll" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.dsimp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L580-L586">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dsimp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimp">dsimp</a></code> tactic is the definitional simplifier. It is similar to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> but only
applies theorems that hold by reflexivity. Thus, the result is guaranteed to be
definitionally equal to the input.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.dsimp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L592-L592">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpArg">simpArg</a></code> is either a <code>*</code>, <code>-lemma</code> or a simp lemma specification
(which includes the <code>↑</code> <code>↓</code> <code>←</code> specifications for pre, post, reverse rewriting).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpArg">Lean.Parser.Tactic.simpArg</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> <a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpStar">Lean.Parser.Tactic.simpStar</a>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> <a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpErase">Lean.Parser.Tactic.simpErase</a> <a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpLemma">Lean.Parser.Tactic.simpLemma</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.simpArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpArgs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L594-L595">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpArgs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpArgs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A simp args list is a list of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpArg">simpArg</a></code>. This is the main argument to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.simpArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.dsimpArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L601-L601">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimpArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dsimpArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimpArg">dsimpArg</a></code> is similar to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpArg">simpArg</a></code>, but it does not have the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpStar">simpStar</a></code> form
because it does not make sense to use hypotheses in <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimp">dsimp</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimpArg">Lean.Parser.Tactic.dsimpArg</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> <a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpErase">Lean.Parser.Tactic.simpErase</a> <a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpLemma">Lean.Parser.Tactic.simpLemma</a></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.dsimpArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.dsimpArgs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L603-L604">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimpArgs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dsimpArgs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A dsimp args list is a list of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimpArg">dsimpArg</a></code>. This is the main argument to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimp">dsimp</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.dsimpArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpTraceArgsRest"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L606-L607">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpTraceArgsRest"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpTraceArgsRest</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The common arguments of <code>simp?</code> and <code>simp?!</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.simpTraceArgsRest" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpTrace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L609-L620">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>simp?</code> takes the same arguments as <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code>, but reports an equivalent call to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href=".././Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: <a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimp">dsimp</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.simpTrace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSimp?!_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L623-L623">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticSimp?!_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSimp?!_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>simp?</code> takes the same arguments as <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code>, but reports an equivalent call to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href=".././Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: <a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimp">dsimp</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSimp?!_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpAllTraceArgsRest"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L625-L626">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpAllTraceArgsRest"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpAllTraceArgsRest</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The common arguments of <code>simp_all?</code> and <code>simp_all?!</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.simpAllTraceArgsRest" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpAllTrace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L628-L629">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpAllTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpAllTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>simp?</code> takes the same arguments as <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code>, but reports an equivalent call to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href=".././Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: <a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimp">dsimp</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.simpAllTrace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSimp_all?!_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L632-L632">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticSimp_all?!_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSimp_all?!_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>simp?</code> takes the same arguments as <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code>, but reports an equivalent call to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href=".././Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: <a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimp">dsimp</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSimp_all?!_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.dsimpTraceArgsRest"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L634-L635">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimpTraceArgsRest"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dsimpTraceArgsRest</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The common arguments of <code>dsimp?</code> and <code>dsimp?!</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.dsimpTraceArgsRest" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.dsimpTrace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L637-L638">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimpTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dsimpTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>simp?</code> takes the same arguments as <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code>, but reports an equivalent call to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href=".././Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: <a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimp">dsimp</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.dsimpTrace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticDsimp?!_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L641-L641">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticDsimp?!_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticDsimp?!_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>simp?</code> takes the same arguments as <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code>, but reports an equivalent call to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href=".././Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: <a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.dsimp">dsimp</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticDsimp?!_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpaArgsRest"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L643-L644">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpaArgsRest"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpaArgsRest</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The arguments to the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpa">simpa</a></code> family tactics.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.simpaArgsRest" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.simpa"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L646-L660">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.simpa"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">simpa</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>This is a &quot;finishing&quot; tactic modification of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code>. It has two forms.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpa">simpa</a> [rules, ⋯] using e</code> will simplify the goal and the type of
<code>e</code> using <code>rules</code>, then try to close the goal using <code>e</code>.</li>
</ul><p>Simplifying the type of <code>e</code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpa">simpa</a> [rules, ⋯]</code> will simplify the goal and the type of a
hypothesis <code>this</code> if present in the context, then try to close the goal using
the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code> tactic.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.simpa" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSimpa!_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L662-L663">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticSimpa!_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSimpa!_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>This is a &quot;finishing&quot; tactic modification of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code>. It has two forms.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpa">simpa</a> [rules, ⋯] using e</code> will simplify the goal and the type of
<code>e</code> using <code>rules</code>, then try to close the goal using <code>e</code>.</li>
</ul><p>Simplifying the type of <code>e</code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpa">simpa</a> [rules, ⋯]</code> will simplify the goal and the type of a
hypothesis <code>this</code> if present in the context, then try to close the goal using
the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code> tactic.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSimpa!_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSimpa?_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L665-L666">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticSimpa?_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSimpa?_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>This is a &quot;finishing&quot; tactic modification of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code>. It has two forms.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpa">simpa</a> [rules, ⋯] using e</code> will simplify the goal and the type of
<code>e</code> using <code>rules</code>, then try to close the goal using <code>e</code>.</li>
</ul><p>Simplifying the type of <code>e</code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpa">simpa</a> [rules, ⋯]</code> will simplify the goal and the type of a
hypothesis <code>this</code> if present in the context, then try to close the goal using
the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code> tactic.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSimpa?_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSimpa?!_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L668-L669">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticSimpa?!_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSimpa?!_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>This is a &quot;finishing&quot; tactic modification of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code>. It has two forms.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpa">simpa</a> [rules, ⋯] using e</code> will simplify the goal and the type of
<code>e</code> using <code>rules</code>, then try to close the goal using <code>e</code>.</li>
</ul><p>Simplifying the type of <code>e</code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simpa">simpa</a> [rules, ⋯]</code> will simplify the goal and the type of a
hypothesis <code>this</code> if present in the context, then try to close the goal using
the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code> tactic.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSimpa?!_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.delta"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L671-L676">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.delta"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">delta</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.delta">delta</a> id1 id2 ...</code> delta-expands the definitions <code>id1</code>, <code>id2</code>, ....
This is a low-level tactic, it will expose how recursive definitions have been
compiled by Lean.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.delta" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.unfold"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L678-L686">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.unfold"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">unfold</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.unfold">unfold</a> <a href=".././Init/Prelude.html#id">id</a></code> unfolds definition <code><a href=".././Init/Prelude.html#id">id</a></code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.unfold">unfold</a> id1 id2 ...</code> is equivalent to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.unfold">unfold</a> id1; <a href=".././Init/Tactics.html#Lean.Parser.Tactic.unfold">unfold</a> id2; ...</code>.</li>
</ul><p>For non-recursive definitions, this tactic is identical to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.delta">delta</a></code>.
For definitions by pattern matching, it uses &quot;equation lemmas&quot; which are
autogenerated for each match arm.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.unfold" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRefine_lift_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L692-L692">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRefine_lift_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Auxiliary macro for lifting have/suffices/let/...
It makes sure the &quot;continuation&quot; <code>?_</code> is the main goal after refining.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticRefine_lift_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticHave_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L694-L705">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticHave_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticHave_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code>have</code> tactic is for adding hypotheses to the local context of the main goal.</p><ul>
<li><code>have h : t := e</code> adds the hypothesis <code>h : t</code> if <code>e</code> is a term of type <code>t</code>.</li>
<li><code>have h := e</code> uses the type of <code>e</code> for <code>t</code>.</li>
<li><code>have : t := e</code> and <code>have := e</code> use <code>this</code> for the name of the hypothesis.</li>
<li><code>have pat := e</code> for a pattern <code>pat</code> is equivalent to <code>match e with | pat =&gt; _</code>,
where <code>_</code> stands for the tactics that follow this one.
It is convenient for types that have only one applicable constructor.
For example, given <code>h : p ∧ q ∧ r</code>, <code>have ⟨h₁, h₂, h₃⟩ := h</code> produces the
hypotheses <code>h₁ : p</code>, <code>h₂ : q</code>, and <code>h₃ : r</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticHave_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticSuffices_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L744-L744">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticSuffices_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticSuffices_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Given a main goal <code>ctx ⊢ t</code>, <code>suffices h : t' from e</code> replaces the main goal with <code>ctx ⊢ t'</code>,
<code>e</code> must have type <code>t</code> in the context <code>ctx, h : t'</code>.</p><p>The variant <code>suffices h : t' by tac</code> is a shorthand for <code>suffices h : t' from by tac</code>.
If <code>h :</code> is omitted, the name <code>this</code> is used.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticSuffices_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticLet_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L756-L756">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticLet_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticLet_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code>let</code> tactic is for adding definitions to the local context of the main goal.</p><ul>
<li><code>let x : t := e</code> adds the definition <code>x : t := e</code> if <code>e</code> is a term of type <code>t</code>.</li>
<li><code>let x := e</code> uses the type of <code>e</code> for <code>t</code>.</li>
<li><code>let : t := e</code> and <code>let := e</code> use <code>this</code> for the name of the hypothesis.</li>
<li><code>let pat := e</code> for a pattern <code>pat</code> is equivalent to <code>match e with | pat =&gt; _</code>,
where <code>_</code> stands for the tactics that follow this one.
It is convenient for types that let only one applicable constructor.
For example, given <code>p : α × β × γ</code>, <code>let ⟨x, y, z⟩ := p</code> produces the
local variables <code>x : α</code>, <code>y : β</code>, and <code>z : γ</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticLet_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticShow_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L761-L761">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticShow_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticShow_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>show t</code> finds the first goal whose target unifies with <code>t</code>. It makes that the main goal,
performs the unification, and replaces the target with the unified version of <code>t</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticShow_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.letrec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L762-L764">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.letrec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">letrec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>let rec f : t := e</code> adds a recursive definition <code>f</code> to the current goal.
The syntax is the same as term-mode <code>let rec</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.letrec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRefine_lift'_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L769-L769">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift'_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRefine_lift'_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Similar to <code>refine_lift</code>, but using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticRefine_lift'_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticHave'_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L771-L771">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticHave'_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticHave'_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Similar to <code>have</code>, but using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticHave'_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«tacticHave'_:=_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L773-L773">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.«tacticHave'_:=_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tacticHave'_:=_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Similar to <code>have</code>, but using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«tacticHave'_:=_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticLet'_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L775-L775">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticLet'_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticLet'_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Similar to <code>let</code>, but using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticLet'_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.inductionAltLHS"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L777-L782">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.inductionAltLHS"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">inductionAltLHS</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The left hand side of an induction arm, <code>| foo a b c</code> or <code>| @foo a b c</code>
where <code>foo</code> is a constructor of the inductive type and <code>a b c</code> are the arguments
to the constructor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.inductionAltLHS" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.inductionAlt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L783-L787">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.inductionAlt"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">inductionAlt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>In induction alternative, which can have 1 or more cases on the left
and <code>_</code>, <code>?_</code>, or a tactic sequence after the <code>=&gt;</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.inductionAlt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.inductionAlts"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L788-L792">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.inductionAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">inductionAlts</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>After <code>with</code>, there is an optional tactic that runs on all branches, and
then a list of alternatives.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.inductionAlts" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.induction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L794-L821">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.induction"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">induction</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Assuming <code>x</code> is a variable in the local context with an inductive type,
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> x</code> applies induction on <code>x</code> to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on <code>x</code>,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.</p><p>For example, given <code>n : <a href=".././Init/Prelude.html#Nat">Nat</a></code> and a goal with a hypothesis <code>h : P n</code> and target <code>Q n</code>,
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> n</code> produces one goal with hypothesis <code>h : P 0</code> and target <code>Q 0</code>,
and one goal with hypotheses <code>h : P (Nat.succ a)</code> and <code>ih₁ : P a → Q a</code> and target <code>Q (Nat.succ a)</code>.
Here the names <code>a</code> and <code>ih₁</code> are chosen automatically and are not accessible.
You can use <code>with</code> to provide the variables names for each constructor.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> e</code>, where <code>e</code> is an expression instead of a variable,
generalizes <code>e</code> in the goal, and then performs induction on the resulting variable.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> e using r</code> allows the user to specify the principle of induction that should be used.
Here <code>r</code> should be a term whose result type must be of the form <code>C t</code>,
where <code>C</code> is a bound variable and <code>t</code> is a (possibly empty) sequence of bound variables</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> e generalizing z₁ ... zₙ</code>, where <code>z₁ ... zₙ</code> are variables in the local context,
generalizes over <code>z₁ ... zₙ</code> before applying the induction but then introduces them in each goal.
In other words, the net effect is that each inductive hypothesis is generalized.</li>
<li>Given <code>x : <a href=".././Init/Prelude.html#Nat">Nat</a></code>, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a> x with | zero =&gt; tac₁ | succ x' ih =&gt; tac₂</code>
uses tactic <code>tac₁</code> for the <code>zero</code> case, and <code>tac₂</code> for the <code>succ</code> case.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.induction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.generalizeArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L823-L824">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.generalizeArg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">generalizeArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.generalize">generalize</a></code> argument, of the form <code>term = x</code> or <code>h : term = x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.generalizeArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.generalize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L826-L833">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.generalize"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">generalize</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.generalize">generalize</a> ([h :] e = x),+</code> replaces all occurrences <code>e</code>s in the main goal
with a fresh hypothesis <code>x</code>s. If <code>h</code> is given, <code>h : e = x</code> is introduced as well.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.generalize">generalize</a> e = x at h₁ ... hₙ</code> also generalizes occurrences of <code>e</code>
inside <code>h₁</code>, ..., <code>hₙ</code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.generalize">generalize</a> e = x at *</code> will generalize occurrences of <code>e</code> everywhere.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.generalize" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.casesTarget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L835-L839">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.casesTarget"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">casesTarget</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a></code> argument, of the form <code>e</code> or <code>h : e</code> (where <code>h</code> asserts that
<code>e = cᵢ a b</code> for each constructor <code>cᵢ</code> of the inductive).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.casesTarget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.cases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L840-L863">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.cases"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">cases</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Assuming <code>x</code> is a variable in the local context with an inductive type,
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> x</code> splits the main goal, producing one goal for each constructor of the
inductive type, in which the target is replaced by a general instance of that constructor.
If the type of an element in the local context depends on <code>x</code>,
that element is reverted and reintroduced afterward,
so that the case split affects that hypothesis as well.
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a></code> detects unreachable cases and closes them automatically.</p><p>For example, given <code>n : <a href=".././Init/Prelude.html#Nat">Nat</a></code> and a goal with a hypothesis <code>h : P n</code> and target <code>Q n</code>,
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> n</code> produces one goal with hypothesis <code>h : P 0</code> and target <code>Q 0</code>,
and one goal with hypothesis <code>h : P (Nat.succ a)</code> and target <code>Q (Nat.succ a)</code>.
Here the name <code>a</code> is chosen automatically and is not accessible.
You can use <code>with</code> to provide the variables names for each constructor.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> e</code>, where <code>e</code> is an expression instead of a variable, generalizes <code>e</code> in the goal,
and then cases on the resulting variable.</li>
<li>Given <code>as : <a href=".././Init/Prelude.html#List">List</a> α</code>, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> as with | nil =&gt; tac₁ | cons a as' =&gt; tac₂</code>,
uses tactic <code>tac₁</code> for the <code>nil</code> case, and <code>tac₂</code> for the <code>cons</code> case,
and <code>a</code> and <code>as'</code> are used as names for the new variables introduced.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> h : e</code>, where <code>e</code> is a variable or an expression,
performs cases on <code>e</code> as above, but also adds a hypothesis <code>h : e = ...</code> to each hypothesis,
where <code>...</code> is the constructor instance for that particular case.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.cases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.renameI"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L865-L866">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.renameI"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">renameI</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rename_i x_1 ... x_n</code> renames the last <code>n</code> inaccessible names using the given names.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.renameI" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticRepeat_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L868-L880">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticRepeat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticRepeat_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>repeat tac</code> repeatedly applies <code>tac</code> so long as it succeeds.
The tactic <code>tac</code> may be a tactic sequence, and if <code>tac</code> fails at any point in its execution,
<code>repeat</code> will revert any partial changes that <code>tac</code> made to the tactic state.</p><p>The tactic <code>tac</code> should eventually fail, otherwise <code>repeat tac</code> will run indefinitely.</p><p>See also:</p><ul>
<li><code>try tac</code> is like <code>repeat tac</code> but will apply <code>tac</code> at most once.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.repeat'">repeat'</a> tac</code> recursively applies <code>tac</code> to each goal.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.first">first</a> | tac1 | tac2</code> implements the backtracking used by <code>repeat</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticRepeat_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.repeat'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L884-L892">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.repeat'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">repeat'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.repeat'">repeat'</a> tac</code> recursively applies <code>tac</code> on all of the goals so long as it succeeds.
That is to say, if <code>tac</code> produces multiple subgoals, then <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.repeat'">repeat'</a> tac</code> is applied to each of them.</p><p>See also:</p><ul>
<li><code>repeat tac</code> simply repeatedly applies <code>tac</code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.repeat1'">repeat1'</a> tac</code> is <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.repeat'">repeat'</a> tac</code> but requires that <code>tac</code> succeed for some goal at least once.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.repeat'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.repeat1'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L894-L902">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.repeat1'"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">repeat1'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.repeat1'">repeat1'</a> tac</code> recursively applies to <code>tac</code> on all of the goals so long as it succeeds,
but <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.repeat1'">repeat1'</a> tac</code> fails if <code>tac</code> succeeds on none of the initial goals.</p><p>See also:</p><ul>
<li><code>repeat tac</code> simply applies <code>tac</code> repeatedly.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.repeat'">repeat'</a> tac</code> is like <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.repeat1'">repeat1'</a> tac</code> but it does not require that <code>tac</code> succeed at least once.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.repeat1'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticTrivial"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L904-L912">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticTrivial"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticTrivial</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Core.html#trivial">trivial</a></code> tries different simple tactics (e.g., <code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a></code>, ...)
to close the current goal.
You can use the command <code>macro_rules</code> to extend the set of tactics used. Example:</p><pre><code>macro_rules | `(tactic| trivial) =&gt; `(tactic| simp)
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticTrivial">Lean.Parser.Tactic.tacticTrivial</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticTrivial</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;trivial&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticTrivial" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.split"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L914-L926">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.split"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">split</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.split">split</a></code> tactic is useful for breaking nested if-then-else and <code>match</code> expressions into separate cases.
For a <code>match</code> expression with <code>n</code> cases, the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.split">split</a></code> tactic generates at most <code>n</code> subgoals.</p><p>For example, given <code>n : <a href=".././Init/Prelude.html#Nat">Nat</a></code>, and a target <code>if n = 0 then Q else R</code>, <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.split">split</a></code> will generate
one goal with hypothesis <code>n = 0</code> and target <code>Q</code>, and a second goal with hypothesis
<code>¬n = 0</code> and target <code>R</code>.  Note that the introduced hypothesis is unnamed, and is commonly
renamed used the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.case">case</a></code> or <code>next</code> tactics.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.split">split</a></code> will split the goal (target).</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.split">split</a> at h</code> will split the hypothesis <code>h</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.split" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.dbgTrace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L928-L937">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.dbgTrace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">dbgTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>dbg_trace &quot;foo&quot;</code> prints <code>foo</code> when elaborated.
Useful for debugging tactic control flow:</p><pre><code>example : <a href=".././Init/Prelude.html#False">False</a> ∨ <a href=".././Init/Prelude.html#True">True</a> := by
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.first">first</a>
  | <a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a> Or.inl; trivial; dbg_trace &quot;left&quot;
  | <a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a> Or.inr; trivial; dbg_trace &quot;right&quot;
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.dbgTrace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticStop_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L945-L945">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticStop_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticStop_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>stop</code> is a helper tactic for &quot;discarding&quot; the rest of a proof:
it is defined as <code>repeat sorry</code>.
It is useful when working on the middle of a complex proofs,
and less messy than commenting the remainder of the proof.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticStop_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.specialize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L947-L955">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.specialize"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">specialize</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The tactic <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.specialize">specialize</a> h a₁ ... aₙ</code> works on local hypothesis <code>h</code>.
The premises of this hypothesis, either universal quantifications or
non-dependent implications, are instantiated by concrete terms coming
from arguments <code>a₁</code> ... <code>aₙ</code>.
The tactic adds a new hypothesis with the same name <code>h := h a₁ ... aₙ</code>
and tries to clear the previous one.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.specialize" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticUnhygienic_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L976-L976">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticUnhygienic_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticUnhygienic_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>unhygienic tacs</code> runs <code>tacs</code> with name hygiene disabled.
This means that tactics that would normally create inaccessible names will instead
make regular variables. <strong>Warning</strong>: Tactics may change their variable naming
strategies at any time, so code that depends on autogenerated names is brittle.
Users should try not to use <code>unhygienic</code> if possible.</p><pre><code>example : ∀ x : Nat, x = x := by unhygienic
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a>            -- x would normally be intro'd as inaccessible
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> <a href=".././Init/Prelude.html#Eq.refl">Eq.refl</a> x  -- refer to x
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticUnhygienic_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.checkpoint"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L978-L989">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.checkpoint"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">checkpoint</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.checkpoint">checkpoint</a> tac</code> acts the same as <code>tac</code>, but it caches the input and output of <code>tac</code>,
and if the file is re-elaborated and the input matches, the tactic is not re-run and
its effects are reapplied to the state. This is useful for improving responsiveness
when working on a long tactic proof, by wrapping expensive tactics with <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.checkpoint">checkpoint</a></code>.</p><p>See the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.save">save</a></code> tactic, which may be more convenient to use.</p><p>(TODO: do this automatically and transparently so that users don't have to use
this combinator explicitly.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.checkpoint" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.save"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1001-L1001">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.save"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">save</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.save">save</a></code> is defined to be the same as <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.skip">skip</a></code>, but the elaborator has
special handling for occurrences of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.save">save</a></code> in tactic scripts and will transform
<code>by tac1; save; tac2</code> to <code>by (checkpoint tac1); tac2</code>, meaning that the effect of <code>tac1</code>
will be cached and replayed. This is useful for improving responsiveness
when working on a long tactic proof, by using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.save">save</a></code> after expensive tactics.</p><p>(TODO: do this automatically and transparently so that users don't have to use
this combinator explicitly.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.save">Lean.Parser.Tactic.save</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.save</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;save&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.save" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.sleep"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1003-L1007">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.sleep"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">sleep</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The tactic <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.sleep">sleep</a> ms</code> sleeps for <code>ms</code> milliseconds and does nothing.
It is used for debugging purposes only.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.sleep" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«tacticExists_,,»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1013-L1014">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.«tacticExists_,,»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tacticExists_,,»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>exists e₁, e₂, ...</code> is shorthand for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine">refine</a> ⟨e₁, e₂, ...⟩; try <a href=".././Init/Core.html#trivial">trivial</a></code>.
It is useful for existential goals.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«tacticExists_,,»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.congr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1016-L1024">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.congr"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">congr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Apply congruence (recursively) to goals of the form <code>⊢ f as = f bs</code> and <code>⊢ <a href=".././Init/Prelude.html#HEq">HEq</a> (f as) (f bs)</code>.
The optional parameter is the depth of the recursive applications.
This is useful when <code><a href=".././Init/Prelude.html#congr">congr</a></code> is too aggressive in breaking down the goal.
For example, given <code>⊢ f (g (x + y)) = f (g (y + x))</code>,
<code><a href=".././Init/Prelude.html#congr">congr</a></code> produces the goals <code>⊢ x = y</code> and <code>⊢ y = x</code>,
while <code><a href=".././Init/Prelude.html#congr">congr</a> 2</code> produces the intended <code>⊢ x + y = y + x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.congr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacDepIfThenElse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1027-L1042">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacDepIfThenElse"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacDepIfThenElse</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>In tactic mode, <code>if h : t then tac1 else tac2</code> can be used as alternative syntax for:</p><pre><code>by_cases h : t
· tac1
· tac2
</code></pre><p>It performs case distinction on <code>h : t</code> or <code>h : ¬t</code> and <code>tac1</code> and <code>tac2</code> are the subproofs.</p><p>You can use <code>?_</code> or <code>_</code> for either subproof to delay the goal to after the tactic, but
if a tactic sequence is provided for <code>tac1</code> or <code>tac2</code> then it will require the goal to be closed
by the end of the block.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacDepIfThenElse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacIfThenElse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1044-L1059">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacIfThenElse"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacIfThenElse</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>In tactic mode, <code>if t then tac1 else tac2</code> is alternative syntax for:</p><pre><code>by_cases t
· tac1
· tac2
</code></pre><p>It performs case distinction on <code>h† : t</code> or <code>h† : ¬t</code>, where <code>h†</code> is an anonymous
hypothesis, and <code>tac1</code> and <code>tac2</code> are the subproofs. (It doesn't actually use
nondependent <code>if</code>, since this wouldn't add anything to the context and hence would be
useless for proving theorems. To actually insert an <code><a href=".././Init/Prelude.html#ite">ite</a></code> application use
<code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.refine">refine</a> if t then ?_ else ?_</code>.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacIfThenElse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticNofun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1065-L1065">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticNofun"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticNofun</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The tactic <code>nofun</code> is shorthand for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> nofun</code>: it introduces the assumptions, then performs an
empty pattern match, closing the goal if the introduced pattern is impossible.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticNofun">Lean.Parser.Tactic.tacticNofun</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticNofun</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;nofun&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticNofun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«tacticNomatch_,,»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1070-L1071">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.«tacticNomatch_,,»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«tacticNomatch_,,»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The tactic <code>nomatch h</code> is shorthand for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> nomatch h</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«tacticNomatch_,,»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.replace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1073-L1102">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.replace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">replace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Acts like <code>have</code>, but removes a hypothesis with the same name as
this one if possible. For example, if the state is:</p><pre><code class="language-lean">f : α → β
h : α
⊢ goal
</code></pre><p>Then after <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.replace">replace</a> h := f h</code> the state will be:</p><pre><code class="language-lean">f : α → β
h : β
⊢ goal
</code></pre><p>whereas <code>have h := f h</code> would result in:</p><pre><code class="language-lean">f : α → β
h† : α
h : β
⊢ goal
</code></pre><p>This can be used to simulate the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.specialize">specialize</a></code> and <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a> at</code> tactics of Coq.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.replace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticAnd_intros"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1104-L1105">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticAnd_intros"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticAnd_intros</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>and_intros</code> applies <code><a href=".././Init/Prelude.html#And.intro">And.intro</a></code> until it does not make progress.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticAnd_intros">Lean.Parser.Tactic.tacticAnd_intros</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticAnd_intros</span> <span class="fn">1024</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;and_intros&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticAnd_intros" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.substEqs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1108-L1112">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.substEqs"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">substEqs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>subst_eq</code> repeatedly substitutes according to the equality proof hypotheses in the context,
replacing the left side of the equality with the right, until no more progress can be made.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.substEqs">Lean.Parser.Tactic.substEqs</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.substEqs</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;subst_eqs&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.substEqs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.runTac"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1114-L1115">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.runTac"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">runTac</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code>run_tac doSeq</code> tactic executes code in <code>TacticM <a href=".././Init/Prelude.html#Unit">Unit</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.runTac" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticHaveI_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1118-L1118">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticHaveI_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticHaveI_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>haveI</code> behaves like <code>have</code>, but inlines the value instead of producing a <code>let_fun</code> term.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticHaveI_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticLetI_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1121-L1121">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticLetI_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticLetI_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>letI</code> behaves like <code>let</code>, but inlines the value instead of producing a <code>let_fun</code> term.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticLetI_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.omega"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1123-L1154">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.omega"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">omega</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.omega">omega</a></code> tactic, for resolving integer and natural linear arithmetic problems.</p><p>It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.</p><p>We handle hypotheses of the form <code>x = y</code>, <code>x &lt; y</code>, <code>x ≤ y</code>, and <code>k ∣ x</code> for <code>x y</code> in <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> or <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code>
(and <code>k</code> a literal), along with negations of these statements.</p><p>We decompose the sides of the inequalities as linear combinations of atoms.</p><p>If we encounter <code>x / k</code> or <code>x % k</code> for literal integers <code>k</code> we introduce new auxiliary variables
and the relevant inequalities.</p><p>On the first pass, we do not perform case splits on natural subtraction.
If <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.omega">omega</a></code> fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.</p><p>The options</p><pre><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.omega">omega</a> (config :=
  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })
</code></pre><p>can be used to:</p><ul>
<li><code>splitDisjunctions</code>: split any disjunctions found in the context,
if the problem is not otherwise solvable.</li>
<li><code>splitNatSub</code>: for each appearance of <code>((a - b : Nat) : Int)</code>, split on <code>a ≤ b</code> if necessary.</li>
<li><code>splitNatAbs</code>: for each appearance of <code><a href=".././Init/Data/Int/Basic.html#Int.natAbs">Int.natAbs</a> a</code>, split on <code>0 ≤ a</code> if necessary.</li>
<li><code>splitMinMax</code>: for each occurrence of <code>min a b</code>, split on <code>min a b = a ∨ min a b = b</code>
Currently, all of these are on by default.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.omega" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticBv_omega"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1161-L1161">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticBv_omega"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticBv_omega</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>bv_omega</code> is <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.omega">omega</a></code> with an additional preprocessor that turns statements about <code><a href=".././Init/Data/BitVec/Basic.html#BitVec">BitVec</a></code> into statements about <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>.
Currently the preprocessor is implemented as <code>try <a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a> only [bv_toNat] at *</code>.
<code>bv_toNat</code> is a <code>@[simp]</code> attribute that you can (cautiously) add to more theorems.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticBv_omega">Lean.Parser.Tactic.tacticBv_omega</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticBv_omega</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;bv_omega&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticBv_omega" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.normCast0"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1163-L1164">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.normCast0"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">normCast0</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Implementation of <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code> (the full <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code> calls <code><a href=".././Init/Core.html#trivial">trivial</a></code> afterwards).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.normCast0" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticAssumption_mod_cast"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1173-L1173">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticAssumption_mod_cast"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticAssumption_mod_cast</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>assumption_mod_cast</code> is a variant of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code> that solves the goal
using a hypothesis. Unlike <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>, it first pre-processes the goal and
each hypothesis to move casts as far outwards as possible, so it can be used
in more situations.</p><p>Concretely, it runs <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code> on the goal. For each local hypothesis <code>h</code>, it also
normalizes <code>h</code> with <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code> and tries to use that to close the goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticAssumption_mod_cast">Lean.Parser.Tactic.tacticAssumption_mod_cast</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticAssumption_mod_cast</span> <span class="fn">1024</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;assumption_mod_cast&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticAssumption_mod_cast" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.tacticNorm_cast_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1210-L1211">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.tacticNorm_cast_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">tacticNorm_cast_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code> family of tactics is used to normalize certain coercions (<em>casts</em>) in expressions.</p><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code> normalizes casts in the target.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a> at h</code> normalizes casts in hypothesis <code>h</code>.</li>
</ul><p>The tactic is basically a version of <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> with a specific set of lemmas to move casts
upwards in the expression.
Therefore even in situations where non-terminal <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> calls are discouraged (because of fragility),
<code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code> is considered to be safe.
It also has special handling of numerals.</p><p>For instance, given an assumption</p><pre><code class="language-lean">a b : ℤ
h : ↑a + ↑b &lt; (10 : ℚ)
</code></pre><p>writing <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a> at h</code> will turn <code>h</code> into</p><pre><code class="language-lean">h : a + b &lt; 10
</code></pre><p>There are also variants of basic tactics that use <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code> to normalize expressions during
their operation, to make them more flexible about the expressions they accept
(we say that it is a tactic <em>modulo</em> the effects of <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code>):</p><ul>
<li><code>exact_mod_cast</code> for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a></code> and <code>apply_mod_cast</code> for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a></code>.
Writing <code>exact_mod_cast h</code> and <code>apply_mod_cast h</code> will normalize casts
in the goal and <code>h</code> before using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> h</code> or <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a> h</code>.</li>
<li><code>rw_mod_cast</code> for <code>rw</code>. It applies <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code> between rewrites.</li>
<li><code>assumption_mod_cast</code> for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>.
This is effectively <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a> at *; <a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>, but more efficient.
It normalizes casts in the goal and, for every hypothesis <code>h</code> in the context,
it will try to normalize casts in <code>h</code> and use <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> h</code>.</li>
</ul><p>See also <code>push_cast</code>, which moves casts inwards rather than lifting them outwards.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.tacticNorm_cast_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.pushCast"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1213-L1247">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.pushCast"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">pushCast</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>push_cast</code> rewrites the goal to move certain coercions (<em>casts</em>) inward, toward the leaf nodes.
This uses <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code> lemmas in the forward direction.
For example, <code>↑(a + b)</code> will be written to <code>↑a + ↑b</code>.</p><ul>
<li><code>push_cast</code> moves casts inward in the goal.</li>
<li><code>push_cast at h</code> moves casts inward in the hypothesis <code>h</code>.
It can be used with extra simp lemmas with, for example, <code>push_cast [Int.add_zero]</code>.</li>
</ul><p>Example:</p><pre><code class="language-lean">example (a b : Nat)
    (h1 : ((a + b : Nat) : Int) = 10)
    (h2 : ((a + b + 0 : Nat) : Int) = 10) :
    ((a + b : Nat) : Int) = 10 := by
  /-
  h1 : ↑(a + b) = 10
  h2 : ↑(a + b + 0) = 10
  ⊢ ↑(a + b) = 10
  -/
  push_cast
  /- Now
  ⊢ ↑a + ↑b = 10
  -/
  push_cast at h1
  push_cast [Int.add_zero] at h2
  /- Now
  h1 h2 : ↑a + ↑b = 10
  -/
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a> h1
</code></pre><p>See also <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.pushCast" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.normCastAddElim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1249-L1252">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.normCastAddElim"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">normCastAddElim</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>norm_cast_add_elim foo</code> registers <code>foo</code> as an elim-lemma in <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.normCastAddElim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.symm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1254-L1260">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.symm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">symm</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.symm">symm</a></code> applies to a goal whose target has the form <code>t ~ u</code> where <code>~</code> is a symmetric relation,
that is, a relation which has a symmetry lemma tagged with the attribute [symm].
It replaces the target with <code>u ~ t</code>.</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.symm">symm</a> at h</code> will rewrite a hypothesis <code>h : t ~ u</code> to <code>h : u ~ t</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.symm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.symmSaturate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1262-L1264">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.symmSaturate"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">symmSaturate</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>For every hypothesis <code>h : a ~ b</code> where a <code>@[symm]</code> lemma is available,
add a hypothesis <code>h_symm : b ~ a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.symmSaturate">Lean.Parser.Tactic.symmSaturate</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.symmSaturate</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;symm_saturate&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.symmSaturate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.SolveByElim.erase"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1268-L1269">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.erase"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">erase</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Syntax for omitting a local hypothesis in <code>solve_by_elim</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.SolveByElim.erase" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.SolveByElim.star"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1270-L1271">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.star"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">star</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Syntax for including all local hypotheses in <code>solve_by_elim</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.star">Lean.Parser.Tactic.SolveByElim.star</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;star&quot;</span> <span class="fn">`Lean.Parser.Tactic.SolveByElim.star</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;*&quot;</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.SolveByElim.star" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.SolveByElim.arg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1272-L1273">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.arg"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">arg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Syntax for adding or removing a term, or <code>*</code>, in <code>solve_by_elim</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.SolveByElim.arg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.SolveByElim.args"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1274-L1275">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.args"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">args</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Syntax for adding and removing terms in <code>solve_by_elim</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.SolveByElim.args" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.SolveByElim.using_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1276-L1277">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.SolveByElim.using_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">using_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Syntax for using all lemmas labelled with an attribute in <code>solve_by_elim</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.SolveByElim.using_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.solveByElim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1284-L1322">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.solveByElim"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">solveByElim</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>solve_by_elim</code> calls <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a></code> on the main goal to find an assumption whose head matches
and then repeatedly calls <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a></code> on the generated subgoals until no subgoals remain,
performing at most <code>maxDepth</code> (defaults to 6) recursive steps.</p><p><code>solve_by_elim</code> discharges the current goal or fails.</p><p><code>solve_by_elim</code> performs backtracking if subgoals can not be solved.</p><p>By default, the assumptions passed to <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a></code> are the local context, <code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, <code><a href=".././Init/Core.html#trivial">trivial</a></code>,
<code><a href=".././Init/Prelude.html#congrFun">congrFun</a></code> and <code><a href=".././Init/Prelude.html#congrArg">congrArg</a></code>.</p><p>The assumptions can be modified with similar syntax as for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code>:</p><ul>
<li><code>solve_by_elim [h₁, h₂, ..., hᵣ]</code> also applies the given expressions.</li>
<li><code>solve_by_elim only [h₁, h₂, ..., hᵣ]</code> does not include the local context,
<code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, <code><a href=".././Init/Core.html#trivial">trivial</a></code>, <code><a href=".././Init/Prelude.html#congrFun">congrFun</a></code>, or <code><a href=".././Init/Prelude.html#congrArg">congrArg</a></code> unless they are explicitly included.</li>
<li><code>solve_by_elim [-h₁, ... -hₙ]</code> removes the given local hypotheses.</li>
<li><code>solve_by_elim using [a₁, ...]</code> uses all lemmas which have been labelled
with the attributes <code>aᵢ</code> (these attributes must be created using <code>register_label_attr</code>).</li>
</ul><p><code>solve_by_elim*</code> tries to solve all goals together, using backtracking if a solution for one goal
makes other goals impossible.
(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)</p><p>Optional arguments passed via a configuration argument as <code>solve_by_elim (config := { ... })</code></p><ul>
<li><code>maxDepth</code>: number of attempts at discharging generated subgoals</li>
<li><code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.symm">symm</a></code>: adds all hypotheses derived by <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.symm">symm</a></code> (defaults to <code>true</code>).</li>
<li><code>exfalso</code>: allow calling <code>exfalso</code> and trying again if <code>solve_by_elim</code> fails
(defaults to <code>true</code>).</li>
<li><code>transparency</code>: change the transparency mode when calling <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a></code>. Defaults to <code>.default</code>,
but it is often useful to change to <code>.reducible</code>,
so semireducible definitions will not be unfolded when trying to apply a lemma.</li>
</ul><p>See also the doc-comment for <code><a href=".././Lean/Meta/Tactic/Backtrack.html#Lean.Meta.Tactic.Backtrack.BacktrackConfig">Lean.Meta.Tactic.Backtrack.BacktrackConfig</a></code> for the options
<code>proc</code>, <code>suspend</code>, and <code>discharge</code> which allow further customization of <code>solve_by_elim</code>.
Both <code>apply_assumption</code> and <code>apply_rules</code> are implemented via these hooks.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.solveByElim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.applyAssumption"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1324-L1345">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.applyAssumption"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">applyAssumption</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>apply_assumption</code> looks for an assumption of the form <code>... → ∀ _, ... → head</code>
where <code>head</code> matches the current goal.</p><p>You can specify additional rules to apply using <code>apply_assumption [...]</code>.
By default <code>apply_assumption</code> will also try <code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, <code><a href=".././Init/Core.html#trivial">trivial</a></code>, <code><a href=".././Init/Prelude.html#congrFun">congrFun</a></code>, and <code><a href=".././Init/Prelude.html#congrArg">congrArg</a></code>.
If you don't want these, or don't want to use all hypotheses, use <code>apply_assumption only [...]</code>.
You can use <code>apply_assumption [-h]</code> to omit a local hypothesis.
You can use <code>apply_assumption using [a₁, ...]</code> to use all lemmas which have been labelled
with the attributes <code>aᵢ</code> (these attributes must be created using <code>register_label_attr</code>).</p><p><code>apply_assumption</code> will use consequences of local hypotheses obtained via <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.symm">symm</a></code>.</p><p>If <code>apply_assumption</code> fails, it will call <code>exfalso</code> and try again.
Thus if there is an assumption of the form <code>P → ¬ Q</code>, the new tactic state
will have two goals, <code>P</code> and <code>Q</code>.</p><p>You can pass a further configuration via the syntax <code>apply_rules (config := {...}) lemmas</code>.
The options supported are the same as for <code>solve_by_elim</code> (and include all the options for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a></code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.applyAssumption" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.applyRules"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1347-L1370">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.applyRules"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">applyRules</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>apply_rules [l₁, l₂, ...]</code> tries to solve the main goal by iteratively
applying the list of lemmas <code>[l₁, l₂, ...]</code> or by applying a local hypothesis.
If <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a></code> generates new goals, <code>apply_rules</code> iteratively tries to solve those goals.
You can use <code>apply_rules [-h]</code> to omit a local hypothesis.</p><p><code>apply_rules</code> will also use <code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, <code><a href=".././Init/Core.html#trivial">trivial</a></code>, <code><a href=".././Init/Prelude.html#congrFun">congrFun</a></code> and <code><a href=".././Init/Prelude.html#congrArg">congrArg</a></code>.
These can be disabled, as can local hypotheses, by using <code>apply_rules only [...]</code>.</p><p>You can use <code>apply_rules using [a₁, ...]</code> to use all lemmas which have been labelled
with the attributes <code>aᵢ</code> (these attributes must be created using <code>register_label_attr</code>).</p><p>You can pass a further configuration via the syntax <code>apply_rules (config := {...})</code>.
The options supported are the same as for <code>solve_by_elim</code> (and include all the options for <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a></code>).</p><p><code>apply_rules</code> will try calling <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.symm">symm</a></code> on hypotheses and <code>exfalso</code> on the goal as needed.
This can be disabled with <code>apply_rules (config := {symm := false, exfalso := false})</code>.</p><p>You can bound the iteration depth using the syntax <code>apply_rules (config := {maxDepth := n})</code>.</p><p>Unlike <code>solve_by_elim</code>, <code>apply_rules</code> does not perform backtracking, and greedily applies
a lemma from the list until it gets stuck.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.applyRules" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.exact?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1373-L1381">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.exact?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">exact?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Searches environment for definitions or theorems that can solve the goal using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a></code>
with conditions resolved by <code>solve_by_elim</code>.</p><p>The optional <code>using</code> clause provides identifiers in the local context that must be
used by <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.exact?">exact?</a></code> when closing the goal.  This is most useful if there are multiple
ways to resolve the goal, and one wants to guide which lemma is used.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.exact?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.apply?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1383-L1390">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.apply?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">apply?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Searches environment for definitions or theorems that can refine the goal using <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a></code>
with conditions resolved when possible with <code>solve_by_elim</code>.</p><p>The optional <code>using</code> clause provides identifiers in the local context that must be
used when closing the goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.apply?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rewrites_forbidden"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1392-L1395">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rewrites_forbidden"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rewrites_forbidden</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Syntax for excluding some names, e.g. <code>[-my_lemma, -my_theorem]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rewrites_forbidden" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.rewrites?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1397-L1406">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.rewrites?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">rewrites?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rw?</code> tries to find a lemma which can rewrite the goal.</p><p><code>rw?</code> should not be left in proofs; it is a search tool, like <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.apply?">apply?</a></code>.</p><p>Suggestions are printed as <code>rw [h]</code> or <code>rw [← h]</code>.</p><p>You can use <code>rw? [-my_lemma, -my_theorem]</code> to prevent <code>rw?</code> using the named lemmas.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.rewrites?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.showTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1408-L1414">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.showTerm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">showTerm</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>show_term tac</code> runs <code>tac</code>, then prints the generated term in the form
&quot;exact X Y Z&quot; or &quot;refine X ?_ Z&quot; if there are remaining subgoals.</p><p>(For some tactics, the printed term will not be human readable.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.showTerm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.showTermElab"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1419-L1420">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.showTermElab"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">showTermElab</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>show_term e</code> elaborates <code>e</code>, then prints the generated term.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.showTermElab" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.by?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1426-L1426">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Tactic.by?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">by?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The command <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.by?">by?</a></code> will print a suggestion for replacing the proof block with a proof term
using <code>show_term</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Tactic.by?">Lean.Parser.Tactic.by?</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.by?</span> <span class="fn">1022</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;by?&quot;</span>)</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span>)</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.by?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.simp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1431-L1475">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Attr.simp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">simp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Theorems tagged with the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> attribute are used by the simplifier
(i.e., the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> tactic, and its variants) to simplify expressions occurring in your goals.
We call theorems tagged with the <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> attribute &quot;simp theorems&quot; or &quot;simp lemmas&quot;.
Lean maintains a database/index containing all active simp theorems.
Here is an example of a simp theorem.</p><pre><code class="language-lean">@[simp] theorem <a href=".././Init/SimpLemmas.html#ne_eq">ne_eq</a> (a b : α) : (a ≠ b) = <a href=".././Init/Prelude.html#Not">Not</a> (a = b) := <a href=".././Init/Prelude.html#rfl">rfl</a>
</code></pre><p>This simp theorem instructs the simplifier to replace instances of the term
<code>a ≠ b</code> (e.g. <code>x + 0 ≠ y</code>) with <code><a href=".././Init/Prelude.html#Not">Not</a> (a = b)</code> (e.g., <code><a href=".././Init/Prelude.html#Not">Not</a> (x + 0 = y)</code>).
The simplifier applies simp theorems in one direction only:
if <code>A = B</code> is a simp theorem, then <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> replaces <code>A</code>s with <code>B</code>s,
but it doesn't replace <code>B</code>s with <code>A</code>s. Hence a simp theorem should have the
property that its right-hand side is &quot;simpler&quot; than its left-hand side.
In particular, <code>=</code> and <code>↔</code> should not be viewed as symmetric operators in this situation.
The following would be a terrible simp theorem (if it were even allowed):</p><pre><code class="language-lean">@[simp] lemma mul_right_inv_bad (a : G) : 1 = a * a⁻¹ := ...
</code></pre><p>Replacing 1 with a * a⁻¹ is not a sensible default direction to travel.
Even worse would be a theorem that causes expressions to grow without bound,
causing simp to loop forever.</p><p>By default the simplifier applies <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> theorems to an expression <code>e</code>
after its sub-expressions have been simplified.
We say it performs a bottom-up simplification.
You can instruct the simplifier to apply a theorem before its sub-expressions
have been simplified by using the modifier <code>↓</code>. Here is an example</p><pre><code class="language-lean">@[simp↓] theorem not_and_eq (p q : Prop) : (¬ (p ∧ q)) = (¬p ∨ ¬q) :=
</code></pre><p>When multiple simp theorems are applicable, the simplifier uses the one with highest priority.
The equational theorems of function are applied at very low priority (100 and below).
If there are several with the same priority, it is uses the &quot;most recent one&quot;. Example:</p><pre><code class="language-lean">@[simp high] theorem <a href=".././Init/SimpLemmas.html#cond_true">cond_true</a> (a b : α) : <a href=".././Init/Prelude.html#cond">cond</a> true a b = a := <a href=".././Init/Prelude.html#rfl">rfl</a>
@[simp low+1] theorem <a href=".././Init/SimpLemmas.html#or_true">or_true</a> (p : Prop) : (p ∨ True) = <a href=".././Init/Prelude.html#True">True</a> :=
  <a href=".././Init/Core.html#propext">propext</a> &lt;| <a href=".././Init/Core.html#Iff.intro">Iff.intro</a> (fun _ =&gt; trivial) (fun _ =&gt; <a href=".././Init/Prelude.html#Or.inr">Or.inr</a> trivial)
@[simp 100] theorem <a href=".././Init/SimpLemmas.html#ite_self">ite_self</a> {d : <a href=".././Init/Prelude.html#Decidable">Decidable</a> c} (a : α) : <a href=".././Init/Prelude.html#ite">ite</a> c a a = a := by
  <a href=".././Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a> d &lt;;&gt; <a href=".././Init/Prelude.html#rfl">rfl</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.simp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grind_norm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1477-L1480">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Attr.grind_norm"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind_norm</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Theorems tagged with the <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.grind_norm">grind_norm</a></code> attribute are used by the <code>grind</code> tactic normalizer/pre-processor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grind_norm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.grind_norm_proc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1482-L1485">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Attr.grind_norm_proc"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">grind_norm_proc</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Simplification procedures tagged with the <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.grind_norm_proc">grind_norm_proc</a></code> attribute are used by the <code>grind</code> tactic normalizer/pre-processor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.grind_norm_proc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.normCastLabel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1488-L1489">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Attr.normCastLabel"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">normCastLabel</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The possible <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code> kinds: <code>elim</code>, <code>move</code>, or <code>squash</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.normCastLabel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Attr.norm_cast"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1491-L1537">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">norm_cast</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code> attribute should be given to lemmas that describe the
behaviour of a coercion with respect to an operator, a relation, or a particular
function.</p><p>It only concerns equality or iff lemmas involving <code>↑</code>, <code>⇑</code> and <code>↥</code>, describing the behavior of
the coercion functions.
It does not apply to the explicit functions that define the coercions.</p><p>Examples:</p><pre><code class="language-lean">@[norm_cast] theorem coe_nat_inj' {m n : ℕ} : (↑m : ℤ) = ↑n ↔ m = n

@[norm_cast] theorem coe_int_denom (n : ℤ) : (n : ℚ).denom = 1

@[norm_cast] theorem cast_id : ∀ n : ℚ, ↑n = n

@[norm_cast] theorem coe_nat_add (m n : ℕ) : (↑(m + n) : ℤ) = ↑m + ↑n

@[norm_cast] theorem cast_coe_nat (n : ℕ) : ((n : ℤ) : α) = n

@[norm_cast] theorem cast_one : ((1 : ℚ) : α) = 1
</code></pre><p>Lemmas tagged with <code>@[norm_cast]</code> are classified into three categories: <code>move</code>, <code>elim</code>, and
<code>squash</code>. They are classified roughly as follows:</p><ul>
<li>elim lemma:   LHS has 0 head coes and ≥ 1 internal coe</li>
<li>move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and ≥ 1 internal coes</li>
<li>squash lemma: LHS has ≥ 1 head coes and 0 internal coes, RHS has fewer head coes</li>
</ul><p><code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code> uses <code>move</code> and <code>elim</code> lemmas to factor coercions toward the root of an expression
and to cancel them from both sides of an equation or relation. It uses <code>squash</code> lemmas to clean
up the result.</p><p>It is typically not necessary to specify these categories, as <code><a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a></code> lemmas are
automatically classified by default. The automatic classification can be overridden by
giving an optional <code>elim</code>, <code>move</code>, or <code>squash</code> parameter to the attribute.</p><pre><code class="language-lean">@[simp, <a href=".././Init/Tactics.html#Lean.Parser.Attr.norm_cast">norm_cast</a> elim] lemma nat_cast_re (n : ℕ) : (n : ℂ).re = n := by
  rw [← of_real_nat_cast, of_real_re]
</code></pre><p>Don't do this unless you understand what you are doing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.norm_cast" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term‹_›»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1544-L1550">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#«term‹_›»"><span class="name">«term‹_›»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>‹t›</code> resolves to an (arbitrary) hypothesis of type <code>t</code>.
It is useful for referring to hypotheses without accessible names.
<code>t</code> may contain holes that are solved by unification with the expected type;
in particular, <code>‹_›</code> is a shortcut for <code>by <a href=".././Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-«term‹_›»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="tacticGet_elem_tactic_trivial"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1553-L1561">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#tacticGet_elem_tactic_trivial"><span class="name">tacticGet_elem_tactic_trivial</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>get_elem_tactic_trivial</code> is an extensible tactic automatically called
by the notation <code>arr[i]</code> to prove any side conditions that arise when
constructing the term (e.g. the index is in bounds of the array).
The default behavior is to just try <code><a href=".././Init/Core.html#trivial">trivial</a></code> (which handles the case
where <code>i &lt; arr.size</code> is in the context) and <code>simp_arith</code> and <code><a href=".././Init/Tactics.html#Lean.Parser.Tactic.omega">omega</a></code>
(for doing linear arithmetic in the index).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#tacticGet_elem_tactic_trivial">tacticGet_elem_tactic_trivial</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`tacticGet_elem_tactic_trivial</span> <span class="fn">1024</span>
    <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;get_elem_tactic_trivial&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-tacticGet_elem_tactic_trivial" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="tacticGet_elem_tactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1574-L1600">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#tacticGet_elem_tactic"><span class="name">tacticGet_elem_tactic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>get_elem_tactic</code> is the tactic automatically called by the notation <code>arr[i]</code>
to prove any side conditions that arise when constructing the term
(e.g. the index is in bounds of the array). It just delegates to
<code>get_elem_tactic_trivial</code> and gives a diagnostic error message otherwise;
users are encouraged to extend <code>get_elem_tactic_trivial</code> instead of this tactic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#tacticGet_elem_tactic">tacticGet_elem_tactic</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`tacticGet_elem_tactic</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;get_elem_tactic&quot;</span> <a href=".././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-tacticGet_elem_tactic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Syntax.exact?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1602-L1606">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#Lean.Parser.Syntax.exact?"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Syntax</span>.<span class="name">exact?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Searches environment for definitions or theorems that can be substituted in
for <code>exact?%</code> to solve the goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Tactics.html#Lean.Parser.Syntax.exact?">Lean.Parser.Syntax.exact?</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Syntax.exact?</span> <span class="fn">1024</span> <span class="fn">(<a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;exact?%&quot;</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Syntax.exact?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="autoParam"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ec3042d94bd11a42430f9e14d39e26b1f880f99b/src/Init/Tactics.lean#L1614-L1614">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Tactics.html#autoParam"><span class="name">autoParam</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args">
<span class="fn">(tactic : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> u</div></div><p>Gadget for automatic parameter support. This is similar to the <code><a href=".././Init/Prelude.html#optParam">optParam</a></code> gadget, but it uses
the given tactic.
Like <code><a href=".././Init/Prelude.html#optParam">optParam</a></code>, this gadget only affects elaboration.
For example, the tactic will <em>not</em> be invoked during type class resolution.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Tactics.html#autoParam">autoParam</a> <span class="fn">α</span> <span class="fn">tactic</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">α</span></span></li></ul></details><details id="instances-for-list-autoParam" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src=".././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>