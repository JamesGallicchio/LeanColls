<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Logic.Relation</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Logic.Relation";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Logic</span>.<span class="name">Relation</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Logic/Relator.html">Mathlib.Logic.Relator</a></li><li><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html">Mathlib.Tactic.MkIffOfInductiveProp</a></li><li><a href="../.././Mathlib/Tactic/SimpRw.html">Mathlib.Tactic.SimpRw</a></li><li><a href="../.././Mathlib/Tactic/Use.html">Mathlib.Tactic.Use</a></li><li><a href="../.././Mathlib/Init/Data/Quot.html">Mathlib.Init.Data.Quot</a></li><li><a href="../.././Mathlib/Logic/Function/Basic.html">Mathlib.Logic.Function.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Logic.Relation" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#IsRefl.reflexive"><span class="name">IsRefl</span>.<span class="name">reflexive</span></a></div><div class="nav_link"><a class="break_within" href="#Reflexive.rel_of_ne_imp"><span class="name">Reflexive</span>.<span class="name">rel_of_ne_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Reflexive.ne_imp_iff"><span class="name">Reflexive</span>.<span class="name">ne_imp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#reflexive_ne_imp_iff"><span class="name">reflexive_ne_imp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Symmetric.iff"><span class="name">Symmetric</span>.<span class="name">iff</span></a></div><div class="nav_link"><a class="break_within" href="#Symmetric.flip_eq"><span class="name">Symmetric</span>.<span class="name">flip_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Symmetric.swap_eq"><span class="name">Symmetric</span>.<span class="name">swap_eq</span></a></div><div class="nav_link"><a class="break_within" href="#flip_eq_iff"><span class="name">flip_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#swap_eq_iff"><span class="name">swap_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Reflexive.comap"><span class="name">Reflexive</span>.<span class="name">comap</span></a></div><div class="nav_link"><a class="break_within" href="#Symmetric.comap"><span class="name">Symmetric</span>.<span class="name">comap</span></a></div><div class="nav_link"><a class="break_within" href="#Transitive.comap"><span class="name">Transitive</span>.<span class="name">comap</span></a></div><div class="nav_link"><a class="break_within" href="#Equivalence.comap"><span class="name">Equivalence</span>.<span class="name">comap</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.Comp"><span class="name">Relation</span>.<span class="name">Comp</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.comp_eq"><span class="name">Relation</span>.<span class="name">comp_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.eq_comp"><span class="name">Relation</span>.<span class="name">eq_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.iff_comp"><span class="name">Relation</span>.<span class="name">iff_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.comp_iff"><span class="name">Relation</span>.<span class="name">comp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.comp_assoc"><span class="name">Relation</span>.<span class="name">comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.flip_comp"><span class="name">Relation</span>.<span class="name">flip_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.Fibration"><span class="name">Relation</span>.<span class="name">Fibration</span></a></div><div class="nav_link"><a class="break_within" href="#Acc.of_fibration"><span class="name">Acc</span>.<span class="name">of_fibration</span></a></div><div class="nav_link"><a class="break_within" href="#Acc.of_downward_closed"><span class="name">Acc</span>.<span class="name">of_downward_closed</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.Map"><span class="name">Relation</span>.<span class="name">Map</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_apply"><span class="name">Relation</span>.<span class="name">map_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_map"><span class="name">Relation</span>.<span class="name">map_map</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_apply_apply"><span class="name">Relation</span>.<span class="name">map_apply_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_id_id"><span class="name">Relation</span>.<span class="name">map_id_id</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instDecidableMapOfExistsAndEq"><span class="name">Relation</span>.<span class="name">instDecidableMapOfExistsAndEq</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.cases_tail_iff"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_tail_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen"><span class="name">Relation</span>.<span class="name">ReflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflGen_iff"><span class="name">Relation</span>.<span class="name">reflGen_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflGen"><span class="name">Relation</span>.<span class="name">ReflGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_iff"><span class="name">Relation</span>.<span class="name">transGen_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflGen.to_reflTransGen"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">to_reflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflGen.mono"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflGen.instIsRefl"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">instIsRefl</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.trans"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.single"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">single</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.head"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">head</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.symmetric"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">symmetric</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.cases_tail"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_tail</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.head_induction_on"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">head_induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.trans_induction_on"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">trans_induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.cases_head"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_head</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.cases_head_iff"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_head_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.total_of_right_unique"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">total_of_right_unique</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.to_reflTransGen"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">to_reflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.trans_left"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_left</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.instTransReflTransGen"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">instTransReflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.trans"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.instTrans_mathlib"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">instTrans_mathlib</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.head'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head'</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.tail'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">tail'</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.head"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.head_induction_on"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head_induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.trans_induction_on"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.trans_right"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_right</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.instTransReflTransGen_1"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">instTransReflTransGen_1</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.tail'_iff"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">tail'_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.head'_iff"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head'_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflGen_eq_self"><span class="name">Relation</span>.<span class="name">reflGen_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflexive_reflGen"><span class="name">Relation</span>.<span class="name">reflexive_reflGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflGen_minimal"><span class="name">Relation</span>.<span class="name">reflGen_minimal</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_eq_self"><span class="name">Relation</span>.<span class="name">transGen_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transitive_transGen"><span class="name">Relation</span>.<span class="name">transitive_transGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instIsTransTransGen"><span class="name">Relation</span>.<span class="name">instIsTransTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_idem"><span class="name">Relation</span>.<span class="name">transGen_idem</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.lift"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.lift'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">lift'</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.closed"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">closed</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.closed'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">closed'</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.mono"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_minimal"><span class="name">Relation</span>.<span class="name">transGen_minimal</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.swap"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">swap</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_swap"><span class="name">Relation</span>.<span class="name">transGen_swap</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_iff_eq"><span class="name">Relation</span>.<span class="name">reflTransGen_iff_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_iff_eq_or_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_iff_eq_or_transGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.lift"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.mono"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_eq_self"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_minimal"><span class="name">Relation</span>.<span class="name">reflTransGen_minimal</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflexive_reflTransGen"><span class="name">Relation</span>.<span class="name">reflexive_reflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transitive_reflTransGen"><span class="name">Relation</span>.<span class="name">transitive_reflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instIsReflReflTransGen"><span class="name">Relation</span>.<span class="name">instIsReflReflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instIsTransReflTransGen"><span class="name">Relation</span>.<span class="name">instIsTransReflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_idem"><span class="name">Relation</span>.<span class="name">reflTransGen_idem</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.lift'"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">lift'</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_closed"><span class="name">Relation</span>.<span class="name">reflTransGen_closed</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.swap"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">swap</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_swap"><span class="name">Relation</span>.<span class="name">reflTransGen_swap</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflGen_transGen"><span class="name">Relation</span>.<span class="name">reflGen_transGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_reflGen"><span class="name">Relation</span>.<span class="name">transGen_reflGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_reflGen"><span class="name">Relation</span>.<span class="name">reflTransGen_reflGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_transGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_eq_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_transGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_eq_reflGen"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_reflGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.Join"><span class="name">Relation</span>.<span class="name">Join</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.church_rosser"><span class="name">Relation</span>.<span class="name">church_rosser</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.join_of_single"><span class="name">Relation</span>.<span class="name">join_of_single</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.symmetric_join"><span class="name">Relation</span>.<span class="name">symmetric_join</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflexive_join"><span class="name">Relation</span>.<span class="name">reflexive_join</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transitive_join"><span class="name">Relation</span>.<span class="name">transitive_join</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.equivalence_join"><span class="name">Relation</span>.<span class="name">equivalence_join</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.equivalence_join_reflTransGen"><span class="name">Relation</span>.<span class="name">equivalence_join_reflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.join_of_equivalence"><span class="name">Relation</span>.<span class="name">join_of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_of_transitive_reflexive"><span class="name">Relation</span>.<span class="name">reflTransGen_of_transitive_reflexive</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_of_equivalence"><span class="name">Relation</span>.<span class="name">reflTransGen_of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#Equivalence.eqvGen_iff"><span class="name">Equivalence</span>.<span class="name">eqvGen_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Equivalence.eqvGen_eq"><span class="name">Equivalence</span>.<span class="name">eqvGen_eq</span></a></div><div class="nav_link"><a class="break_within" href="#EqvGen.mono"><span class="name">EqvGen</span>.<span class="name">mono</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Relation-closures">Relation closures <a class="hover-link" href="#Relation-closures">#</a></h1><p>This file defines the reflexive, transitive, and reflexive transitive closures of relations.
It also proves some basic results on definitions such as <code><a href="../.././Mathlib/Init/Data/Quot.html#EqvGen">EqvGen</a></code>.</p><p>Note that this is about unbundled relations, that is terms of types of the form <code>α → β → Prop</code>. For
the bundled version, see <code>Rel</code>.</p><h2 class="markdown-heading" id="Definitions">Definitions <a class="hover-link" href="#Definitions">#</a></h2><ul>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a></code>: Reflexive closure. <code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> r</code> relates everything <code>r</code> related, plus for all
<code>a</code> it relates <code>a</code> with itself. So <code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> r a b ↔ r a b ∨ a = b</code>.</li>
<li><code><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a></code>: Transitive closure. <code>TransGen r</code> relates everything <code>r</code> related
transitively. So <code>TransGen r a b ↔ ∃ x₀ ... xₙ, r a x₀ ∧ r x₀ x₁ ∧ ... ∧ r xₙ b</code>.</li>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a></code>: Reflexive transitive closure. <code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> r</code> relates everything
<code>r</code> related transitively, plus for all <code>a</code> it relates <code>a</code> with itself. So
<code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> r a b ↔ (∃ x₀ ... xₙ, r a x₀ ∧ r x₀ x₁ ∧ ... ∧ r xₙ b) ∨ a = b</code>. It is the same as
the reflexive closure of the transitive closure, or the transitive closure of the reflexive
closure. In terms of rewriting systems, this means that <code>a</code> can be rewritten to <code>b</code> in a number of
rewrites.</li>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a></code>:  Relation composition. We provide notation <code>∘r</code>. For <code>r : α → β → Prop</code> and
<code>s : β → γ → Prop</code>, <code>r ∘r s</code>relates <code>a : α</code> and <code>c : γ</code> iff there exists <code>b : β</code> that's related to
both.</li>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a></code>: Image of a relation under a pair of maps. For <code>r : α → β → Prop</code>, <code>f : α → γ</code>,
<code>g : β → δ</code>, <code><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Map</a> r f g</code> is the relation <code>γ → δ → Prop</code> relating <code>f a</code> and <code>g b</code> for all <code>a</code>, <code>b</code>
related by <code>r</code>.</li>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a></code>: Join of a relation. For <code>r : α → α → Prop</code>, <code><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Join</a> r a b ↔ ∃ c, r a c ∧ r b c</code>. In
terms of rewriting systems, this means that <code>a</code> and <code>b</code> can be rewritten to the same term.</li>
</ul></div><div class="decl" id="IsRefl.reflexive"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L53-L53">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#IsRefl.reflexive"><span class="name">IsRefl</span>.<span class="name">reflexive</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs.html#IsRefl">IsRefl</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Reflexive.rel_of_ne_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L57-L60">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Reflexive.rel_of_ne_imp"><span class="name">Reflexive</span>.<span class="name">rel_of_ne_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div><p>To show a reflexive relation <code>r : α → α → Prop</code> holds over <code>x y : α</code>,
it suffices to show it holds when <code>x ≠ y</code>.</p></div></div><div class="decl" id="Reflexive.ne_imp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L65-L66">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Reflexive.ne_imp_iff"><span class="name">Reflexive</span>.<span class="name">ne_imp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span></div></div><p>If a reflexive relation <code>r : α → α → Prop</code> holds over <code>x y : α</code>,
then it holds whether or not <code>x ≠ y</code>.</p></div></div><div class="decl" id="reflexive_ne_imp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L70-L71">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#reflexive_ne_imp_iff"><span class="name">reflexive_ne_imp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs.html#IsRefl">IsRefl</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span></div></div><p>If a reflexive relation <code>r : α → α → Prop</code> holds over <code>x y : α</code>,
then it holds whether or not <code>x ≠ y</code>. Unlike <code><a href="../.././Mathlib/Logic/Relation.html#Reflexive.ne_imp_iff">Reflexive.ne_imp_iff</a></code>, this uses <code>[IsRefl α r]</code>.</p></div></div><div class="decl" id="Symmetric.iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L73-L74">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Symmetric.iff"><span class="name">Symmetric</span>.<span class="name">iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Symmetric">Symmetric</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">y</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Symmetric.flip_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L76-L77">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Symmetric.flip_eq"><span class="name">Symmetric</span>.<span class="name">flip_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Symmetric">Symmetric</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#flip">flip</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Symmetric.swap_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L79-L80">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Symmetric.swap_eq"><span class="name">Symmetric</span>.<span class="name">swap_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Symmetric">Symmetric</a> <span class="fn">r</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="flip_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L82-L83">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#flip_eq_iff"><span class="name">flip_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#flip">flip</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Symmetric">Symmetric</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="swap_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L85-L86">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#swap_eq_iff"><span class="name">swap_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Symmetric">Symmetric</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Reflexive.comap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L94-L94">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Reflexive.comap"><span class="name">Reflexive</span>.<span class="name">comap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">(<span class="fn">r</span> <a href="../.././Mathlib/Logic/Function/Defs.html#Function.onFun">on</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Symmetric.comap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L96-L96">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Symmetric.comap"><span class="name">Symmetric</span>.<span class="name">comap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Symmetric">Symmetric</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Symmetric">Symmetric</a> <span class="fn">(<span class="fn">r</span> <a href="../.././Mathlib/Logic/Function/Defs.html#Function.onFun">on</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Transitive.comap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L98-L99">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Transitive.comap"><span class="name">Transitive</span>.<span class="name">comap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Transitive">Transitive</a> <span class="fn">(<span class="fn">r</span> <a href="../.././Mathlib/Logic/Function/Defs.html#Function.onFun">on</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Equivalence.comap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L101-L102">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Equivalence.comap"><span class="name">Equivalence</span>.<span class="name">comap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">(<span class="fn">r</span> <a href="../.././Mathlib/Logic/Function/Defs.html#Function.onFun">on</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Relation.Comp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L116-L117">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.Comp"><span class="name">Relation</span>.<span class="name">Comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">γ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>The composition of two relations, yielding a new relation.  The result
relates a term of <code>α</code> and a term of <code>γ</code> if there is an intermediate
term of <code>β</code> related to both.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">r</span> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span></li></ul></details><details id="instances-for-list-Relation.Comp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.comp_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L122-L124">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.comp_eq"><span class="name">Relation</span>.<span class="name">comp_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">r</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x_1</span></span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.eq_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L126-L128">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.eq_comp"><span class="name">Relation</span>.<span class="name">eq_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">(fun (<span class="fn">x</span> <span class="fn">x_1</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x_1</span></span>)</span> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.iff_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L130-L132">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.iff_comp"><span class="name">Relation</span>.<span class="name">iff_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">(fun (<span class="fn">x</span> <span class="fn">x_1</span> : <a href="../.././foundational_types.html">Prop</a>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">x_1</span></span>)</span> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.comp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L134-L136">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.comp_iff"><span class="name">Relation</span>.<span class="name">comp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">r</span> <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <a href="../.././foundational_types.html">Prop</a>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">x_1</span></span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L138-L143">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.comp_assoc"><span class="name">Relation</span>.<span class="name">comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">γ</span> → <span class="fn"><span class="fn">δ</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">r</span> <span class="fn">p</span>)</span> <span class="fn">q</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">r</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">p</span> <span class="fn">q</span>)</span></span></span></div></div></div></div><div class="decl" id="Relation.flip_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L145-L150">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.flip_comp"><span class="name">Relation</span>.<span class="name">flip_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#flip">flip</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">r</span> <span class="fn">p</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">(<a href="../.././Init/Core.html#flip">flip</a> <span class="fn">p</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#flip">flip</a> <span class="fn">r</span>)</span></span></span></div></div></div></div><div class="decl" id="Relation.Fibration"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L161-L162">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.Fibration"><span class="name">Relation</span>.<span class="name">Fibration</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(rα : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(rβ : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>A function <code>f : α → β</code> is a fibration between the relation <code>rα</code> and <code>rβ</code> if for all
<code>a : α</code> and <code>b : β</code>, whenever <code>b : β</code> and <code>f a</code> are related by <code>rβ</code>, <code>b</code> is the image
of some <code>a' : α</code> under <code>f</code>, and <code>a'</code> and <code>a</code> are related by <code>rα</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Fibration">Relation.Fibration</a> <span class="fn">rα</span> <span class="fn">rβ</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∀ ⦃<span class="fn">a</span> : <span class="fn">α</span>⦄ ⦃<span class="fn">b</span> : <span class="fn">β</span>⦄, <span class="fn"><span class="fn"><span class="fn">rβ</span> <span class="fn">b</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span> → <span class="fn">∃ (<span class="fn">a'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">rα</span> <span class="fn">a'</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></span></span></span></li></ul></details><details id="instances-for-list-Relation.Fibration" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Acc.of_fibration"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L168-L172">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Acc.of_fibration"><span class="name">Acc</span>.<span class="name">of_fibration</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{rα : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{rβ : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(fib : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Fibration">Relation.Fibration</a> <span class="fn">rα</span> <span class="fn">rβ</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(ha : <span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">rα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">rβ</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></div></div><p>If <code>f : α → β</code> is a fibration between relations <code>rα</code> and <code>rβ</code>, and <code>a : α</code> is
accessible under <code>rα</code>, then <code>f a</code> is accessible under <code>rβ</code>.</p></div></div><div class="decl" id="Acc.of_downward_closed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L174-L179">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Acc.of_downward_closed"><span class="name">Acc</span>.<span class="name">of_downward_closed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{rβ : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(dc : <span class="fn">∀ {<span class="fn">a</span> : <span class="fn">α</span>} {<span class="fn">b</span> : <span class="fn">β</span>}, <span class="fn"><span class="fn"><span class="fn">rβ</span> <span class="fn">b</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span> → <span class="fn">∃ (<span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(ha : <span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">(<a href="../.././Init/Core.html#InvImage">InvImage</a> <span class="fn">rβ</span> <span class="fn">f</span>)</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">rβ</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></div></div></div></div><div class="decl" id="Relation.Map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L191-L192">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.Map"><span class="name">Relation</span>.<span class="name">Map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">γ</span> → <span class="fn"><span class="fn">δ</span> → <a href="../.././foundational_types.html">Prop</a></span></span></div></div><p>The map of a relation <code>r</code> through a pair of functions pushes the
relation to the codomains of the functions.  The resulting relation is
defined by having pairs of terms related if they have preimages
related by <code>r</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">c</span> <span class="fn">d</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">g</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></span></span></span></li></ul></details><details id="instances-for-list-Relation.Map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.map_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L194-L194">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_apply"><span class="name">Relation</span>.<span class="name">map_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">γ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">c</span> <span class="fn">d</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">g</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.map_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L196-L202">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_map"><span class="name">Relation</span>.<span class="name">map_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ζ : <a href="../.././foundational_types.html">Type</a> u_6}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₁ : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₁ : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₂ : <span class="fn"><span class="fn">γ</span> → <span class="fn">ε</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₂ : <span class="fn"><span class="fn">δ</span> → <span class="fn">ζ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f₁</span> <span class="fn">g₁</span>)</span> <span class="fn">f₂</span> <span class="fn">g₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">(<span class="fn">f₂</span> <a href="../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f₁</span>)</span> <span class="fn">(<span class="fn">g₂</span> <a href="../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">g₁</span>)</span></span></span></div></div></div></div><div class="decl" id="Relation.map_apply_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L205-L206">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_apply_apply"><span class="name">Relation</span>.<span class="name">map_apply_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hg : <span class="fn"><a href="../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">g</span> <span class="fn">b</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Relation.map_id_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L208-L208">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_id_id"><span class="name">Relation</span>.<span class="name">map_id_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">id</span> <span class="fn">id</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.instDecidableMapOfExistsAndEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L210-L211">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instDecidableMapOfExistsAndEq"><span class="name">Relation</span>.<span class="name">instDecidableMapOfExistsAndEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">γ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">δ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">g</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">c</span> <span class="fn">d</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Relation.instDecidableMapOfExistsAndEq</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst</span></span></li></ul></details></div></div><div class="decl" id="Relation.ReflTransGen.cases_tail_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L218-L218">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.cases_tail_iff"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_tail_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ (<span class="fn">a_1</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">a_1</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">a_1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">a_1</span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L219-L221">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen"><span class="name">Relation</span>.<span class="name">ReflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></div><p><code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> r</code>: reflexive transitive closure of <code>r</code></p><ul class="constructors"><li class="constructor" id="Relation.ReflTransGen.refl">refl: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>} {<span class="fn">a</span> : <span class="fn">α</span>}, <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">a</span></span></span></li><li class="constructor" id="Relation.ReflTransGen.tail">tail: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>} {<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></span></span></span></li></ul><details id="instances-for-list-Relation.ReflTransGen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.reflGen_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L226-L226">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflGen_iff"><span class="name">Relation</span>.<span class="name">reflGen_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ (<span class="fn">a_1</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">a_1</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">a_1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">a_1</span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflGen"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L227-L229">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen"><span class="name">Relation</span>.<span class="name">ReflGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></div><p><code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> r</code>: reflexive closure of <code>r</code></p><ul class="constructors"><li class="constructor" id="Relation.ReflGen.refl">refl: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>} {<span class="fn">a</span> : <span class="fn">α</span>}, <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">a</span></span></span></li><li class="constructor" id="Relation.ReflGen.single">single: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>} {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></li></ul><details id="instances-for-list-Relation.ReflGen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.transGen_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L231-L231">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_iff"><span class="name">Relation</span>.<span class="name">transGen_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ (<span class="fn">a </span><span class="fn">a_1</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">a_1</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">a_1</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">a_1</span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflGen.to_reflTransGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L238-L240">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen.to_reflTransGen"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">to_reflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Relation.ReflGen.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L242-L244">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen.mono"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hp : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Relation.ReflGen.instIsRefl"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L246-L247">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen.instIsRefl"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">instIsRefl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs.html#IsRefl">IsRefl</a> <span class="fn">α</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Relation.ReflTransGen.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L254-L257">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.trans"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.single"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L259-L260">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.single"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">single</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.head"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L262-L265">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.head"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">head</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.symmetric"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L267-L271">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.symmetric"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">symmetric</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Symmetric">Symmetric</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Symmetric">Symmetric</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.cases_tail"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L273-L274">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.cases_tail"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_tail</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.head_induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L277-L285">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.head_induction_on"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">head_induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(refl : <span class="fn"><span class="fn">P</span> <span class="fn">b</span> <span class="fn">⋯</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(head : <span class="fn">∀ {<span class="fn">a </span><span class="fn">c</span> : <span class="fn">α</span>} (<span class="fn">h'</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span>) (<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">c</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.trans_induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L288-L294">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.trans_induction_on"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">trans_induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>} → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ih₁ : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">P</span> <span class="fn">⋯</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ih₂ : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>} (<span class="fn">h</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">⋯</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ih₃ : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>} (<span class="fn">h₁</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>) (<span class="fn">h₂</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">h₁</span></span> → <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">h₂</span></span> → <span class="fn"><span class="fn">P</span> <span class="fn">⋯</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.cases_head"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L296-L301">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.cases_head"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_head</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.cases_head_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L303-L307">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.cases_head_iff"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_head_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.total_of_right_unique"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L309-L319">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.total_of_right_unique"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">total_of_right_unique</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><a href="../.././Mathlib/Logic/Relator.html#Relator.RightUnique">Relator.RightUnique</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ab : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ac : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Relation.TransGen.to_reflTransGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L325-L328">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.to_reflTransGen"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">to_reflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.trans_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L330-L333">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.trans_left"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.instTransReflTransGen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L335-L336">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.instTransReflTransGen"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">instTransReflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Trans">Trans</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Relation.TransGen.instTransReflTransGen</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">trans</span> := <span class="fn">⋯</span> }</span></span></li></ul></details></div></div><div class="decl" id="Relation.TransGen.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L339-L340">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.trans"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.instTrans_mathlib"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L342-L343">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.instTrans_mathlib"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">instTrans_mathlib</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Trans">Trans</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Relation.TransGen.instTrans_mathlib</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">trans</span> := <span class="fn">⋯</span> }</span></span></li></ul></details></div></div><div class="decl" id="Relation.TransGen.head'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L345-L346">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.head'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.tail'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L348-L351">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.tail'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">tail'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.head"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L353-L354">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.head"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.head_induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L357-L365">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.head_induction_on"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head_induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(base : <span class="fn">∀ {<span class="fn">a</span> : <span class="fn">α</span>} (<span class="fn">h</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ih : <span class="fn">∀ {<span class="fn">a </span><span class="fn">c</span> : <span class="fn">α</span>} (<span class="fn">h'</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span>) (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">c</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.trans_induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L368-L374">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.trans_induction_on"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>} → <span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(base : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>} (<span class="fn">h</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">⋯</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ih : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>} (<span class="fn">h₁</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>) (<span class="fn">h₂</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">h₁</span></span> → <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">h₂</span></span> → <span class="fn"><span class="fn">P</span> <span class="fn">⋯</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.trans_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L376-L379">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.trans_right"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.instTransReflTransGen_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L381-L382">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.instTransReflTransGen_1"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">instTransReflTransGen_1</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Trans">Trans</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Relation.TransGen.instTransReflTransGen_1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">trans</span> := <span class="fn">⋯</span> }</span></span></li></ul></details></div></div><div class="decl" id="Relation.TransGen.tail'_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L384-L388">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.tail'_iff"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">tail'_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.TransGen.head'_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L390-L396">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.head'_iff"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head'_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.reflGen_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L403-L405">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflGen_eq_self"><span class="name">Relation</span>.<span class="name">reflGen_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.reflexive_reflGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L407-L407">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflexive_reflGen"><span class="name">Relation</span>.<span class="name">reflexive_reflGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.reflGen_minimal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L409-L411">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflGen_minimal"><span class="name">Relation</span>.<span class="name">reflGen_minimal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r' : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr' : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">r'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hxy : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Relation.transGen_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L417-L422">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_eq_self"><span class="name">Relation</span>.<span class="name">transGen_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(trans : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.transitive_transGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L424-L424">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transitive_transGen"><span class="name">Relation</span>.<span class="name">transitive_transGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Transitive">Transitive</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.instIsTransTransGen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L426-L427">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instIsTransTransGen"><span class="name">Relation</span>.<span class="name">instIsTransTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Relation.transGen_idem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L429-L430">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_idem"><span class="name">Relation</span>.<span class="name">transGen_idem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.TransGen.lift"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L432-L436">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.lift"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.lift'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L438-L441">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.lift'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">lift'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.closed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L443-L445">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.closed"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">closed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Relation.TransGen.closed'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L447-L449">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.closed'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">closed'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(dc : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Relation.TransGen.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L451-L453">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.mono"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Relation.transGen_minimal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L455-L457">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_minimal"><span class="name">Relation</span>.<span class="name">transGen_minimal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r' : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr' : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Transitive">Transitive</a> <span class="fn">r'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hxy : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L459-L462">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.swap"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span>)</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.transGen_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L464-L465">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_swap"><span class="name">Relation</span>.<span class="name">transGen_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span>)</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_iff_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L473-L474">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_iff_eq"><span class="name">Relation</span>.<span class="name">reflTransGen_iff_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_iff_eq_or_transGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L476-L483">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_iff_eq_or_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_iff_eq_or_transGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.lift"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L485-L487">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.lift"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L489-L491">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.mono"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L493-L498">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_eq_self"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(refl : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(trans : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_minimal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L500-L502">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_minimal"><span class="name">Relation</span>.<span class="name">reflTransGen_minimal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r' : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr₁ : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">r'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hr₂ : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Transitive">Transitive</a> <span class="fn">r'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hxy : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Relation.reflexive_reflTransGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L504-L504">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflexive_reflTransGen"><span class="name">Relation</span>.<span class="name">reflexive_reflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.transitive_reflTransGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L506-L506">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transitive_reflTransGen"><span class="name">Relation</span>.<span class="name">transitive_reflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Transitive">Transitive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.instIsReflReflTransGen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L508-L509">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instIsReflReflTransGen"><span class="name">Relation</span>.<span class="name">instIsReflReflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs.html#IsRefl">IsRefl</a> <span class="fn">α</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Relation.instIsTransReflTransGen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L511-L512">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instIsTransReflTransGen"><span class="name">Relation</span>.<span class="name">instIsTransReflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Relation.reflTransGen_idem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L514-L515">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_idem"><span class="name">Relation</span>.<span class="name">reflTransGen_idem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.lift'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L517-L520">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.lift'"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">lift'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_closed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L522-L524">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_closed"><span class="name">Relation</span>.<span class="name">reflTransGen_closed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L526-L529">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.swap"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span>)</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L531-L532">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_swap"><span class="name">Relation</span>.<span class="name">reflTransGen_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span>)</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Relation.reflGen_transGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L534-L536">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflGen_transGen"><span class="name">Relation</span>.<span class="name">reflGen_transGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.transGen_reflGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L538-L545">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_reflGen"><span class="name">Relation</span>.<span class="name">transGen_reflGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_reflGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L547-L548">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_reflGen"><span class="name">Relation</span>.<span class="name">reflTransGen_reflGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_transGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L550-L551">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_transGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_eq_transGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L553-L555">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_eq_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_transGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_eq_reflGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L557-L559">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_eq_reflGen"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_reflGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span></span></span></div></div></div></div><div class="decl" id="Relation.Join"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L570-L570">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.Join"><span class="name">Relation</span>.<span class="name">Join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></div><p>The join of a relation on a single type is a new relation for which
pairs of terms are related if there is a third term they are both
related to.  For example, if <code>r</code> is a relation representing rewrites
in a term rewriting system, then <em>confluence</em> is the property that if
<code>a</code> rewrites to both <code>b</code> and <code>c</code>, then <code>join r</code> relates <code>b</code> and <code>c</code>
(see <code><a href="../.././Mathlib/Logic/Relation.html#Relation.church_rosser">Relation.church_rosser</a></code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∃ (<span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span></li></ul></details><details id="instances-for-list-Relation.Join" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.church_rosser"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L577-L597">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.church_rosser"><span class="name">Relation</span>.<span class="name">church_rosser</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> → <span class="fn">∃ (<span class="fn">d</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">d</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">d</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hab : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hac : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span> <span class="fn">b</span> <span class="fn">c</span></span></div></div><p>A sufficient condition for the Church-Rosser property.</p></div></div><div class="decl" id="Relation.join_of_single"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L600-L601">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.join_of_single"><span class="name">Relation</span>.<span class="name">join_of_single</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hab : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.symmetric_join"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L603-L603">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.symmetric_join"><span class="name">Relation</span>.<span class="name">symmetric_join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Symmetric">Symmetric</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.reflexive_join"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L605-L605">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflexive_join"><span class="name">Relation</span>.<span class="name">reflexive_join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.transitive_join"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L607-L611">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transitive_join"><span class="name">Relation</span>.<span class="name">transitive_join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(ht : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Transitive">Transitive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.equivalence_join"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L613-L615">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.equivalence_join"><span class="name">Relation</span>.<span class="name">equivalence_join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.equivalence_join_reflTransGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L617-L620">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.equivalence_join_reflTransGen"><span class="name">Relation</span>.<span class="name">equivalence_join_reflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> → <span class="fn">∃ (<span class="fn">d</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">d</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">d</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r</span>)</span>)</span></span></div></div></div></div><div class="decl" id="Relation.join_of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L622-L624">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.join_of_equivalence"><span class="name">Relation</span>.<span class="name">join_of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r' : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_of_transitive_reflexive"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L626-L630">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_of_transitive_reflexive"><span class="name">Relation</span>.<span class="name">reflTransGen_of_transitive_reflexive</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r' : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h' : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L632-L634">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_of_equivalence"><span class="name">Relation</span>.<span class="name">reflTransGen_of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r' : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a> <span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Equivalence.eqvGen_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L644-L653">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Equivalence.eqvGen_iff"><span class="name">Equivalence</span>.<span class="name">eqvGen_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Data/Quot.html#EqvGen">EqvGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Equivalence.eqvGen_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L655-L656">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Equivalence.eqvGen_eq"><span class="name">Equivalence</span>.<span class="name">eqvGen_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Data/Quot.html#EqvGen">EqvGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="EqvGen.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Relation.lean#L658-L664">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#EqvGen.mono"><span class="name">EqvGen</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hrp : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Init/Data/Quot.html#EqvGen">EqvGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Data/Quot.html#EqvGen">EqvGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>