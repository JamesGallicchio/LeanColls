<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Logic.Basic</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Logic.Basic";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Logic</span>.<span class="name">Basic</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Batteries/Logic.html">Batteries.Logic</a></li><li><a href="../.././Batteries/Util/LibraryNote.html">Batteries.Util.LibraryNote</a></li><li><a href="../.././Mathlib/Order/Defs.html">Mathlib.Order.Defs</a></li><li><a href="../.././Mathlib/Tactic/Basic.html">Mathlib.Tactic.Basic</a></li><li><a href="../.././Batteries/Tactic/Lint/Basic.html">Batteries.Tactic.Lint.Basic</a></li><li><a href="../.././Mathlib/Data/Int/Notation.html">Mathlib.Data.Int.Notation</a></li><li><a href="../.././Mathlib/Data/Nat/Notation.html">Mathlib.Data.Nat.Notation</a></li><li><a href="../.././Mathlib/Tactic/Attr/Register.html">Mathlib.Tactic.Attr.Register</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Logic.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#hidden"><span class="name">hidden</span></a></div><div class="nav_link"><a class="break_within" href="#decidableEq_of_subsingleton"><span class="name">decidableEq_of_subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonSubtype_mathlib"><span class="name">instSubsingletonSubtype_mathlib</span></a></div><div class="nav_link"><a class="break_within" href="#congr_heq"><span class="name">congr_heq</span></a></div><div class="nav_link"><a class="break_within" href="#congr_arg_heq"><span class="name">congr_arg_heq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_iff_eq_cancel_left"><span class="name">eq_iff_eq_cancel_left</span></a></div><div class="nav_link"><a class="break_within" href="#eq_iff_eq_cancel_right"><span class="name">eq_iff_eq_cancel_right</span></a></div><div class="nav_link"><a class="break_within" href="#ne_and_eq_iff_right"><span class="name">ne_and_eq_iff_right</span></a></div><div class="nav_link"><a class="break_within" href="#Fact"><span class="name">Fact</span></a></div><div class="nav_link"><a class="break_within" href="#Fact.out"><span class="name">Fact</span>.<span class="name">out</span></a></div><div class="nav_link"><a class="break_within" href="#Fact.elim"><span class="name">Fact</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#fact_iff"><span class="name">fact_iff</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableFact"><span class="name">instDecidableFact</span></a></div><div class="nav_link"><a class="break_within" href="#Function.swap₂"><span class="name">Function</span>.<span class="name">swap₂</span></a></div><div class="nav_link"><a class="break_within" href="#instIsReflPropIff"><span class="name">instIsReflPropIff</span></a></div><div class="nav_link"><a class="break_within" href="#instIsTransPropIff"><span class="name">instIsTransPropIff</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.imp"><span class="name">Iff</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_right_iff"><span class="name">imp_iff_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#and_or_imp"><span class="name">and_or_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.mt"><span class="name">Function</span>.<span class="name">mt</span></a></div><div class="nav_link"><a class="break_within" href="#dec_em"><span class="name">dec_em</span></a></div><div class="nav_link"><a class="break_within" href="#dec_em'"><span class="name">dec_em'</span></a></div><div class="nav_link"><a class="break_within" href="#em"><span class="name">em</span></a></div><div class="nav_link"><a class="break_within" href="#em'"><span class="name">em'</span></a></div><div class="nav_link"><a class="break_within" href="#or_not"><span class="name">or_not</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.eq_or_ne"><span class="name">Decidable</span>.<span class="name">eq_or_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.ne_or_eq"><span class="name">Decidable</span>.<span class="name">ne_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_or_ne"><span class="name">eq_or_ne</span></a></div><div class="nav_link"><a class="break_within" href="#ne_or_eq"><span class="name">ne_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#by_contradiction"><span class="name">by_contradiction</span></a></div><div class="nav_link"><a class="break_within" href="#by_cases"><span class="name">by_cases</span></a></div><div class="nav_link"><a class="break_within" href="#by_contra"><span class="name">by_contra</span></a></div><div class="nav_link"><a class="break_within" href="#of_not_not"><span class="name">of_not_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_ne_iff"><span class="name">not_ne_iff</span></a></div><div class="nav_link"><a class="break_within" href="#of_not_imp"><span class="name">of_not_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Not.decidable_imp_symm"><span class="name">Not</span>.<span class="name">decidable_imp_symm</span></a></div><div class="nav_link"><a class="break_within" href="#Not.imp_symm"><span class="name">Not</span>.<span class="name">imp_symm</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp_comm"><span class="name">not_imp_comm</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp_self"><span class="name">not_imp_self</span></a></div><div class="nav_link"><a class="break_within" href="#Imp.swap"><span class="name">Imp</span>.<span class="name">swap</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.not"><span class="name">Iff</span>.<span class="name">not</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.not_left"><span class="name">Iff</span>.<span class="name">not_left</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.not_right"><span class="name">Iff</span>.<span class="name">not_right</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.ne"><span class="name">Iff</span>.<span class="name">ne</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.ne_left"><span class="name">Iff</span>.<span class="name">ne_left</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.ne_right"><span class="name">Iff</span>.<span class="name">ne_right</span></a></div><div class="nav_link"><a class="break_within" href="#xor_true"><span class="name">xor_true</span></a></div><div class="nav_link"><a class="break_within" href="#xor_false"><span class="name">xor_false</span></a></div><div class="nav_link"><a class="break_within" href="#xor_comm"><span class="name">xor_comm</span></a></div><div class="nav_link"><a class="break_within" href="#instCommutativeXor'"><span class="name">instCommutativeXor'</span></a></div><div class="nav_link"><a class="break_within" href="#xor_self"><span class="name">xor_self</span></a></div><div class="nav_link"><a class="break_within" href="#xor_not_left"><span class="name">xor_not_left</span></a></div><div class="nav_link"><a class="break_within" href="#xor_not_right"><span class="name">xor_not_right</span></a></div><div class="nav_link"><a class="break_within" href="#xor_not_not"><span class="name">xor_not_not</span></a></div><div class="nav_link"><a class="break_within" href="#Xor'.or"><span class="name">Xor'</span>.<span class="name">or</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.and"><span class="name">Iff</span>.<span class="name">and</span></a></div><div class="nav_link"><a class="break_within" href="#And.rotate"><span class="name">And</span>.<span class="name">rotate</span></a></div><div class="nav_link"><a class="break_within" href="#and_symm_right"><span class="name">and_symm_right</span></a></div><div class="nav_link"><a class="break_within" href="#and_symm_left"><span class="name">and_symm_left</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.or"><span class="name">Iff</span>.<span class="name">or</span></a></div><div class="nav_link"><a class="break_within" href="#Or.rotate"><span class="name">Or</span>.<span class="name">rotate</span></a></div><div class="nav_link"><a class="break_within" href="#Or.elim3"><span class="name">Or</span>.<span class="name">elim3</span></a></div><div class="nav_link"><a class="break_within" href="#Or.imp3"><span class="name">Or</span>.<span class="name">imp3</span></a></div><div class="nav_link"><a class="break_within" href="#not_or_of_imp"><span class="name">not_or_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.or_not_of_imp"><span class="name">Decidable</span>.<span class="name">or_not_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#or_not_of_imp"><span class="name">or_not_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_not_or"><span class="name">imp_iff_not_or</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_or_not"><span class="name">imp_iff_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp_not"><span class="name">not_imp_not</span></a></div><div class="nav_link"><a class="break_within" href="#imp_and_neg_imp_iff"><span class="name">imp_and_neg_imp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.mtr"><span class="name">Function</span>.<span class="name">mtr</span></a></div><div class="nav_link"><a class="break_within" href="#or_congr_left'"><span class="name">or_congr_left'</span></a></div><div class="nav_link"><a class="break_within" href="#or_congr_right'"><span class="name">or_congr_right'</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.iff"><span class="name">Iff</span>.<span class="name">iff</span></a></div><div class="nav_link"><a class="break_within" href="#iff_mpr_iff_true_intro"><span class="name">iff_mpr_iff_true_intro</span></a></div><div class="nav_link"><a class="break_within" href="#imp_or"><span class="name">imp_or</span></a></div><div class="nav_link"><a class="break_within" href="#imp_or'"><span class="name">imp_or'</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp"><span class="name">not_imp</span></a></div><div class="nav_link"><a class="break_within" href="#peirce"><span class="name">peirce</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff_not"><span class="name">not_iff_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff_comm"><span class="name">not_iff_comm</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff"><span class="name">not_iff</span></a></div><div class="nav_link"><a class="break_within" href="#iff_not_comm"><span class="name">iff_not_comm</span></a></div><div class="nav_link"><a class="break_within" href="#iff_iff_and_or_not_and_not"><span class="name">iff_iff_and_or_not_and_not</span></a></div><div class="nav_link"><a class="break_within" href="#iff_iff_not_or_and_or_not"><span class="name">iff_iff_not_or_and_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_and_not_right"><span class="name">not_and_not_right</span></a></div><div class="nav_link"><a class="break_within" href="#not_and_or"><span class="name">not_and_or</span></a></div><div class="nav_link"><a class="break_within" href="#or_iff_not_and_not"><span class="name">or_iff_not_and_not</span></a></div><div class="nav_link"><a class="break_within" href="#and_iff_not_or_not"><span class="name">and_iff_not_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_xor"><span class="name">not_xor</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_not_iff"><span class="name">xor_iff_not_iff</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_iff_not"><span class="name">xor_iff_iff_not</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_not_iff'"><span class="name">xor_iff_not_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#Membership.mem.ne_of_not_mem"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Membership.mem.ne_of_not_mem'"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem'</span></a></div><div class="nav_link"><a class="break_within" href="#forall_cond_comm"><span class="name">forall_cond_comm</span></a></div><div class="nav_link"><a class="break_within" href="#forall_mem_comm"><span class="name">forall_mem_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ball_cond_comm"><span class="name">ball_cond_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ball_mem_comm"><span class="name">ball_mem_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ne_of_eq_of_ne"><span class="name">ne_of_eq_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#ne_of_ne_of_eq"><span class="name">ne_of_ne_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.trans_ne"><span class="name">Eq</span>.<span class="name">trans_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.trans_eq"><span class="name">Ne</span>.<span class="name">trans_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_equivalence"><span class="name">eq_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#congr_refl_left"><span class="name">congr_refl_left</span></a></div><div class="nav_link"><a class="break_within" href="#congr_refl_right"><span class="name">congr_refl_right</span></a></div><div class="nav_link"><a class="break_within" href="#congr_arg_refl"><span class="name">congr_arg_refl</span></a></div><div class="nav_link"><a class="break_within" href="#congr_fun_rfl"><span class="name">congr_fun_rfl</span></a></div><div class="nav_link"><a class="break_within" href="#congr_fun_congr_arg"><span class="name">congr_fun_congr_arg</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.rec_eq_cast"><span class="name">Eq</span>.<span class="name">rec_eq_cast</span></a></div><div class="nav_link"><a class="break_within" href="#eqRec_heq'"><span class="name">eqRec_heq'</span></a></div><div class="nav_link"><a class="break_within" href="#rec_heq_of_heq"><span class="name">rec_heq_of_heq</span></a></div><div class="nav_link"><a class="break_within" href="#rec_heq_iff_heq"><span class="name">rec_heq_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_rec_iff_heq"><span class="name">heq_rec_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#pi_congr"><span class="name">pi_congr</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_imp"><span class="name">forall₂_imp</span></a></div><div class="nav_link"><a class="break_within" href="#forall₃_imp"><span class="name">forall₃_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Exists₂.imp"><span class="name">Exists₂</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#Exists₃.imp"><span class="name">Exists₃</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#forall_swap"><span class="name">forall_swap</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_swap"><span class="name">forall₂_swap</span></a></div><div class="nav_link"><a class="break_within" href="#imp_forall_iff"><span class="name">imp_forall_iff</span></a></div><div class="nav_link"><a class="break_within" href="#exists_swap"><span class="name">exists_swap</span></a></div><div class="nav_link"><a class="break_within" href="#not_forall_not"><span class="name">not_forall_not</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_exists_not"><span class="name">forall_or_exists_not</span></a></div><div class="nav_link"><a class="break_within" href="#exists_or_forall_not"><span class="name">exists_or_forall_not</span></a></div><div class="nav_link"><a class="break_within" href="#forall_imp_iff_exists_imp"><span class="name">forall_imp_iff_exists_imp</span></a></div><div class="nav_link"><a class="break_within" href="#forall_true_iff"><span class="name">forall_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#forall_true_iff'"><span class="name">forall_true_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_true_iff"><span class="name">forall₂_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#forall₃_true_iff"><span class="name">forall₃_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#exists_unique_iff_exists"><span class="name">exists_unique_iff_exists</span></a></div><div class="nav_link"><a class="break_within" href="#exists_unique_const"><span class="name">exists_unique_const</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.and_forall_ne"><span class="name">Decidable</span>.<span class="name">and_forall_ne</span></a></div><div class="nav_link"><a class="break_within" href="#and_forall_ne"><span class="name">and_forall_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ne_or_ne"><span class="name">Ne</span>.<span class="name">ne_or_ne</span></a></div><div class="nav_link"><a class="break_within" href="#exists_unique_eq"><span class="name">exists_unique_eq</span></a></div><div class="nav_link"><a class="break_within" href="#exists_unique_eq'"><span class="name">exists_unique_eq'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply'"><span class="name">exists_apply_eq_apply'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply2"><span class="name">exists_apply_eq_apply2</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply2'"><span class="name">exists_apply_eq_apply2'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply3"><span class="name">exists_apply_eq_apply3</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply3'"><span class="name">exists_apply_eq_apply3'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq"><span class="name">exists_apply_eq</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_and_eq_and"><span class="name">exists_exists_and_eq_and</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_eq_and"><span class="name">exists_exists_eq_and</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_and_exists_and_eq_and"><span class="name">exists_exists_and_exists_and_eq_and</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_exists_and_eq"><span class="name">exists_exists_exists_and_eq</span></a></div><div class="nav_link"><a class="break_within" href="#forall_apply_eq_imp_iff'"><span class="name">forall_apply_eq_imp_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#forall_eq_apply_imp_iff'"><span class="name">forall_eq_apply_imp_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#exists₂_comm"><span class="name">exists₂_comm</span></a></div><div class="nav_link"><a class="break_within" href="#And.exists"><span class="name">And</span>.<span class="name">exists</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_of_or_forall"><span class="name">forall_or_of_or_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.forall_or_left"><span class="name">Decidable</span>.<span class="name">forall_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_left"><span class="name">forall_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.forall_or_right"><span class="name">Decidable</span>.<span class="name">forall_or_right</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_right"><span class="name">forall_or_right</span></a></div><div class="nav_link"><a class="break_within" href="#exists_unique_prop"><span class="name">exists_unique_prop</span></a></div><div class="nav_link"><a class="break_within" href="#exists_unique_false"><span class="name">exists_unique_false</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.fst"><span class="name">Exists</span>.<span class="name">fst</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.snd"><span class="name">Exists</span>.<span class="name">snd</span></a></div><div class="nav_link"><a class="break_within" href="#Prop.exists_iff"><span class="name">Prop</span>.<span class="name">exists_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Prop.forall_iff"><span class="name">Prop</span>.<span class="name">forall_iff</span></a></div><div class="nav_link"><a class="break_within" href="#exists_iff_of_forall"><span class="name">exists_iff_of_forall</span></a></div><div class="nav_link"><a class="break_within" href="#exists_unique_prop_of_true"><span class="name">exists_unique_prop_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#exists_prop_of_false"><span class="name">exists_prop_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#forall_prop_congr"><span class="name">forall_prop_congr</span></a></div><div class="nav_link"><a class="break_within" href="#forall_prop_congr'"><span class="name">forall_prop_congr'</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr_eq"><span class="name">imp_congr_eq</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr_ctx_eq"><span class="name">imp_congr_ctx_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_true_intro"><span class="name">eq_true_intro</span></a></div><div class="nav_link"><a class="break_within" href="#eq_false_intro"><span class="name">eq_false_intro</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.eq"><span class="name">Iff</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#iff_eq_eq"><span class="name">iff_eq_eq</span></a></div><div class="nav_link"><a class="break_within" href="#forall_true_left"><span class="name">forall_true_left</span></a></div><div class="nav_link"><a class="break_within" href="#ExistsUnique.elim₂"><span class="name">ExistsUnique</span>.<span class="name">elim₂</span></a></div><div class="nav_link"><a class="break_within" href="#ExistsUnique.intro₂"><span class="name">ExistsUnique</span>.<span class="name">intro₂</span></a></div><div class="nav_link"><a class="break_within" href="#ExistsUnique.exists₂"><span class="name">ExistsUnique</span>.<span class="name">exists₂</span></a></div><div class="nav_link"><a class="break_within" href="#ExistsUnique.unique₂"><span class="name">ExistsUnique</span>.<span class="name">unique₂</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.dec"><span class="name">Classical</span>.<span class="name">dec</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.decPred"><span class="name">Classical</span>.<span class="name">decPred</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.decRel"><span class="name">Classical</span>.<span class="name">decRel</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.decEq"><span class="name">Classical</span>.<span class="name">decEq</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.existsCases"><span class="name">Classical</span>.<span class="name">existsCases</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.some_spec₂"><span class="name">Classical</span>.<span class="name">some_spec₂</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.subtype_of_exists"><span class="name">Classical</span>.<span class="name">subtype_of_exists</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.byContradiction'"><span class="name">Classical</span>.<span class="name">byContradiction'</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.choice_of_byContradiction'"><span class="name">Classical</span>.<span class="name">choice_of_byContradiction'</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.choose_eq"><span class="name">Classical</span>.<span class="name">choose_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.choose_eq'"><span class="name">Classical</span>.<span class="name">choose_eq'</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.axiom_of_choice"><span class="name">Classical</span>.<span class="name">axiom_of_choice</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.by_cases"><span class="name">Classical</span>.<span class="name">by_cases</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.by_contradiction"><span class="name">Classical</span>.<span class="name">by_contradiction</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.prop_complete"><span class="name">Classical</span>.<span class="name">prop_complete</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.cases_true_false"><span class="name">Classical</span>.<span class="name">cases_true_false</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.eq_false_or_eq_true"><span class="name">Classical</span>.<span class="name">eq_false_or_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.cases_on"><span class="name">Classical</span>.<span class="name">cases_on</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.cases"><span class="name">Classical</span>.<span class="name">cases</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.classicalRecOn"><span class="name">Exists</span>.<span class="name">classicalRecOn</span></a></div><div class="nav_link"><a class="break_within" href="#bex_def"><span class="name">bex_def</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.elim"><span class="name">BEx</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.intro"><span class="name">BEx</span>.<span class="name">intro</span></a></div><div class="nav_link"><a class="break_within" href="#bex_eq_left"><span class="name">bex_eq_left</span></a></div><div class="nav_link"><a class="break_within" href="#ball_congr"><span class="name">ball_congr</span></a></div><div class="nav_link"><a class="break_within" href="#bex_congr"><span class="name">bex_congr</span></a></div><div class="nav_link"><a class="break_within" href="#BAll.imp_right"><span class="name">BAll</span>.<span class="name">imp_right</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.imp_right"><span class="name">BEx</span>.<span class="name">imp_right</span></a></div><div class="nav_link"><a class="break_within" href="#BAll.imp_left"><span class="name">BAll</span>.<span class="name">imp_left</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.imp_left"><span class="name">BEx</span>.<span class="name">imp_left</span></a></div><div class="nav_link"><a class="break_within" href="#ball_of_forall"><span class="name">ball_of_forall</span></a></div><div class="nav_link"><a class="break_within" href="#forall_of_ball"><span class="name">forall_of_ball</span></a></div><div class="nav_link"><a class="break_within" href="#exists_mem_of_exists"><span class="name">exists_mem_of_exists</span></a></div><div class="nav_link"><a class="break_within" href="#exists_of_exists_mem"><span class="name">exists_of_exists_mem</span></a></div><div class="nav_link"><a class="break_within" href="#exists₂_imp"><span class="name">exists₂_imp</span></a></div><div class="nav_link"><a class="break_within" href="#bex_of_exists"><span class="name">bex_of_exists</span></a></div><div class="nav_link"><a class="break_within" href="#exists_of_bex"><span class="name">exists_of_bex</span></a></div><div class="nav_link"><a class="break_within" href="#bex_imp"><span class="name">bex_imp</span></a></div><div class="nav_link"><a class="break_within" href="#not_exists_mem"><span class="name">not_exists_mem</span></a></div><div class="nav_link"><a class="break_within" href="#not_forall₂_of_exists₂_not"><span class="name">not_forall₂_of_exists₂_not</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.not_forall₂"><span class="name">Decidable</span>.<span class="name">not_forall₂</span></a></div><div class="nav_link"><a class="break_within" href="#not_forall₂"><span class="name">not_forall₂</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_and"><span class="name">forall₂_and</span></a></div><div class="nav_link"><a class="break_within" href="#forall_and_left"><span class="name">forall_and_left</span></a></div><div class="nav_link"><a class="break_within" href="#forall_and_right"><span class="name">forall_and_right</span></a></div><div class="nav_link"><a class="break_within" href="#exists_mem_or"><span class="name">exists_mem_or</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_or_left"><span class="name">forall₂_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#exists_mem_or_left"><span class="name">exists_mem_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#dite_eq_iff"><span class="name">dite_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ite_eq_iff"><span class="name">ite_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#eq_ite_iff"><span class="name">eq_ite_iff</span></a></div><div class="nav_link"><a class="break_within" href="#dite_eq_iff'"><span class="name">dite_eq_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#ite_eq_iff'"><span class="name">ite_eq_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#dite_ne_left_iff"><span class="name">dite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#dite_ne_right_iff"><span class="name">dite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ite_ne_left_iff"><span class="name">ite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ite_ne_right_iff"><span class="name">ite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_eq_left_iff"><span class="name">Ne</span>.<span class="name">dite_eq_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_eq_right_iff"><span class="name">Ne</span>.<span class="name">dite_eq_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_eq_left_iff"><span class="name">Ne</span>.<span class="name">ite_eq_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_eq_right_iff"><span class="name">Ne</span>.<span class="name">ite_eq_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_ne_left_iff"><span class="name">Ne</span>.<span class="name">dite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_ne_right_iff"><span class="name">Ne</span>.<span class="name">dite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_ne_left_iff"><span class="name">Ne</span>.<span class="name">ite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_ne_right_iff"><span class="name">Ne</span>.<span class="name">ite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#dite_eq_or_eq"><span class="name">dite_eq_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#ite_eq_or_eq"><span class="name">ite_eq_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#apply_dite₂"><span class="name">apply_dite₂</span></a></div><div class="nav_link"><a class="break_within" href="#apply_ite₂"><span class="name">apply_ite₂</span></a></div><div class="nav_link"><a class="break_within" href="#dite_apply"><span class="name">dite_apply</span></a></div><div class="nav_link"><a class="break_within" href="#ite_apply"><span class="name">ite_apply</span></a></div><div class="nav_link"><a class="break_within" href="#ite_and"><span class="name">ite_and</span></a></div><div class="nav_link"><a class="break_within" href="#dite_dite_comm"><span class="name">dite_dite_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ite_ite_comm"><span class="name">ite_ite_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ite_prop_iff_or"><span class="name">ite_prop_iff_or</span></a></div><div class="nav_link"><a class="break_within" href="#dite_prop_iff_or"><span class="name">dite_prop_iff_or</span></a></div><div class="nav_link"><a class="break_within" href="#ite_prop_iff_and"><span class="name">ite_prop_iff_and</span></a></div><div class="nav_link"><a class="break_within" href="#dite_prop_iff_and"><span class="name">dite_prop_iff_and</span></a></div><div class="nav_link"><a class="break_within" href="#not_beq_of_ne"><span class="name">not_beq_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#beq_eq_decide"><span class="name">beq_eq_decide</span></a></div><div class="nav_link"><a class="break_within" href="#beq_eq_beq"><span class="name">beq_eq_beq</span></a></div><div class="nav_link"><a class="break_within" href="#beq_ext_iff"><span class="name">beq_ext_iff</span></a></div><div class="nav_link"><a class="break_within" href="#beq_ext"><span class="name">beq_ext</span></a></div><div class="nav_link"><a class="break_within" href="#lawful_beq_subsingleton"><span class="name">lawful_beq_subsingleton</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Basic-logic-properties">Basic logic properties <a class="hover-link" href="#Basic-logic-properties">#</a></h1><p>This file is one of the earliest imports in mathlib.</p><h2 class="markdown-heading" id="Implementation-notes">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>Theorems that require decidability hypotheses are in the namespace <code><a href="../.././Init/Prelude.html#Decidable">Decidable</a></code>.
Classical versions are in the namespace <code>Classical</code>.</p></div><div class="decl" id="hidden"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L48-L48">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#hidden"><span class="name">hidden</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>An identity function with its main argument implicit. This will be printed as <code><a href="../.././Mathlib/Logic/Basic.html#hidden">hidden</a></code> even
if it is applied to a large term, so it can be used for elision,
as done in the <code>elide</code> and <code>unelide</code> tactics.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">hidden</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></li></ul></details><details id="instances-for-list-hidden" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="decidableEq_of_subsingleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L52-L53">source</a></div><div class="attributes">@[instance 10]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#decidableEq_of_subsingleton"><span class="name">decidableEq_of_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#decidableEq_of_subsingleton">decidableEq_of_subsingleton</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="decl" id="instSubsingletonSubtype_mathlib"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L55-L56">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instSubsingletonSubtype_mathlib"><span class="name">instSubsingletonSubtype_mathlib</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<a href="../.././Init/Prelude.html#Subtype">Subtype</a> <span class="fn">p</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="congr_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L58-L60">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_heq"><span class="name">congr_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="congr_arg_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L62-L64">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_arg_heq"><span class="name">congr_arg_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn">f</span> <span class="fn">a₁</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a₂</span>)</span></span></span></div></div></div></div><div class="decl" id="eq_iff_eq_cancel_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L66-L67">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_iff_eq_cancel_left"><span class="name">eq_iff_eq_cancel_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ {<span class="fn">a</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="eq_iff_eq_cancel_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L69-L70">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_iff_eq_cancel_right"><span class="name">eq_iff_eq_cancel_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ {<span class="fn">c</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="ne_and_eq_iff_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L72-L73">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_and_eq_iff_right"><span class="name">ne_and_eq_iff_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Fact"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L92-L95">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Fact"><span class="name">Fact</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>Wrapper for adding elementary propositions to the type class systems.
Warning: this can easily be abused. See the rest of this docstring for details.</p><p>Certain propositions should not be treated as a class globally,
but sometimes it is very convenient to be able to use the type class system
in specific circumstances.</p><p>For example, <code>ZMod p</code> is a field if and only if <code>p</code> is a prime number.
In order to be able to find this field instance automatically by type class search,
we have to turn <code>p.prime</code> into an instance implicit assumption.</p><p>On the other hand, making <code>Nat.prime</code> a class would require a major refactoring of the library,
and it is questionable whether making <code>Nat.prime</code> a class is desirable at all.
The compromise is to add the assumption <code>[Fact p.prime]</code> to <code>ZMod.field</code>.</p><p>In particular, this class is not intended for turning the type class system
into an automated theorem prover for first order logic.</p><ul class="structure_fields" id="Fact.mk"><li id="Fact.out" class="structure_field"><div class="structure_field_info">out : <span class="fn">p</span></div><div class="structure_field_doc"><p><code><a href="../.././Mathlib/Logic/Basic.html#Fact.out">Fact.out</a></code> contains the unwrapped witness for the fact represented by the instance of
<code><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> p</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Fact" class="instances-list"></ul></details></div></div><div class="decl" id="Fact.out"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L95-L95">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Fact.out"><span class="name">Fact</span>.<span class="name">out</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div><p><code><a href="../.././Mathlib/Logic/Basic.html#Fact.out">Fact.out</a></code> contains the unwrapped witness for the fact represented by the instance of
<code><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> p</code>.</p></div></div><div class="decl" id="Fact.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L103-L103">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Fact.elim"><span class="name">Fact</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div></div></div><div class="decl" id="fact_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L104-L104">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#fact_iff"><span class="name">fact_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn">p</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="instDecidableFact"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L106-L107">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instDecidableFact"><span class="name">instDecidableFact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn">p</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableFact</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/PropLemmas.html#decidable_of_iff">decidable_of_iff</a> <span class="fn">p</span> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="decl" id="Function.swap₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L110-L112">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Function.swap₂"><span class="name">Function</span>.<span class="name">swap₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₁ : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₂ : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₁ : <span class="fn"><span class="fn">ι₁</span> → <a href="../.././foundational_types.html">Sort</a> u_4</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₂ : <span class="fn"><span class="fn">ι₂</span> → <a href="../.././foundational_types.html">Sort</a> u_5</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{φ : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn"><span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span> → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn"><span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span> → <a href="../.././foundational_types.html">Sort</a> u_6</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn">(<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>) → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn">(<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>) → <span class="fn"><span class="fn">φ</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i₂ : <span class="fn">ι₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₂ : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i₁ : <span class="fn">ι₁</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₁ : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">φ</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></div></div><p>Swaps two pairs of arguments to a function.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Function.swap₂">Function.swap₂</a> <span class="fn">f</span> <span class="fn">i₂</span> <span class="fn">j₂</span> <span class="fn">i₁</span> <span class="fn">j₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></li></ul></details><details id="instances-for-list-Function.swap₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-propositional-connectives">Declarations about propositional connectives <a class="hover-link" href="#Declarations-about-propositional-connectives">#</a></h3></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-implies">Declarations about <code>implies</code> <a class="hover-link" href="#Declarations-about-implies">#</a></h3></div><div class="decl" id="instIsReflPropIff"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L137-L137">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instIsReflPropIff"><span class="name">instIsReflPropIff</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs.html#IsRefl">IsRefl</a> <a href="../.././foundational_types.html">Prop</a> <a href="../.././Init/Core.html#Iff">Iff</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#instIsReflPropIff">instIsReflPropIff</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="instIsTransPropIff"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L139-L139">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instIsTransPropIff"><span class="name">instIsTransPropIff</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs.html#IsTrans">IsTrans</a> <a href="../.././foundational_types.html">Prop</a> <a href="../.././Init/Core.html#Iff">Iff</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#instIsTransPropIff">instIsTransPropIff</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Iff.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L141-L141">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.imp"><span class="name">Iff</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#imp_congr">imp_congr</a></code>.</p></div></div><div class="decl" id="imp_iff_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L144-L144">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_iff_right_iff"><span class="name">imp_iff_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="and_or_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L147-L147">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_or_imp"><span class="name">and_or_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">c</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Function.mt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L150-L150">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Function.mt"><span class="name">Function</span>.<span class="name">mt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></span></div></div><p>Provide modus tollens (<code><a href="../.././Init/Core.html#mt">mt</a></code>) as dot notation for implications.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-not">Declarations about <code><a href="../.././Init/Prelude.html#not">not</a></code> <a class="hover-link" href="#Declarations-about-not">#</a></h3></div><div class="decl" id="dec_em"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L154-L154">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dec_em"><span class="name">dec_em</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#Decidable.em">Decidable.em</a></code>.</p></div></div><div class="decl" id="dec_em'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L156-L156">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dec_em'"><span class="name">dec_em'</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="em"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L158-L158">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#em"><span class="name">em</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.em">Classical.em</a></code>.</p><hr></hr><p><strong>Diaconescu's theorem</strong>: excluded middle from choice, Function extensionality and propositional extensionality.</p></div></div><div class="decl" id="em'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L160-L160">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#em'"><span class="name">em'</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L162-L162">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_not"><span class="name">or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div></div></div><div class="decl" id="Decidable.eq_or_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L164-L165">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.eq_or_ne"><span class="name">Decidable</span>.<span class="name">eq_or_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="Decidable.ne_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L167-L168">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.ne_or_eq"><span class="name">Decidable</span>.<span class="name">ne_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="eq_or_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L170-L170">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_or_ne"><span class="name">eq_or_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="ne_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L172-L172">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_or_eq"><span class="name">ne_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="by_contradiction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L174-L174">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#by_contradiction"><span class="name">by_contradiction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <a href="../.././Init/Prelude.html#False">False</a>)</span> → <span class="fn">p</span></span></div></div></div></div><div class="decl" id="by_cases"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L176-L177">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#by_cases"><span class="name">by_cases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(hpq : <span class="fn"><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hnpq : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">q</span></div></div></div></div><div class="decl" id="by_contra"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L179-L179">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#by_contra"><span class="name">by_contra</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <a href="../.././Init/Prelude.html#False">False</a>)</span> → <span class="fn">p</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#by_contradiction">by_contradiction</a></code>.</p></div></div><div class="decl" id="of_not_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L206-L206">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#of_not_not"><span class="name">of_not_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_ne_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L208-L208">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_ne_iff"><span class="name">not_ne_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="of_not_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L210-L210">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#of_not_imp"><span class="name">of_not_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span></span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Not.decidable_imp_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L212-L212">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Not.decidable_imp_symm"><span class="name">Not</span>.<span class="name">decidable_imp_symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">a</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#Decidable.not_imp_symm">Decidable.not_imp_symm</a></code>.</p></div></div><div class="decl" id="Not.imp_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L214-L214">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Not.imp_symm"><span class="name">Not</span>.<span class="name">imp_symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn">b</span>)</span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> → <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="not_imp_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L216-L216">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp_comm"><span class="name">not_imp_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> → <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="not_imp_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L218-L218">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp_self"><span class="name">not_imp_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Imp.swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L220-L221">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Imp.swap"><span class="name">Imp</span>.<span class="name">swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> → <span class="fn">c</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> → <span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Iff.not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L223-L223">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.not"><span class="name">Iff</span>.<span class="name">not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#not_congr">not_congr</a></code>.</p></div></div><div class="decl" id="Iff.not_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L225-L225">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.not_left"><span class="name">Iff</span>.<span class="name">not_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Iff.not_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L227-L227">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.not_right"><span class="name">Iff</span>.<span class="name">not_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Iff.ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L229-L230">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.ne"><span class="name">Iff</span>.<span class="name">ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">d</span></span>)</span></span></div></div></div></div><div class="decl" id="Iff.ne_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L232-L233">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.ne_left"><span class="name">Iff</span>.<span class="name">ne_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">d</span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span>)</span></span></div></div></div></div><div class="decl" id="Iff.ne_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L235-L236">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.ne_right"><span class="name">Iff</span>.<span class="name">ne_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">d</span></span>)</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-Xor">Declarations about <code><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a></code> <a class="hover-link" href="#Declarations-about-Xor">#</a></h3></div><div class="decl" id="xor_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L240-L241">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_true"><span class="name">xor_true</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <a href="../.././Init/Prelude.html#True">True</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Not">Not</a></span></div></div></div></div><div class="decl" id="xor_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L243-L243">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_false"><span class="name">xor_false</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">id</span></span></div></div></div></div><div class="decl" id="xor_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L245-L245">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_comm"><span class="name">xor_comm</span></a></span><span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">b</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="instCommutativeXor'"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L247-L247">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instCommutativeXor'"><span class="name">instCommutativeXor'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Std.Commutative">Std.Commutative</a> <a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#instCommutativeXor'">instCommutativeXor'</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="xor_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L249-L249">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_self"><span class="name">xor_self</span></a></span><span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="xor_not_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L251-L251">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_not_left"><span class="name">xor_not_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="xor_not_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L253-L253">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_not_right"><span class="name">xor_not_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="xor_not_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L255-L255">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_not_not"><span class="name">xor_not_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</span> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Xor'.or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L257-L257">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Xor'.or"><span class="name">Xor'</span>.<span class="name">or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-and">Declarations about <code><a href="../.././Init/Prelude.html#and">and</a></code> <a class="hover-link" href="#Declarations-about-and">#</a></h3></div><div class="decl" id="Iff.and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L261-L261">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.and"><span class="name">Iff</span>.<span class="name">and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">d</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#and_congr">and_congr</a></code>.</p></div></div><div class="decl" id="And.rotate"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L262-L262">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#And.rotate"><span class="name">And</span>.<span class="name">rotate</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">c</span></span></span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../.././Init/PropLemmas.html#and_rotate">and_rotate</a></code>.</p></div></div><div class="decl" id="and_symm_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L264-L264">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_symm_right"><span class="name">and_symm_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="and_symm_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L265-L265">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_symm_left"><span class="name">and_symm_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">p</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">p</span></span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-or">Declarations about <code><a href="../.././Init/Prelude.html#or">or</a></code> <a class="hover-link" href="#Declarations-about-or">#</a></h3></div><div class="decl" id="Iff.or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L269-L269">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.or"><span class="name">Iff</span>.<span class="name">or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">d</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#or_congr">or_congr</a></code>.</p></div></div><div class="decl" id="Or.rotate"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L270-L270">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Or.rotate"><span class="name">Or</span>.<span class="name">rotate</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">a</span></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../.././Init/PropLemmas.html#or_rotate">or_rotate</a></code>.</p></div></div><div class="decl" id="Or.elim3"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L272-L273">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Or.elim3"><span class="name">Or</span>.<span class="name">elim3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ha : <span class="fn"><span class="fn">a</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn">b</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hc : <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">d</span></div></div></div></div><div class="decl" id="Or.imp3"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L275-L277">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Or.imp3"><span class="name">Or</span>.<span class="name">imp3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(had : <span class="fn"><span class="fn">a</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbe : <span class="fn"><span class="fn">b</span> → <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hcf : <span class="fn"><span class="fn">c</span> → <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span> → <span class="fn"><span class="fn">d</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">e</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">f</span></span></span></span></div></div></div></div><div class="decl" id="not_or_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L281-L281">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_or_of_imp"><span class="name">not_or_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Decidable.or_not_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L284-L285">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.or_not_of_imp"><span class="name">Decidable</span>.<span class="name">or_not_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">a</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="or_not_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L287-L287">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_not_of_imp"><span class="name">or_not_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="imp_iff_not_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L289-L289">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_iff_not_or"><span class="name">imp_iff_not_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="imp_iff_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L291-L291">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_iff_or_not"><span class="name">imp_iff_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="not_imp_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L293-L293">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp_not"><span class="name">not_imp_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="imp_and_neg_imp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L295-L295">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_and_neg_imp_iff"><span class="name">imp_and_neg_imp_iff</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">p</span> → <span class="fn">q</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn">q</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q</span></span></div></div></div></div><div class="decl" id="Function.mtr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L298-L298">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Function.mtr"><span class="name">Function</span>.<span class="name">mtr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span> → <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span></span></div></div><p>Provide the reverse of modus tollens (<code><a href="../.././Init/Core.html#mt">mt</a></code>) as dot notation for implications.</p></div></div><div class="decl" id="or_congr_left'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L300-L301">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_congr_left'"><span class="name">or_congr_left'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span> → <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="or_congr_right'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L303-L303">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_congr_right'"><span class="name">or_congr_right'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> → <span class="fn">(<span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-distributivity">Declarations about distributivity <a class="hover-link" href="#Declarations-about-distributivity">#</a></h3></div><div class="mod_doc"><p>Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Iff.iff">iff</a></code></p></div><div class="decl" id="Iff.iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L309-L309">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.iff"><span class="name">Iff</span>.<span class="name">iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p₁ : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p₂ : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q₁ : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q₂ : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">p₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">q₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">p₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q₁</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">p₂</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q₂</span>)</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/SimpLemmas.html#iff_congr">iff_congr</a></code>.</p></div></div><div class="decl" id="iff_mpr_iff_true_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L312-L312">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_mpr_iff_true_intro"><span class="name">iff_mpr_iff_true_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">P</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="imp_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L314-L314">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_or"><span class="name">imp_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">c</span>)</span></span></span></div></div></div></div><div class="decl" id="imp_or'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L316-L316">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_or'"><span class="name">imp_or'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">c</span>)</span></span></span></div></div></div></div><div class="decl" id="not_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L318-L318">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp"><span class="name">not_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="peirce"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L320-L320">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#peirce"><span class="name">peirce</span></a></span><span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn">a</span>)</span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_iff_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L322-L322">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_iff_not"><span class="name">not_iff_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="not_iff_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L324-L324">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_iff_comm"><span class="name">not_iff_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span>)</span></span></div></div></div></div><div class="decl" id="not_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L326-L326">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_iff"><span class="name">not_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="iff_not_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L328-L328">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_not_comm"><span class="name">iff_not_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span>)</span></span></div></div></div></div><div class="decl" id="iff_iff_and_or_not_and_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L330-L331">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_iff_and_or_not_and_not"><span class="name">iff_iff_and_or_not_and_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></span></span></div></div></div></div><div class="decl" id="iff_iff_not_or_and_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L333-L334">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_iff_not_or_and_or_not"><span class="name">iff_iff_not_or_and_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span></span></div></div></div></div><div class="decl" id="not_and_not_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L336-L336">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_and_not_right"><span class="name">not_and_not_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="De-Morgan-s-laws">De Morgan's laws <a class="hover-link" href="#De-Morgan-s-laws">#</a></h3></div><div class="decl" id="not_and_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L342-L342">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_and_or"><span class="name">not_and_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span></span></span></div></div><p>One of <strong>de Morgan's laws</strong>: the negation of a conjunction is logically equivalent to the
disjunction of the negations.</p></div></div><div class="decl" id="or_iff_not_and_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L344-L344">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_iff_not_and_not"><span class="name">or_iff_not_and_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span></span></div></div></div></div><div class="decl" id="and_iff_not_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L346-L346">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_iff_not_or_not"><span class="name">and_iff_not_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span></span></div></div></div></div><div class="decl" id="not_xor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L348-L349">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_xor"><span class="name">not_xor</span></a></span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">P</span> <span class="fn">Q</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span>)</span></span></div></div></div></div><div class="decl" id="xor_iff_not_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L351-L351">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_not_iff"><span class="name">xor_iff_not_iff</span></a></span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">P</span> <span class="fn">Q</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span>)</span></span></span></div></div></div></div><div class="decl" id="xor_iff_iff_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L353-L353">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_iff_not"><span class="name">xor_iff_iff_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span></div></div></div></div><div class="decl" id="xor_iff_not_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L355-L355">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_not_iff'"><span class="name">xor_iff_not_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Init/Logic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-equality">Declarations about equality <a class="hover-link" href="#Declarations-about-equality">#</a></h3></div><div class="decl" id="Membership.mem.ne_of_not_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L361-L361">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Membership.mem.ne_of_not_mem"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span></span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Batteries/Logic.html#ne_of_mem_of_not_mem">ne_of_mem_of_not_mem</a></code>.</p></div></div><div class="decl" id="Membership.mem.ne_of_not_mem'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L362-L362">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Membership.mem.ne_of_not_mem'"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span> → <span class="fn"><span class="fn">s</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">t</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Batteries/Logic.html#ne_of_mem_of_not_mem'">ne_of_mem_of_not_mem'</a></code>.</p></div></div><div class="decl" id="forall_cond_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L367-L369">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_cond_comm"><span class="name">forall_cond_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">a</span></span> → <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></span></div></div></div></div><div class="decl" id="forall_mem_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L371-L373">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_mem_comm"><span class="name">forall_mem_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></span></div></div></div></div><div class="decl" id="ball_cond_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L375-L375">source</a></div><div class="attributes">@[deprecated forall_cond_comm]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ball_cond_comm"><span class="name">ball_cond_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">a</span></span> → <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#forall_cond_comm">forall_cond_comm</a></code>.</p></div></div><div class="decl" id="ball_mem_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L376-L376">source</a></div><div class="attributes">@[deprecated forall_mem_comm]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ball_mem_comm"><span class="name">ball_mem_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#forall_mem_comm">forall_mem_comm</a></code>.</p></div></div><div class="decl" id="ne_of_eq_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L378-L378">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_of_eq_of_ne"><span class="name">ne_of_eq_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="ne_of_ne_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L379-L379">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_of_ne_of_eq"><span class="name">ne_of_ne_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Eq.trans_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L381-L381">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Eq.trans_ne"><span class="name">Eq</span>.<span class="name">trans_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#ne_of_eq_of_ne">ne_of_eq_of_ne</a></code>.</p></div></div><div class="decl" id="Ne.trans_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L382-L382">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.trans_eq"><span class="name">Ne</span>.<span class="name">trans_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#ne_of_ne_of_eq">ne_of_ne_of_eq</a></code>.</p></div></div><div class="decl" id="eq_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L384-L385">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_equivalence"><span class="name">eq_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">Eq</span></span></div></div></div></div><div class="decl" id="congr_refl_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L391-L392">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_refl_left"><span class="name">congr_refl_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="congr_refl_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L395-L396">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_refl_right"><span class="name">congr_refl_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="congr_arg_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L399-L401">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_arg_refl"><span class="name">congr_arg_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="congr_fun_rfl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L404-L405">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_fun_rfl"><span class="name">congr_fun_rfl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="congr_fun_congr_arg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L408-L409">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_fun_congr_arg"><span class="name">congr_fun_congr_arg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Eq.rec_eq_cast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L411-L412">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Eq.rec_eq_cast"><span class="name">Eq</span>.<span class="name">rec_eq_cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(z : <span class="fn"><span class="fn">P</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">h</span> ▸ <span class="fn">z</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">z</span></span></span></div></div></div></div><div class="decl" id="eqRec_heq'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L414-L417">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eqRec_heq'"><span class="name">eqRec_heq'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_2</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">motive</span> <span class="fn">a'</span> <span class="fn">⋯</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(t : <span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn">t</span> ▸ <span class="fn">p</span>)</span> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="rec_heq_of_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L419-L420">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#rec_heq_of_heq"><span class="name">rec_heq_of_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn">e</span> ▸ <span class="fn">x</span>)</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="rec_heq_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L422-L423">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#rec_heq_iff_heq"><span class="name">rec_heq_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">(<span class="fn">e</span> ▸ <span class="fn">x</span>)</span> <span class="fn">y</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="heq_rec_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L425-L426">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#heq_rec_iff_heq"><span class="name">heq_rec_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">(<span class="fn">e</span> ▸ <span class="fn">y</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#HEq">HEq</a> <span class="fn">x</span> <span class="fn">y</span></span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-quantifiers">Declarations about quantifiers <a class="hover-link" href="#Declarations-about-quantifiers">#</a></h3></div><div class="decl" id="pi_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L437-L438">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#pi_congr"><span class="name">pi_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β' : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">β'</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β'</span> <span class="fn">a</span></span>)</span></span></div></div></div></div><div class="decl" id="forall₂_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L443-L445">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_imp"><span class="name">forall₂_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span> → <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="forall₃_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L447-L449">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₃_imp"><span class="name">forall₃_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_3</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) → <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) → <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span> → <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Exists₂.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L451-L453">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists₂.imp"><span class="name">Exists₂</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></div></div></div></div><div class="decl" id="Exists₃.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L455-L457">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists₃.imp"><span class="name">Exists₃</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_3</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) → <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) → <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn">∃ (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span>)</span> → <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn">∃ (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span></span></div></div></div></div><div class="decl" id="forall_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L463-L464">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_swap"><span class="name">forall_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">y</span> : <span class="fn">β</span>) (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span></div></div></div></div><div class="decl" id="forall₂_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L466-L468">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_swap"><span class="name">forall₂_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₁ : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₂ : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₁ : <span class="fn"><span class="fn">ι₁</span> → <a href="../.././foundational_types.html">Sort</a> u_5</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₂ : <span class="fn"><span class="fn">ι₂</span> → <a href="../.././foundational_types.html">Sort</a> u_6</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn"><span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span> → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn"><span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">i₁</span> : <span class="fn">ι₁</span>) (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>) (<span class="fn">i₂</span> : <span class="fn">ι₂</span>) (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">i₂</span> : <span class="fn">ι₂</span>) (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>) (<span class="fn">i₁</span> : <span class="fn">ι₁</span>) (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></span></div></div></div></div><div class="decl" id="imp_forall_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L472-L473">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_forall_iff"><span class="name">imp_forall_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">p</span> → <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></span></div></div><p>We intentionally restrict the type of <code>α</code> in this lemma so that this is a safer to use in simp
than <code><a href="../.././Mathlib/Logic/Basic.html#forall_swap">forall_swap</a></code>.</p></div></div><div class="decl" id="exists_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L475-L476">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_swap"><span class="name">exists_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span></span></div></div></div></div><div class="decl" id="not_forall_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L480-L480">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_forall_not"><span class="name">not_forall_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="forall_or_exists_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L484-L485">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_exists_not"><span class="name">forall_or_exists_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_or_forall_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L487-L488">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_or_forall_not"><span class="name">exists_or_forall_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_imp_iff_exists_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L490-L494">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_imp_iff_exists_imp"><span class="name">forall_imp_iff_exists_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[ha : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="forall_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L497-L497">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_true_iff"><span class="name">forall_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">α</span> → <a href="../.././Init/Prelude.html#True">True</a></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="forall_true_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L501-L502">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_true_iff'"><span class="name">forall_true_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="forall₂_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L505-L505">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_true_iff"><span class="name">forall₂_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././Init/Prelude.html#True">True</a></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="forall₃_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L508-L509">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₃_true_iff"><span class="name">forall₃_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_4</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././Init/Prelude.html#True">True</a></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="exists_unique_iff_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L511-L513">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_unique_iff_exists"><span class="name">exists_unique_iff_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃! <span class="fn">x</span> : <span class="fn">α</span>, <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="exists_unique_const"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L517-L518">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_unique_const"><span class="name">exists_unique_const</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Sort</a> u_3)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[i : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃! <span class="fn">x</span> : <span class="fn">α</span>, <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Decidable.and_forall_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L520-L522">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.and_forall_ne"><span class="name">Decidable</span>.<span class="name">and_forall_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="and_forall_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L524-L525">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_forall_ne"><span class="name">and_forall_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Ne.ne_or_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L527-L528">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ne_or_ne"><span class="name">Ne</span>.<span class="name">ne_or_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(z : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">z</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">y</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">z</span></span></span></div></div></div></div><div class="decl" id="exists_unique_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L530-L531">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_unique_eq"><span class="name">exists_unique_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃! <span class="fn">a</span> : <span class="fn">α</span>, <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span></span></div></div></div></div><div class="decl" id="exists_unique_eq'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L533-L534">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_unique_eq'"><span class="name">exists_unique_eq'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃! <span class="fn">a</span> : <span class="fn">α</span>, <span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L537-L537">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply'"><span class="name">exists_apply_eq_apply'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a' : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply2"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L540-L541">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply2"><span class="name">exists_apply_eq_apply2</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply2'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L544-L545">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply2'"><span class="name">exists_apply_eq_apply2'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply3"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L548-L550">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply3"><span class="name">exists_apply_eq_apply3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Sort</a> u_6}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">γ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn">∃ (<span class="fn">z</span> : <span class="fn">γ</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">z</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply3'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L553-L555">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply3'"><span class="name">exists_apply_eq_apply3'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href="../.././foundational_types.html">Sort</a> u_6}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">γ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn">∃ (<span class="fn">z</span> : <span class="fn">γ</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">z</span></span></span></span></span></span></div></div></div></div><div class="decl" id="exists_apply_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L558-L558">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq"><span class="name">exists_apply_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="exists_exists_and_eq_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L560-L562">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_and_eq_and"><span class="name">exists_exists_and_eq_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">q</span> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">q</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_exists_eq_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L564-L566">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_eq_and"><span class="name">exists_exists_eq_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span></span></div></div></div></div><div class="decl" id="exists_exists_and_exists_and_eq_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L568-L572">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_and_exists_and_eq_and"><span class="name">exists_exists_and_exists_and_eq_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">c</span> : <span class="fn">γ</span>), <span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">c</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span>)</span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="exists_exists_exists_and_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L574-L578">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_exists_and_eq"><span class="name">exists_exists_exists_and_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">c</span> : <span class="fn">γ</span>), <span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">c</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span>)</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_apply_eq_imp_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L580-L581">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_apply_eq_imp_iff'"><span class="name">forall_apply_eq_imp_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span></span></div></div></div></div><div class="decl" id="forall_eq_apply_imp_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L583-L584">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_eq_apply_imp_iff'"><span class="name">forall_eq_apply_imp_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span></span></div></div></div></div><div class="decl" id="exists₂_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L586-L589">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists₂_comm"><span class="name">exists₂_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₁ : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι₂ : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₁ : <span class="fn"><span class="fn">ι₁</span> → <a href="../.././foundational_types.html">Sort</a> u_5</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ₂ : <span class="fn"><span class="fn">ι₂</span> → <a href="../.././foundational_types.html">Sort</a> u_6</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn"><span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span> → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn"><span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">i₁</span> : <span class="fn">ι₁</span>), <span class="fn">∃ (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>), <span class="fn">∃ (<span class="fn">i₂</span> : <span class="fn">ι₂</span>), <span class="fn">∃ (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn">∃ (<span class="fn">i₂</span> : <span class="fn">ι₂</span>), <span class="fn">∃ (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>), <span class="fn">∃ (<span class="fn">i₁</span> : <span class="fn">ι₁</span>), <span class="fn">∃ (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="And.exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L591-L592">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#And.exists"><span class="name">And</span>.<span class="name">exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span></span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span></span>), <span class="fn"><span class="fn">f</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">hp</span> : <span class="fn">p</span>), <span class="fn">∃ (<span class="fn">hq</span> : <span class="fn">q</span>), <span class="fn"><span class="fn">f</span> <span class="fn">⋯</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_or_of_or_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L594-L596">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_of_or_forall"><span class="name">forall_or_of_or_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Decidable.forall_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L599-L602">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.forall_or_left"><span class="name">Decidable</span>.<span class="name">forall_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L604-L605">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_left"><span class="name">forall_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="Decidable.forall_or_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L608-L609">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.forall_or_right"><span class="name">Decidable</span>.<span class="name">forall_or_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span></span></div></div></div></div><div class="decl" id="forall_or_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L611-L612">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_right"><span class="name">forall_or_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span></span></div></div></div></div><div class="decl" id="exists_unique_prop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L614-L614">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_unique_prop"><span class="name">exists_unique_prop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃! <span class="fn">x</span> : <span class="fn">p</span>, <span class="fn">q</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span></span></span></div></div></div></div><div class="decl" id="exists_unique_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L616-L616">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_unique_false"><span class="name">exists_unique_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∃! <span class="fn">x</span> : <span class="fn">α</span>, <a href="../.././Init/Prelude.html#False">False</a></span></span></div></div></div></div><div class="decl" id="Exists.fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L618-L619">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists.fst"><span class="name">Exists</span>.<span class="name">fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">b</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Exists">Exists</a> <span class="fn">p</span></span> → <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Exists.snd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L621-L622">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists.snd"><span class="name">Exists</span>.<span class="name">snd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">b</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Core.html#Exists">Exists</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Prop.exists_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L624-L626">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Prop.exists_iff"><span class="name">Prop</span>.<span class="name">exists_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">h</span> : <a href="../.././foundational_types.html">Prop</a>), <span class="fn"><span class="fn">p</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span></span></span></div></div></div></div><div class="decl" id="Prop.forall_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L628-L629">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Prop.forall_iff"><span class="name">Prop</span>.<span class="name">forall_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">h</span> : <a href="../.././foundational_types.html">Prop</a>), <span class="fn"><span class="fn">p</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span></span></span></div></div></div></div><div class="decl" id="exists_iff_of_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L631-L632">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_iff_of_forall"><span class="name">exists_iff_of_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="exists_unique_prop_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L634-L635">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_unique_prop_of_true"><span class="name">exists_unique_prop_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">p</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃! <span class="fn">h'</span> : <span class="fn">p</span>, <span class="fn"><span class="fn">q</span> <span class="fn">h'</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="exists_prop_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L637-L638">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_prop_of_false"><span class="name">exists_prop_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∃ (<span class="fn">h'</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h'</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_prop_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L644-L646">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_prop_congr"><span class="name">forall_prop_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p' : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q' : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hq : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q'</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hp : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p'</span>), <span class="fn"><span class="fn">q'</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="forall_prop_congr'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L650-L652">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_prop_congr'"><span class="name">forall_prop_congr'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p' : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q' : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hq : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q'</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hp : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p'</span>), <span class="fn"><span class="fn">q'</span> <span class="fn">⋯</span></span></span></span></div></div></div></div><div class="decl" id="imp_congr_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L654-L655">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_congr_eq"><span class="name">imp_congr_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">c</span> → <span class="fn">d</span>)</span></span></div></div></div></div><div class="decl" id="imp_congr_ctx_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L657-L658">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_congr_ctx_eq"><span class="name">imp_congr_ctx_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">c</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">c</span> → <span class="fn">d</span>)</span></span></div></div></div></div><div class="decl" id="eq_true_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L660-L660">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_true_intro"><span class="name">eq_true_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="eq_false_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L662-L662">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_false_intro"><span class="name">eq_false_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="Iff.eq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L665-L665">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.eq"><span class="name">Iff</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#propext">propext</a></code>.</p><hr></hr><p>The axiom of <strong>propositional extensionality</strong>. It asserts that if propositions
<code>a</code> and <code>b</code> are logically equivalent (i.e. we can prove <code>a</code> from <code>b</code> and vice versa),
then <code>a</code> and <code>b</code> are <em>equal</em>, meaning that we can replace <code>a</code> with <code>b</code> in all
contexts.</p><p>For simple expressions like <code>a ∧ c ∨ d → e</code> we can prove that because all the logical
connectives respect logical equivalence, we can replace <code>a</code> with <code>b</code> in this expression
without using <code><a href="../.././Init/Core.html#propext">propext</a></code>. However, for higher order expressions like <code>P a</code> where
<code>P : Prop → Prop</code> is unknown, or indeed for <code>a = b</code> itself, we cannot replace <code>a</code> with <code>b</code>
without an axiom which says exactly this.</p><p>This is a relatively uncontroversial axiom, which is intuitionistically valid.
It does however block computation when using <code>#reduce</code> to reduce proofs directly
(which is not recommended), meaning that canonicity,
the property that all closed terms of type <code><a href="../.././Init/Prelude.html#Nat">Nat</a></code> normalize to numerals,
fails to hold when this (or any) axiom is used:</p><pre><code>set_option pp.proofs true

def foo : <a href="../.././Init/Prelude.html#Nat">Nat</a> := by
  have : (True → True) ↔ <a href="../.././Init/Prelude.html#True">True</a> := ⟨λ _ =&gt; trivial, λ _ _ =&gt; trivial⟩
  have := <a href="../.././Init/Core.html#propext">propext</a> this ▸ (2 : Nat)
  exact this

#reduce foo
-- <a href="../.././Init/Core.html#propext">propext</a> { mp := fun x x =&gt; True.intro, mpr := fun x =&gt; <a href="../.././Init/Prelude.html#True.intro">True.intro</a> } ▸ 2

#eval foo -- 2
</code></pre><p><code>#eval</code> can evaluate it to a numeral because the compiler erases casts and
does not evaluate proofs, so <code><a href="../.././Init/Core.html#propext">propext</a></code>, whose return type is a proposition,
can never block it.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Iff.eq">@<a href="../.././Mathlib/Logic/Basic.html#Iff.eq">Iff.eq</a></a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Core.html#propext">@<a href="../.././Init/Core.html#propext">propext</a></a></span></li></ul></details><details id="instances-for-list-Iff.eq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="iff_eq_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L667-L667">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_eq_eq"><span class="name">iff_eq_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="forall_true_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L672-L673">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_true_left"><span class="name">forall_true_left</span></a></span><span class="decl_args">
<span class="fn">(p : <span class="fn"><a href="../.././Init/Prelude.html#True">True</a> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#True">True</a>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True.intro">True.intro</a></span></span></div></div><p>See <code>IsEmpty.<a href="../.././Mathlib/Logic/Basic.html#Prop.forall_iff">forall_iff</a></code> for the <code><a href="../.././Init/Prelude.html#False">False</a></code> version.</p></div></div><div class="decl" id="ExistsUnique.elim₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L675-L680">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ExistsUnique.elim₂"><span class="name">ExistsUnique</span>.<span class="name">elim₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_4</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">p</span> <span class="fn">x</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₂ : <span class="fn">∃! <span class="fn">x</span> : <span class="fn">α</span>, <span class="fn">∃! <span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">(∀ (<span class="fn">y</span> : <span class="fn">α</span>) (<span class="fn">hy</span> : <span class="fn"><span class="fn">p</span> <span class="fn">y</span></span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">y</span> <span class="fn">hy</span></span> → <span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></span>)</span> → <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span></div></div></div></div><div class="decl" id="ExistsUnique.intro₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L682-L686">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ExistsUnique.intro₂"><span class="name">ExistsUnique</span>.<span class="name">intro₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_4</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">p</span> <span class="fn">x</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(w : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(hp : <span class="fn"><span class="fn">p</span> <span class="fn">w</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hq : <span class="fn"><span class="fn">q</span> <span class="fn">w</span> <span class="fn">hp</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">y</span> : <span class="fn">α</span>) (<span class="fn">hy</span> : <span class="fn"><span class="fn">p</span> <span class="fn">y</span></span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">y</span> <span class="fn">hy</span></span> → <span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">w</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃! <span class="fn">x</span> : <span class="fn">α</span>, <span class="fn">∃! <span class="fn">hx</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">q</span> <span class="fn">x</span> <span class="fn">hx</span></span></span></span></div></div></div></div><div class="decl" id="ExistsUnique.exists₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L688-L690">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ExistsUnique.exists₂"><span class="name">ExistsUnique</span>.<span class="name">exists₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_4</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∃! <span class="fn">x</span> : <span class="fn">α</span>, <span class="fn">∃! <span class="fn">hx</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">q</span> <span class="fn">x</span> <span class="fn">hx</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">hx</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span> <span class="fn">hx</span></span></span></span></div></div></div></div><div class="decl" id="ExistsUnique.unique₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L692-L696">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ExistsUnique.unique₂"><span class="name">ExistsUnique</span>.<span class="name">unique₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_4</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn">p</span> <span class="fn">x</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∃! <span class="fn">x</span> : <span class="fn">α</span>, <span class="fn">∃! <span class="fn">hx</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">q</span> <span class="fn">x</span> <span class="fn">hx</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{y₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y₂ : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hpy₁ : <span class="fn"><span class="fn">p</span> <span class="fn">y₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hqy₁ : <span class="fn"><span class="fn">q</span> <span class="fn">y₁</span> <span class="fn">hpy₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hpy₂ : <span class="fn"><span class="fn">p</span> <span class="fn">y₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hqy₂ : <span class="fn"><span class="fn">q</span> <span class="fn">y₂</span> <span class="fn">hpy₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">y₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y₂</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Classical-lemmas">Classical lemmas <a class="hover-link" href="#Classical-lemmas">#</a></h3></div><div class="decl" id="Classical.dec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L706-L706">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.dec"><span class="name">Classical</span>.<span class="name">dec</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span></div></div><p>Any prop <code>p</code> is decidable classically. A shorthand for <code><a href="../.././Init/Classical.html#Classical.propDecidable">Classical.propDecidable</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.dec">Classical.dec</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inferInstance</span></span></li></ul></details><details id="instances-for-list-Classical.dec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.decPred"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L711-L711">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.decPred"><span class="name">Classical</span>.<span class="name">decPred</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span></div></div><p>Any predicate <code>p</code> is decidable classically.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.decPred">Classical.decPred</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inferInstance</span></span></li></ul></details><details id="instances-for-list-Classical.decPred" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.decRel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L714-L714">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.decRel"><span class="name">Classical</span>.<span class="name">decRel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">p</span></span></div></div><p>Any relation <code>p</code> is decidable classically.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.decRel">Classical.decRel</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inferInstance</span></span></li></ul></details><details id="instances-for-list-Classical.decRel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L717-L717">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.decEq"><span class="name">Classical</span>.<span class="name">decEq</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Sort</a> u_2)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span></div></div><p>Any type <code>α</code> has decidable equality classically.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.decEq">Classical.decEq</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inferInstance</span></span></li></ul></details><details id="instances-for-list-Classical.decEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.existsCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L722-L723">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.existsCases"><span class="name">Classical</span>.<span class="name">existsCases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H0 : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn">C</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>Construct a function from a default value <code>H0</code>, and a function to use if there exists a value
satisfying the predicate.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.existsCases">Classical.existsCases</a> <span class="fn">H0</span> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span> then <span class="fn"><span class="fn">H</span> <span class="fn">(<a href="../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">h</span>)</span> <span class="fn">⋯</span></span> else <span class="fn">H0</span></span></span></li></ul></details><details id="instances-for-list-Classical.existsCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.some_spec₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L725-L726">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.some_spec₂"><span class="name">Classical</span>.<span class="name">some_spec₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(hpq : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">q</span> <span class="fn">(<a href="../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Classical.subtype_of_exists"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L733-L734">source</a></div><div class="attributes">@[deprecated Classical.indefiniteDescription]</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.subtype_of_exists"><span class="name">Classical</span>.<span class="name">subtype_of_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">{ <span class="fn">x</span> : <span class="fn">α</span> // <span class="fn"><span class="fn">P</span> <span class="fn">x</span></span> }</span></div></div><p>A version of <code><a href="../.././Init/Classical.html#Classical.indefiniteDescription">Classical.indefiniteDescription</a></code> which is definitionally equal to a pair.</p><p>In Lean 4, this definition is defeq to <code><a href="../.././Init/Classical.html#Classical.indefiniteDescription">Classical.indefiniteDescription</a></code>,
so it is deprecated.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.subtype_of_exists">Classical.subtype_of_exists</a> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⟨<span class="fn"><a href="../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">h</span></span>, <span class="fn">⋯</span>⟩</span></span></li></ul></details><details id="instances-for-list-Classical.subtype_of_exists" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.byContradiction'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L737-L738">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.byContradiction'"><span class="name">Classical</span>.<span class="name">byContradiction'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">α</span> → <a href="../.././Init/Prelude.html#False">False</a>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>A version of <code>byContradiction</code> that uses types instead of propositions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.byContradiction'">Classical.byContradiction'</a> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Classical.choice">Classical.choice</a> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Classical.byContradiction'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.choice_of_byContradiction'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L741-L742">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.choice_of_byContradiction'"><span class="name">Classical</span>.<span class="name">choice_of_byContradiction'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(contra : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">α</span> → <a href="../.././Init/Prelude.html#False">False</a>)</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span> → <span class="fn">α</span></span></div></div><p><code><a href="../.././Mathlib/Logic/Basic.html#Classical.byContradiction'">Classical.byContradiction'</a></code> is equivalent to lean's axiom <code><a href="../.././Init/Prelude.html#Classical.choice">Classical.choice</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.choice_of_byContradiction'">Classical.choice_of_byContradiction'</a> <span class="fn">contra</span> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">contra</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Classical.choice_of_byContradiction'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.choose_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L744-L744">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.choose_eq"><span class="name">Classical</span>.<span class="name">choose_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">⋯</span>.choose</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Classical.choose_eq'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L747-L748">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.choose_eq'"><span class="name">Classical</span>.<span class="name">choose_eq'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">⋯</span>.choose</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Classical.axiom_of_choice"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L750-L750">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.axiom_of_choice"><span class="name">Classical</span>.<span class="name">axiom_of_choice</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">y</span> : <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">f</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span></span>), <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.axiomOfChoice">Classical.axiomOfChoice</a></code>.</p><hr></hr><p>the axiom of choice</p></div></div><div class="decl" id="Classical.by_cases"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L751-L751">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.by_cases"><span class="name">Classical</span>.<span class="name">by_cases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(hpq : <span class="fn"><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hnpq : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">q</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.byCases">Classical.byCases</a></code>.</p></div></div><div class="decl" id="Classical.by_contradiction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L752-L752">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.by_contradiction"><span class="name">Classical</span>.<span class="name">by_contradiction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.byContradiction">Classical.byContradiction</a></code>.</p></div></div><div class="decl" id="Classical.prop_complete"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L758-L758">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.prop_complete"><span class="name">Classical</span>.<span class="name">prop_complete</span></a></span><span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#True">True</a></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#False">False</a></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.propComplete">Classical.propComplete</a></code>.</p></div></div><div class="decl" id="Classical.cases_true_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L760-L762">source</a></div><div class="attributes">@[deprecated]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.cases_true_false"><span class="name">Classical</span>.<span class="name">cases_true_false</span></a></span><span class="decl_args">
<span class="fn">(p : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(h1 : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(h2 : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Classical.eq_false_or_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L765-L765">source</a></div><div class="attributes">@[deprecated]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.eq_false_or_eq_true"><span class="name">Classical</span>.<span class="name">eq_false_or_eq_true</span></a></span><span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#True">True</a></span></span></div></div></div></div><div class="decl" id="Classical.cases_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L769-L770">source</a></div><div class="attributes">@[deprecated]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.cases_on"><span class="name">Classical</span>.<span class="name">cases_on</span></a></span><span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h1 : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(h2 : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Classical.cases"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L774-L774">source</a></div><div class="attributes">@[deprecated]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.cases"><span class="name">Classical</span>.<span class="name">cases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h1 : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(h2 : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Exists.classicalRecOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L782-L784">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists.classicalRecOn"><span class="name">Exists</span>.<span class="name">classicalRecOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn">C</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>This function has the same type as <code><a href="../.././Init/Core.html#Exists.recOn">Exists.recOn</a></code>, and can be used to case on an equality,
but <code><a href="../.././Init/Core.html#Exists.recOn">Exists.recOn</a></code> can only eliminate into Prop, while this version eliminates into any universe
using the axiom of choice.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">h</span>.classicalRecOn</span> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">H</span> <span class="fn">(<a href="../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">h</span>)</span> <span class="fn">⋯</span></span></span></li></ul></details><details id="instances-for-list-Exists.classicalRecOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-bounded-quantifiers">Declarations about bounded quantifiers <a class="hover-link" href="#Declarations-about-bounded-quantifiers">#</a></h3></div><div class="decl" id="bex_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L791-L792">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_def"><span class="name">bex_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="BEx.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L794-L795">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.elim"><span class="name">BEx</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> → <span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">h</span></span> → <span class="fn">b</span></span>)</span> → <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="BEx.intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L797-L798">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.intro"><span class="name">BEx</span>.<span class="name">intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">h₁</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></div></div></div></div><div class="decl" id="bex_eq_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L801-L802">source</a></div><div class="attributes">@[deprecated exists_eq_left]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_eq_left"><span class="name">bex_eq_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="ball_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L804-L804">source</a></div><div class="attributes">@[deprecated forall₂_congr]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ball_congr"><span class="name">ball_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#forall₂_congr">forall₂_congr</a></code>.</p></div></div><div class="decl" id="bex_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L805-L805">source</a></div><div class="attributes">@[deprecated exists₂_congr]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_congr"><span class="name">bex_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#exists₂_congr">exists₂_congr</a></code>.</p></div></div><div class="decl" id="BAll.imp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L807-L808">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BAll.imp_right"><span class="name">BAll</span>.<span class="name">imp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="BEx.imp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L810-L811">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.imp_right"><span class="name">BEx</span>.<span class="name">imp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="BAll.imp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L813-L814">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BAll.imp_left"><span class="name">BAll</span>.<span class="name">imp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="BEx.imp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L816-L817">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.imp_left"><span class="name">BEx</span>.<span class="name">imp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="ball_of_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L820-L820">source</a></div><div class="attributes">@[deprecated id]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ball_of_forall"><span class="name">ball_of_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="forall_of_ball"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L823-L823">source</a></div><div class="attributes">@[deprecated forall_imp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_of_ball"><span class="name">forall_of_ball</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="exists_mem_of_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L825-L826">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_mem_of_exists"><span class="name">exists_mem_of_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="exists_of_exists_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L828-L829">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_of_exists_mem"><span class="name">exists_of_exists_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="exists₂_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L831-L831">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists₂_imp"><span class="name">exists₂_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="bex_of_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L833-L833">source</a></div><div class="attributes">@[deprecated exists_mem_of_exists]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_of_exists"><span class="name">bex_of_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(H : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#exists_mem_of_exists">exists_mem_of_exists</a></code>.</p></div></div><div class="decl" id="exists_of_bex"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L834-L834">source</a></div><div class="attributes">@[deprecated exists_of_exists_mem]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_of_bex"><span class="name">exists_of_bex</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span>)</span> → <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#exists_of_exists_mem">exists_of_exists_mem</a></code>.</p></div></div><div class="decl" id="bex_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L835-L835">source</a></div><div class="attributes">@[deprecated exists₂_imp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_imp"><span class="name">bex_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn">b</span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#exists₂_imp">exists₂_imp</a></code>.</p></div></div><div class="decl" id="not_exists_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L837-L837">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_exists_mem"><span class="name">not_exists_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="not_forall₂_of_exists₂_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L839-L840">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_forall₂_of_exists₂_not"><span class="name">not_forall₂_of_exists₂_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="Decidable.not_forall₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L843-L846">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.not_forall₂"><span class="name">Decidable</span>.<span class="name">not_forall₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>) → <span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span>)</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></span></div></div></div></div><div class="decl" id="not_forall₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L848-L848">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_forall₂"><span class="name">not_forall₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></span></div></div></div></div><div class="decl" id="forall₂_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L850-L851">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_and"><span class="name">forall₂_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_and_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L853-L854">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_and_left"><span class="name">forall_and_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_and_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L856-L857">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_and_right"><span class="name">forall_and_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span></span></span></div></div></div></div><div class="decl" id="exists_mem_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L859-L860">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_mem_or"><span class="name">exists_mem_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></span></span></div></div></div></div><div class="decl" id="forall₂_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L862-L863">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_or_left"><span class="name">forall₂_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span></span></span></div></div></div></div><div class="decl" id="exists_mem_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L865-L868">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_mem_or_left"><span class="name">exists_mem_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ (<span class="fn">x_1</span> : <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span></span></span></div></div></div></div><div class="decl" id="dite_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L877-L878">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_eq_iff"><span class="name">dite_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∃ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn"><span class="fn">B</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="ite_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L880-L881">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_eq_iff"><span class="name">ite_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="eq_ite_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L883-L884">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_ite_iff"><span class="name">eq_ite_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">P</span> then <span class="fn">b</span> else <span class="fn">c</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="dite_eq_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L886-L888">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_eq_iff'"><span class="name">dite_eq_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn"><span class="fn">B</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="ite_eq_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L890-L890">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_eq_iff'"><span class="name">ite_eq_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">P</span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span></span></div></div></div></div><div class="decl" id="dite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L892-L894">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_ne_left_iff"><span class="name">dite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">a</span>)</span> <span class="fn">B</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="dite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L896-L897">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_ne_right_iff"><span class="name">dite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>) =&gt; <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="ite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L899-L900">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_ne_left_iff"><span class="name">ite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="ite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L902-L903">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_ne_right_iff"><span class="name">ite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Ne.dite_eq_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L905-L906">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_eq_left_iff"><span class="name">Ne</span>.<span class="name">dite_eq_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">a</span>)</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></span></div></div></div></div><div class="decl" id="Ne.dite_eq_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L908-L909">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_eq_right_iff"><span class="name">Ne</span>.<span class="name">dite_eq_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>) =&gt; <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span></span></div></div></div></div><div class="decl" id="Ne.ite_eq_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L911-L912">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_eq_left_iff"><span class="name">Ne</span>.<span class="name">ite_eq_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></span></div></div></div></div><div class="decl" id="Ne.ite_eq_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L914-L915">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_eq_right_iff"><span class="name">Ne</span>.<span class="name">ite_eq_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span></span></div></div></div></div><div class="decl" id="Ne.dite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L917-L918">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_ne_left_iff"><span class="name">Ne</span>.<span class="name">dite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">a</span>)</span> <span class="fn">B</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span></span></div></div></div></div><div class="decl" id="Ne.dite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L920-L921">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_ne_right_iff"><span class="name">Ne</span>.<span class="name">dite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>) =&gt; <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></span></div></div></div></div><div class="decl" id="Ne.ite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L923-L924">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_ne_left_iff"><span class="name">Ne</span>.<span class="name">ite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span></span></div></div></div></div><div class="decl" id="Ne.ite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L926-L927">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_ne_right_iff"><span class="name">Ne</span>.<span class="name">ite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></span></div></div></div></div><div class="decl" id="dite_eq_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L931-L932">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_eq_or_eq"><span class="name">dite_eq_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∃ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">A</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="ite_eq_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L934-L935">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_eq_or_eq"><span class="name">ite_eq_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="apply_dite₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L939-L942">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#apply_dite₂"><span class="name">apply_dite₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><span class="fn">P</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(d : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">a</span> <span class="fn">b</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">c</span> <span class="fn">d</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">a</span> <span class="fn">h</span>)</span> <span class="fn">(<span class="fn">c</span> <span class="fn">h</span>)</span></span> else <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">b</span> <span class="fn">h</span>)</span> <span class="fn">(<span class="fn">d</span> <span class="fn">h</span>)</span></span></span></span></div></div><p>A two-argument function applied to two <code><a href="../.././Init/Prelude.html#dite">dite</a></code>s is a <code><a href="../.././Init/Prelude.html#dite">dite</a></code> of that two-argument function
applied to each of the branches.</p></div></div><div class="decl" id="apply_ite₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L946-L948">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#apply_ite₂"><span class="name">apply_ite₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(d : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <span class="fn">(if <span class="fn">P</span> then <span class="fn">c</span> else <span class="fn">d</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">c</span></span> else <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn">d</span></span></span></span></div></div><p>A two-argument function applied to two <code><a href="../.././Init/Prelude.html#ite">ite</a></code>s is a <code><a href="../.././Init/Prelude.html#ite">ite</a></code> of that two-argument function
applied to each of the branches.</p></div></div><div class="decl" id="dite_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L952-L953">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_apply"><span class="name">dite_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">P</span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">h</span> <span class="fn">a</span></span> else <span class="fn"><span class="fn">g</span> <span class="fn">h</span> <span class="fn">a</span></span></span></span></div></div><p>A 'dite' producing a <code>Pi</code> type <code>Π a, σ a</code>, applied to a value <code>a : α</code> is a <code><a href="../.././Init/Prelude.html#dite">dite</a></code> that applies
either branch to <code>a</code>.</p></div></div><div class="decl" id="ite_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L957-L958">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_apply"><span class="name">ite_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">f</span> else <span class="fn">g</span>)</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> else <span class="fn"><span class="fn">g</span> <span class="fn">a</span></span></span></span></div></div><p>A 'ite' producing a <code>Pi</code> type <code>Π a, σ a</code>, applied to a value <code>a : α</code> is a <code><a href="../.././Init/Prelude.html#ite">ite</a></code> that applies
either branch to <code>a</code>.</p></div></div><div class="decl" id="ite_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L963-L964">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_and"><span class="name">ite_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if <span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">Q</span></span> then <span class="fn">a</span> else <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">P</span> then <span class="fn">if <span class="fn">Q</span> then <span class="fn">a</span> else <span class="fn">b</span></span> else <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="dite_dite_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L966-L971">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_dite_comm"><span class="name">dite_dite_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><span class="fn">Q</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span></span> → <span class="fn">α</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">P</span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if p : <span class="fn">P</span> then <span class="fn"><span class="fn">A</span> <span class="fn">p</span></span> else <span class="fn">if q : <span class="fn">Q</span> then <span class="fn"><span class="fn">B</span> <span class="fn">q</span></span> else <span class="fn"><span class="fn">C</span> <span class="fn">p</span> <span class="fn">q</span></span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if q : <span class="fn">Q</span> then <span class="fn"><span class="fn">B</span> <span class="fn">q</span></span> else <span class="fn">if p : <span class="fn">P</span> then <span class="fn"><span class="fn">A</span> <span class="fn">p</span></span> else <span class="fn"><span class="fn">C</span> <span class="fn">p</span> <span class="fn">q</span></span></span></span></span></div></div></div></div><div class="decl" id="ite_ite_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L973-L976">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_ite_comm"><span class="name">ite_ite_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(Q : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">P</span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">if <span class="fn">Q</span> then <span class="fn">b</span> else <span class="fn">c</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">Q</span> then <span class="fn">b</span> else <span class="fn">if <span class="fn">P</span> then <span class="fn">a</span> else <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="ite_prop_iff_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L982-L983">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_prop_iff_or"><span class="name">ite_prop_iff_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">Q</span> else <span class="fn">R</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">Q</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">R</span></span></span></span></div></div></div></div><div class="decl" id="dite_prop_iff_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L985-L987">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_prop_iff_or"><span class="name">dite_prop_iff_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn"><span class="fn">P</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">Q</span> <span class="fn">R</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∃ (<span class="fn">p</span> : <span class="fn">P</span>), <span class="fn"><span class="fn">Q</span> <span class="fn">p</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∃ (<span class="fn">p</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn">R</span> <span class="fn">p</span></span></span></span></span></div></div></div></div><div class="decl" id="ite_prop_iff_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L990-L991">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_prop_iff_and"><span class="name">ite_prop_iff_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(if <span class="fn">P</span> then <span class="fn">Q</span> else <span class="fn">R</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(<span class="fn">P</span> → <span class="fn">Q</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <span class="fn">R</span>)</span></span></span></div></div></div></div><div class="decl" id="dite_prop_iff_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L993-L995">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_prop_iff_and"><span class="name">dite_prop_iff_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Q : <span class="fn"><span class="fn">P</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">Q</span> <span class="fn">R</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn">Q</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></span>), <span class="fn"><span class="fn">R</span> <span class="fn">h</span></span></span></span></span></div></div></div></div><div class="decl" id="not_beq_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L999-L1000">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_beq_of_ne"><span class="name">not_beq_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(ne : <span class="fn"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="beq_eq_decide"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L1002-L1004">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_eq_decide"><span class="name">beq_eq_decide</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span></span></div></div></div></div><div class="decl" id="beq_eq_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L1006-L1007">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_eq_beq"><span class="name">beq_eq_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">a₁</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a₂</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">b₁</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b₂</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span></span>)</span></span></div></div></div></div><div class="decl" id="beq_ext_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L1009-L1009">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_ext_iff"><span class="name">beq_ext_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{inst1 : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{inst2 : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">inst1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst2</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">(<span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span>)</span></span></span></span></div></div></div></div><div class="decl" id="beq_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L1010-L1017">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_ext"><span class="name">beq_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(inst1 : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(inst2 : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">(<span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">inst1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst2</span></span></div></div></div></div><div class="decl" id="lawful_beq_subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Logic/Basic.lean#L1019-L1024">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#lawful_beq_subsingleton"><span class="name">lawful_beq_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(inst1 : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(inst2 : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">inst1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst2</span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>