<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.ProxyType</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.ProxyType";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ProxyType</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/ProxyType.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Lean.html">Lean</a></li><li><a href="../.././Mathlib/Tactic/Core.html">Mathlib.Tactic.Core</a></li><li><a href="../.././Mathlib/Logic/Equiv/Defs.html">Mathlib.Logic.Equiv.Defs</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.ProxyType" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.ProxyType.ProxyEquivConfig"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">ProxyEquivConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.ProxyType.defaultMkCtorProxyType"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">defaultMkCtorProxyType</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.ProxyType.defaultMkProxyType"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">defaultMkProxyType</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.ProxyType.defaultMkProxyType.mkCType"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">defaultMkProxyType</span>.<span class="name">mkCType</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.ProxyType.defaultMkProxyType.wrapSumAccess"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">defaultMkProxyType</span>.<span class="name">wrapSumAccess</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.ProxyType.ProxyEquivConfig.default"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">ProxyEquivConfig</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.ProxyType.ensureProxyEquiv"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">ensureProxyEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.ProxyType.elabProxyEquiv"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">elabProxyEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.ProxyType.proxy_equiv"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">proxy_equiv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.ProxyType.elab_proxy_equiv"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">elab_proxy_equiv</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Generating-proxy-types">Generating &quot;proxy types&quot; <a class="hover-link" href="#Generating-proxy-types">#</a></h1><p>This module gives tools to create an equivalence between a given inductive type and a
&quot;proxy type&quot; constructed from <code><a href="../.././Init/Prelude.html#Unit">Unit</a></code>, <code><a href="../.././Init/Prelude.html#PLift">PLift</a></code>, <code><a href="../.././Init/Core.html#Sigma">Sigma</a></code>, <code><a href="../.././Init/Prelude.html#Empty">Empty</a></code>, and <code><a href="../.././Init/Core.html#Sum">Sum</a></code>.
It works for any non-recursive inductive type without indices.</p><p>The intended use case is for pulling typeclass instances across this equivalence. This
reduces the problem of generating typeclass instances to that of writing typeclass instances for
the above five types (and whichever additional types appear in the inductive type).</p><p>The main interface is the <code>proxy_equiv%</code> elaborator, where <code>proxy_equiv% t</code> gives an equivalence
between the proxy type for <code>t</code> and <code>t</code>. See the documentation for <code>proxy_equiv%</code> for an example.</p><p>For debugging information, do <code>set_option Elab.ProxyType true</code>.</p><p>It is possible to reconfigure the machinery to generate other types. See <code><a href="../.././Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ensureProxyEquiv">ensureProxyEquiv</a></code>
and look at how it is used in <code>proxy_equiv%</code>.</p><h2 class="markdown-heading" id="Implementation-notes">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>For inductive types with <code>n</code> constructors, the <code>proxy_equiv%</code> elaborator creates a proxy
type of the form <code>C₁ ⊕ (C₂ ⊕ (⋯ ⊕ Cₙ))</code>. The equivalence then needs to handle <code>n - 1</code> levels
of <code><a href="../.././Init/Core.html#Sum">Sum</a></code> constructors, which is a source of quadratic complexity.</p><p>An alternative design could be to generate a <code>C : <a href="../.././Init/Prelude.html#Fin">Fin</a> n → Type*</code> function for the proxy types
for each constructor and then use <code>(i : <a href="../.././Init/Prelude.html#Fin">Fin</a> n) × <a href="../.././Init/Prelude.html#ULift">ULift</a> (C i)</code> for the total proxy type. However,
typeclass inference is not good at finding instances for such a type even if there are instances
for each <code>C i</code>. One seems to need to add, for example, an explicit <code>[∀ i, Fintype (C i)]</code>
instance given <code>∀ i, Fintype (C i)</code>.</p></div><div class="decl" id="Mathlib.ProxyType.ProxyEquivConfig"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/ProxyType.lean#L50-L63">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">ProxyEquivConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Configuration used by <code>mkProxyEquiv</code>.</p><ul class="structure_fields" id="Mathlib.ProxyType.ProxyEquivConfig.mk"><li id="Mathlib.ProxyType.ProxyEquivConfig.proxyName" class="structure_field"><div class="structure_field_info">proxyName : <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a></div><div class="structure_field_doc"><p>Name to use for the declaration for a type that is <code><a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">Equiv</a></code> to the given type.</p></div></li><li id="Mathlib.ProxyType.ProxyEquivConfig.proxyEquivName" class="structure_field"><div class="structure_field_info">proxyEquivName : <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a></div><div class="structure_field_doc"><p>Name to use for the declaration for the equivalence <code>proxyType ≃ type</code>.</p></div></li><li id="Mathlib.ProxyType.ProxyEquivConfig.mkCtorProxyType" class="structure_field"><div class="structure_field_info">mkCtorProxyType : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span> → <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a>)</span></span></span></div><div class="structure_field_doc"><p>Returns a proxy type for a constructor and a pattern to use to match against it,
given a list of fvars for the constructor arguments and pattern names to use for the arguments.
The proxy type is expected to be a <code>Type*</code>.</p></div></li><li id="Mathlib.ProxyType.ProxyEquivConfig.mkProxyType" class="structure_field"><div class="structure_field_info">mkProxyType : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a></span>)</span></span> → <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`tactic</span></span></span>)</span></span></span></div><div class="structure_field_doc"><p>Given (constructor name, proxy constructor type, proxy constructor pattern) triples
constructed using <code><a href="../.././Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.mkCtorProxyType">mkCtorProxyType</a></code>, return (1) the total proxy type (a <code>Type*</code>),
(2) patterns to use for each constructor, and (3) a proof to use to prove <code>left_inv</code> for
<code>proxy_type ≃ type</code> (this proof starts with <code>intro x</code>).</p></div></li></ul><details id="instances-for-list-Mathlib.ProxyType.ProxyEquivConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.ProxyType.defaultMkCtorProxyType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/ProxyType.lean#L78-L99">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkCtorProxyType"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">defaultMkCtorProxyType</span></a></span><span class="decl_args">
<span class="fn">(xs : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(decorateSigma : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span> <span class="fn">pure</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a>)</span></span></div></div><p>Returns a proxy type for a constructor and a pattern to use to match against it.</p><p>Input: a list of pairs associated to each argument of the constructor consisting
of (1) an fvar for this argument and (2) a name to use for this argument in patterns.</p><p>For example, given <code>#[(a, x), (b, y)]</code> with <code>x : <a href="../.././Init/Prelude.html#Nat">Nat</a></code> and <code>y : <a href="../.././Init/Prelude.html#Fin">Fin</a> x</code>, then this function
returns <code><a href="../.././Init/Core.html#Sigma">Sigma</a> (fun x =&gt; <a href="../.././Init/Prelude.html#Fin">Fin</a> x)</code> and <code>⟨a, b⟩</code>.</p><p>Always returns a <code>Type*</code>. Uses <code><a href="../.././Init/Prelude.html#Unit">Unit</a></code>, <code><a href="../.././Init/Prelude.html#PLift">PLift</a></code>, and <code><a href="../.././Init/Core.html#Sigma">Sigma</a></code>. Avoids using <code><a href="../.././Init/Core.html#PSigma">PSigma</a></code> since
the <code>Fintype</code> instances for it go through <code><a href="../.././Init/Core.html#Sigma">Sigma</a></code>s anyway.</p><p>The <code>decorateSigma</code> function is to wrap the <code><a href="../.././Init/Core.html#Sigma">Sigma</a></code> a decorator such as <code>Lex</code>.
It should yield a definitionally equal type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.ProxyType.defaultMkCtorProxyType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.ProxyType.defaultMkProxyType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/ProxyType.lean#L105-L136">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkProxyType"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">defaultMkProxyType</span></a></span><span class="decl_args">
<span class="fn">(ctors : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(decorateSum : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span> <span class="fn">pure</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`tactic</span></span></span>)</span></span></div></div><p>Create a <code><a href="../.././Init/Core.html#Sum">Sum</a></code> of types, mildly optimized to not have a trailing <code><a href="../.././Init/Prelude.html#Empty">Empty</a></code>.</p><p>The <code>decorateSum</code> function is to wrap the <code><a href="../.././Init/Core.html#Sum">Sum</a></code> with a function such as <code>Lex</code>.
It should yield a definitionally equal type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.ProxyType.defaultMkProxyType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.ProxyType.defaultMkProxyType.mkCType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/ProxyType.lean#L118-L125">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkProxyType.mkCType"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">defaultMkProxyType</span>.<span class="name">mkCType</span></a></span><span class="decl_args">
<span class="fn">(decorateSum : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span> <span class="fn">pure</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ctypes : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`tactic</span></span>)</span></span></div></div><p>Construct the <code><a href="../.././Init/Core.html#Sum">Sum</a></code> expression, using <code>decorateSum</code> to adjust each <code><a href="../.././Init/Core.html#Sum">Sum</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.ProxyType.defaultMkProxyType.mkCType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.ProxyType.defaultMkProxyType.wrapSumAccess"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/ProxyType.lean#L127-L136">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkProxyType.wrapSumAccess"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">defaultMkProxyType</span>.<span class="name">wrapSumAccess</span></a></span><span class="decl_args">
<span class="fn">(cidx : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(nctors : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(spatt : <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a></span></div></div><p>Navigates into the sum type that we create in <code><a href="../.././Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.defaultMkProxyType.mkCType">mkCType</a></code> for the given constructor index.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.ProxyType.defaultMkProxyType.wrapSumAccess" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.ProxyType.ProxyEquivConfig.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/ProxyType.lean#L140-L144">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig.default"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">ProxyEquivConfig</span>.<span class="name">default</span></a></span><span class="decl_args">
<span class="fn">(indVal : <a href="../.././Lean/Declaration.html#Lean.InductiveVal">Lean.InductiveVal</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig">Mathlib.ProxyType.ProxyEquivConfig</a></div></div><p>Default configuration. Defines <code>proxyType</code> and <code>proxyTypeEquiv</code> in the namespace
of the inductive type. Uses <code><a href="../.././Init/Prelude.html#Unit">Unit</a></code>, <code><a href="../.././Init/Prelude.html#PLift">PLift</a></code>, <code><a href="../.././Init/Core.html#Sigma">Sigma</a></code>, <code><a href="../.././Init/Prelude.html#Empty">Empty</a></code>, and <code><a href="../.././Init/Core.html#Sum">Sum</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.ProxyType.ProxyEquivConfig.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.ProxyType.ensureProxyEquiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/ProxyType.lean#L151-L241">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ensureProxyEquiv"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">ensureProxyEquiv</span></a></span><span class="decl_args">
<span class="fn">(config : <a href="../.././Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.ProxyEquivConfig">Mathlib.ProxyType.ProxyEquivConfig</a>)</span></span>
<span class="decl_args">
<span class="fn">(indVal : <a href="../.././Lean/Declaration.html#Lean.InductiveVal">Lean.InductiveVal</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Generates a proxy type for the inductive type and an equivalence from the proxy type to the type.</p><p>If the declarations already exist, there is a check that they are correct.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.ProxyType.ensureProxyEquiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.ProxyType.elabProxyEquiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/ProxyType.lean#L247-L259">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.elabProxyEquiv"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">elabProxyEquiv</span></a></span><span class="decl_args">
<span class="fn">(type : <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a>)</span></span>
<span class="decl_args">
<span class="fn">(expectedType? : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Declaration.html#Lean.InductiveVal">Lean.InductiveVal</a>)</span></span></div></div><p>Helper function for <code>proxy_equiv% type : expectedType</code> elaborators.</p><p>Elaborate <code>type</code> and get its <code>InductiveVal</code>. Uses the <code>expectedType</code>, where the
expected type should be of the form <code>_ ≃ type</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.ProxyType.elabProxyEquiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.ProxyType.proxy_equiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/ProxyType.lean#L261-L286">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.proxy_equiv"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">proxy_equiv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The term elaborator <code>proxy_equiv% α</code> for a type <code>α</code> elaborates to an equivalence <code>β ≃ α</code>
for a &quot;proxy type&quot; <code>β</code> composed out of basic type constructors <code><a href="../.././Init/Prelude.html#Unit">Unit</a></code>, <code><a href="../.././Init/Prelude.html#PLift">PLift</a></code>, <code><a href="../.././Init/Core.html#Sigma">Sigma</a></code>,
<code><a href="../.././Init/Prelude.html#Empty">Empty</a></code>, and <code><a href="../.././Init/Core.html#Sum">Sum</a></code>.</p><p>This only works for inductive types <code>α</code> that are neither recursive nor have indices.
If <code>α</code> is an inductive type with name <code>I</code>, then as a side effect this elaborator defines
<code>I.proxyType</code> and <code>I.proxyTypeEquiv</code>.</p><p>The elaborator makes use of the expected type, so <code>(proxy_equiv% _ : _ ≃ α)</code> works.</p><p>For example, given this inductive type</p><pre><code>inductive foo (n : Nat) (α : Type)
  | a
  | b : <a href="../.././Init/Prelude.html#Bool">Bool</a> → foo n α
  | c (x : <a href="../.././Init/Prelude.html#Fin">Fin</a> n) : <a href="../.././Init/Prelude.html#Fin">Fin</a> x → foo n α
  | d : <a href="../.././Init/Prelude.html#Bool">Bool</a> → α → foo n α
</code></pre><p>the proxy type it generates is <code><a href="../.././Init/Prelude.html#Unit">Unit</a> ⊕ <a href="../.././Init/Prelude.html#Bool">Bool</a> ⊕ (x : <a href="../.././Init/Prelude.html#Fin">Fin</a> n) × <a href="../.././Init/Prelude.html#Fin">Fin</a> x ⊕ (_ : Bool) × α</code> and
in particular we have that</p><pre><code>proxy_equiv% (foo n α) : <a href="../.././Init/Prelude.html#Unit">Unit</a> ⊕ <a href="../.././Init/Prelude.html#Bool">Bool</a> ⊕ (x : <a href="../.././Init/Prelude.html#Fin">Fin</a> n) × <a href="../.././Init/Prelude.html#Fin">Fin</a> x ⊕ (_ : Bool) × α ≃ foo n α
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.ProxyType.proxy_equiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.ProxyType.elab_proxy_equiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/ProxyType.lean#L290-L297">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/ProxyType.html#Mathlib.ProxyType.elab_proxy_equiv"><span class="name">Mathlib</span>.<span class="name">ProxyType</span>.<span class="name">elab_proxy_equiv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElab">Lean.Elab.Term.TermElab</a></div></div><p>Elaborator for <code>proxy_equiv%</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.ProxyType.elab_proxy_equiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>