<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.Ring.Basic</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.Ring.Basic";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Basic</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Util/AtomM.html">Mathlib.Util.AtomM</a></li><li><a href="../../.././Mathlib/Tactic/NormNum/Inv.html">Mathlib.Tactic.NormNum.Inv</a></li><li><a href="../../.././Mathlib/Tactic/NormNum/Pow.html">Mathlib.Tactic.NormNum.Pow</a></li><li><a href="../../.././Mathlib/Algebra/Order/Ring/Rat.html">Mathlib.Algebra.Order.Ring.Rat</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.Ring.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.instCommSemiringNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instCommSemiringNat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.sℕ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">sℕ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExBase"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExSum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExBase.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExSum.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExBase.cmp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">cmp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.cmp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">cmp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExSum.cmp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">cmp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedSigmaQuotedExBase</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedSigmaQuotedExSum</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedSigmaQuotedExProd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExBase.cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">cast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">cast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExSum.cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">cast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.Result"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Result</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedResultOfSigmaQuoted</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.mkNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">mkNat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.mkNegNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">mkNegNat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.mkRat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">mkRat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExBase.toProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.toSum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">toSum</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.coeff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">coeff</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.Overlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Overlap</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_overlap_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_overlap_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_overlap_pf_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_overlap_pf_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalAddOverlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalAddOverlap</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pf_zero_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_zero_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pf_add_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pf_add_overlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_overlap</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pf_add_overlap_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_overlap_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pf_add_lt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_lt</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pf_add_gt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_gt</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalAdd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalAdd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.one_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">one_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_one"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_one</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_pf_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pf_left</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_pf_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pf_right</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_pp_pf_overlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pp_pf_overlap</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalMulProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalMulProd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalMul₁"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalMul₁</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.zero_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">zero_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalMul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.natCast_nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_nat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.natCast_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.natCast_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.natCast_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExBase.evalNatCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">evalNatCast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.evalNatCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">evalNatCast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExSum.evalNatCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">evalNatCast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.smul_nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">smul_nat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.smul_eq_cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">smul_eq_cast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalNSMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalNSMul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.neg_one_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_one_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.neg_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalNegProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalNegProd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.neg_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.neg_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalNeg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalNeg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.sub_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">sub_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalSub"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalSub</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_prod_atom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_prod_atom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalPowProdAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowProdAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_atom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_atom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalPowAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.const_pos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">const_pos</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_exp_pos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_exp_pos</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pos_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pos_left</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pos_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pos_right</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExBase.evalPos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">evalPos</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.evalPos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">evalPos</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExSum.evalPos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">evalPos</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_one"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_one</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_bit0"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_bit0</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_bit1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_bit1</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalPowNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowNat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.one_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">one_pow</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pow</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalPowProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowProd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExtractCoeff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExtractCoeff</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.coeff_one"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">coeff_one</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.coeff_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">coeff_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.extractCoeff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">extractCoeff</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_one_cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_one_cast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.zero_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">zero_pow</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.single_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">single_pow</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_nat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalPow₁"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPow₁</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalPow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPow</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.Cache"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Cache</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mkCache"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mkCache</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.cast_pos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_pos</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.cast_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.cast_neg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_neg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.cast_rat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_rat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalCast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.toProd_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">toProd_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.atom_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">atom_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.atom_pf'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">atom_pf'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.inv_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.inv_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.inv_single"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_single</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.inv_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalInvAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalInvAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.evalInv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">evalInv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExSum.evalInv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">evalInv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.div_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">div_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalDiv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalDiv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.nsmul_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">nsmul_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.neg_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.sub_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">sub_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.inv_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.div_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">div_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.Cache.nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Cache</span>.<span class="name">nat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.isAtomOrDerivable"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">isAtomOrDerivable</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.CSLift"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">CSLift</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.CSLift.inj"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">CSLift</span>.<span class="name">inj</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.CSLiftVal"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">CSLiftVal</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.CSLiftVal.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">CSLiftVal</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.instCSLiftValLift"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instCSLiftValLift</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.of_lift"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">of_lift</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.of_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ringCleanupRef"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ringCleanupRef</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.proveEq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">proveEq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.proveEq.ringCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">proveEq</span>.<span class="name">ringCore</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ring1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ring1</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.tacticRing1!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">tacticRing1!</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="ring-tactic"><code>ring</code> tactic <a class="hover-link" href="#ring-tactic">#</a></h1><p>A tactic for solving equations in commutative (semi)rings,
where the exponents can also contain variables.
Based on <a href="http://www.cs.ru.nl/~freek/courses/tt-2014/read/10.1.1.61.3041.pdf">http://www.cs.ru.nl/~freek/courses/tt-2014/read/10.1.1.61.3041.pdf</a> .</p><p>More precisely, expressions of the following form are supported:</p><ul>
<li>constants (non-negative integers)</li>
<li>variables</li>
<li>coefficients (any rational number, embedded into the (semi)ring)</li>
<li>addition of expressions</li>
<li>multiplication of expressions (<code>a * b</code>)</li>
<li>scalar multiplication of expressions (<code>n • a</code>; the multiplier must have type <code>ℕ</code>)</li>
<li>exponentiation of expressions (the exponent must have type <code>ℕ</code>)</li>
<li>subtraction and negation of expressions (if the base is a full ring)</li>
</ul><p>The extension to exponents means that something like <code>2 * 2^n * b = b * 2^(n+1)</code> can be proved,
even though it is not strictly speaking an equation in the language of commutative rings.</p><h2 class="markdown-heading" id="Implementation-notes">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>The basic approach to prove equalities is to normalise both sides and check for equality.
The normalisation is guided by building a value in the type <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a></code> at the meta level,
together with a proof (at the base level) that the original value is equal to
the normalised version.</p><p>The outline of the file:</p><ul>
<li>Define a mutual inductive family of types <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a></code>, <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a></code>, <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a></code>,
which can represent expressions with <code>+</code>, <code>*</code>, <code>^</code> and rational numerals.
The mutual induction ensures that associativity and distributivity are applied,
by restricting which kinds of subexpressions appear as arguments to the various operators.</li>
<li>Represent addition, multiplication and exponentiation in the <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a></code> type,
thus allowing us to map expressions to <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a></code> (the <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval">eval</a></code> function drives this).
We apply associativity and distributivity of the operators here (helped by <code>Ex*</code> types)
and commutativity as well (by sorting the subterms; unfortunately not helped by anything).
Any expression not of the above formats is treated as an atom (the same as a variable).</li>
</ul><p>There are some details we glossed over which make the plan more complicated:</p><ul>
<li>The order on atoms is not initially obvious.
We construct a list containing them in order of initial appearance in the expression,
then use the index into the list as a key to order on.</li>
<li>For <code>pow</code>, the exponent must be a natural number, while the base can be any semiring <code>α</code>.
We swap out operations for the base ring <code>α</code> with those for the exponent ring <code>ℕ</code>
as soon as we deal with exponents.</li>
</ul><h2 class="markdown-heading" id="Caveats-and-future-work">Caveats and future work <a class="hover-link" href="#Caveats-and-future-work">#</a></h2><p>The normalized form of an expression is the one that is useful for the tactic,
but not as nice to read. To remedy this, the user-facing normalization calls <code>ringNFCore</code>.</p><p>Subtraction cancels out identical terms, but division does not.
That is: <code>a - a = 0 := by ring</code> solves the goal,
but <code>a / a := 1 by ring</code> doesn't.
Note that <code>0 / 0</code> is generally defined to be <code>0</code>,
so division cancelling out is not true in general.</p><p>Multiplication of powers can be simplified a little bit further:
<code>2 ^ n * 2 ^ n = 4 ^ n := by ring</code> could be implemented
in a similar way that <code>2 * a + 2 * a = 4 * a := by ring</code> already works.
This feature wasn't needed yet, so it's not implemented yet.</p><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>ring, semiring, exponent, power</p></div><div class="decl" id="Mathlib.Tactic.Ring.instCommSemiringNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L86-L86">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCommSemiringNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instCommSemiringNat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span></div></div><p>A shortcut instance for <code><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> ℕ</code> used by ring.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCommSemiringNat">Mathlib.Tactic.Ring.instCommSemiringNat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">inferInstance</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.instCommSemiringNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.sℕ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L92-L92">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">sℕ</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span>)</span></div></div><p>A typed expression of type <code><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> ℕ</code> used when we are working on
ring subexpressions of type <code>ℕ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">q(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCommSemiringNat">Mathlib.Tactic.Ring.instCommSemiringNat</a>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.sℕ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExBase"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L97-L112">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span> → <span class="fn"><span class="fn">Q(<span class="fn">«$α»</span>)</span> → <a href="../../.././foundational_types.html">Type</a></span></span></div></div><p>The base <code>e</code> of a normalized exponent expression.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Ring.ExBase.atom">atom: <span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} → <span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>} → <span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>} → <span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>} → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <span class="fn">sα</span> <span class="fn">e</span></span></span></span></span></span></span><div class="inductive_ctor_doc"><p>An atomic expression <code>e</code> with id <code><a href="../../.././Init/Prelude.html#id">id</a></code>.</p><p>Atomic expressions are those which <code>ring</code> cannot parse any further.
For instance, <code>a + (a % b)</code> has <code>a</code> and <code>(a % b)</code> as atoms.
The <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ring1">ring1</a></code> tactic does not normalize the subexpressions in atoms, but <code>ring_nf</code> does.</p><p>Atoms in fact represent equivalence classes of expressions, modulo definitional equality.
The field <code>index : ℕ</code> should be a unique number for each class,
while <code>value : <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.expr">expr</a></code> contains a representative of this class.
The function <code>resolve_atom</code> determines the appropriate atom for a given expression.</p></div></li><li class="constructor" id="Mathlib.Tactic.Ring.ExBase.sum">sum: <span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} →
  <span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>} →
    <span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>} → <span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>} → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">e</span></span> → <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <span class="fn">sα</span> <span class="fn">e</span></span></span></span></span></span></span><div class="inductive_ctor_doc"><p>A sum of monomials.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Ring.ExBase" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L118-L126">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span> → <span class="fn"><span class="fn">Q(<span class="fn">«$α»</span>)</span> → <a href="../../.././foundational_types.html">Type</a></span></span></div></div><p>A monomial, which is a product of powers of <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a></code> expressions,
terminated by a (nonzero) constant coefficient.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Ring.ExProd.const">const: <span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} →
  <span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>} →
    <span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>} → <span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>} → <span class="fn"><a href="../../.././Batteries/Data/Rat/Basic.html#Rat">ℚ</a> → <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#optParam">optParam</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span> <span class="fn">none</span></span> → <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">e</span></span></span></span></span></span></span></span><div class="inductive_ctor_doc"><p>A coefficient <code>value</code>, which must not be <code>0</code>. <code>e</code> is a raw rat cast.
If <code>value</code> is not an integer, then <code>hyp</code> should be a proof of <code>(value.den : α) ≠ 0</code>.</p></div></li><li class="constructor" id="Mathlib.Tactic.Ring.ExProd.mul">mul: <span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} →
  <span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>} →
    <span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>} →
      <span class="fn">{<span class="fn">x</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>} →
        <span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>} →
          <span class="fn">{<span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>} →
            <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <span class="fn">sα</span> <span class="fn">x</span></span> →
              <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn">e</span></span> →
                <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">q(<span class="fn"><span class="fn"><span class="fn">«$x»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$e»</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">«$b»</span></span>)</span></span></span></span></span></span></span></span></span></span></span><div class="inductive_ctor_doc"><p>A product <code>x ^ e * b</code> is a monomial if <code>b</code> is a monomial. Here <code>x</code> is an <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a></code>
and <code>e</code> is an <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a></code> representing a monomial expression in <code>ℕ</code> (it is a monomial instead of
a polynomial because we eagerly normalize <code>x ^ (a + b) = x ^ a * x ^ b</code>.)</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Ring.ExProd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExSum"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L129-L134">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span> → <span class="fn"><span class="fn">Q(<span class="fn">«$α»</span>)</span> → <a href="../../.././foundational_types.html">Type</a></span></span></div></div><p>A polynomial expression, which is a sum of monomials.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Ring.ExSum.zero">zero: <span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} → <span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>} → <span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>} → <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">q(<span class="fn">0</span>)</span></span></span></span></span><div class="inductive_ctor_doc"><p>Zero is a polynomial. <code>e</code> is the expression <code>0</code>.</p></div></li><li class="constructor" id="Mathlib.Tactic.Ring.ExSum.add">add: <span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} →
  <span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>} →
    <span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>} →
      <span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>} →
        <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">«$b»</span></span>)</span></span></span></span></span></span></span></span><div class="inductive_ctor_doc"><p>A sum <code>a + b</code> is a polynomial if <code>a</code> is a monomial and <code>b</code> is another polynomial.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Ring.ExSum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExBase.eq"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L144-L147">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">eq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">a</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} →
  <span class="fn">{<span class="fn">arg</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> a)</span>} →
    <span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$arg»</span></span>)</span>} →
      <span class="fn">{<span class="fn">a_1 </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$arg»</span>)</span>} → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <span class="fn">sα</span> <span class="fn">a_1</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span></span></span></span></span></div></div><p>Equality test for expressions. This is not a <code><a href="../../.././Init/Prelude.html#BEq">BEq</a></code> instance because it is heterogeneous.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.eq"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L150-L153">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">eq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">a</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} →
  <span class="fn">{<span class="fn">arg</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> a)</span>} →
    <span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$arg»</span></span>)</span>} →
      <span class="fn">{<span class="fn">a_1 </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$arg»</span>)</span>} → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">a_1</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span></span></span></span></span></div></div><p>Equality test for expressions. This is not a <code><a href="../../.././Init/Prelude.html#BEq">BEq</a></code> instance because it is heterogeneous.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExSum.eq"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L156-L159">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">eq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">a</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} →
  <span class="fn">{<span class="fn">arg</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> a)</span>} →
    <span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$arg»</span></span>)</span>} →
      <span class="fn">{<span class="fn">a_1 </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$arg»</span>)</span>} → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">a_1</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span></span></span></span></span></div></div><p>Equality test for expressions. This is not a <code><a href="../../.././Init/Prelude.html#BEq">BEq</a></code> instance because it is heterogeneous.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExBase.cmp"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L167-L171">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.cmp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">cmp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">a</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} →
  <span class="fn">{<span class="fn">arg</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> a)</span>} →
    <span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$arg»</span></span>)</span>} →
      <span class="fn">{<span class="fn">a_1 </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$arg»</span>)</span>} → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <span class="fn">sα</span> <span class="fn">a_1</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <a href="../../.././Init/Data/Ord.html#Ordering">Ordering</a></span></span></span></span></span></span></div></div><p>A total order on normalized expressions.
This is not an <code><a href="../../.././Init/Data/Ord.html#Ord">Ord</a></code> instance because it is heterogeneous.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.cmp"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L174-L178">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.cmp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">cmp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">a</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} →
  <span class="fn">{<span class="fn">arg</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> a)</span>} →
    <span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$arg»</span></span>)</span>} →
      <span class="fn">{<span class="fn">a_1 </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$arg»</span>)</span>} → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">a_1</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <a href="../../.././Init/Data/Ord.html#Ordering">Ordering</a></span></span></span></span></span></span></div></div><p>A total order on normalized expressions.
This is not an <code><a href="../../.././Init/Data/Ord.html#Ord">Ord</a></code> instance because it is heterogeneous.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExSum.cmp"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L181-L185">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.cmp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">cmp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">a</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} →
  <span class="fn">{<span class="fn">arg</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> a)</span>} →
    <span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$arg»</span></span>)</span>} →
      <span class="fn">{<span class="fn">a_1 </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$arg»</span>)</span>} → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">a_1</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <a href="../../.././Init/Data/Ord.html#Ordering">Ordering</a></span></span></span></span></span></span></div></div><p>A total order on normalized expressions.
This is not an <code><a href="../../.././Init/Data/Ord.html#Ord">Ord</a></code> instance because it is heterogeneous.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L190-L190">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedSigmaQuotedExBase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{arg : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$arg»</span></span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">((<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$arg»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <span class="fn">sα</span> <span class="fn">e</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">⟨<span class="fn">default</span>, <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.atom">Mathlib.Tactic.Ring.ExBase.atom</a> <span class="fn">0</span></span>⟩</span> }</span></span></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L191-L191">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedSigmaQuotedExSum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{arg : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$arg»</span></span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">((<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$arg»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">e</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">⟨<span class="fn">q(<span class="fn">0</span>)</span>, <span class="fn">Mathlib.Tactic.Ring.ExSum.zero</span>⟩</span> }</span></span></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L192-L192">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedSigmaQuotedExProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{arg : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$arg»</span></span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">((<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$arg»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">e</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">⟨<span class="fn">default</span>, <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">Mathlib.Tactic.Ring.ExProd.const</a> <span class="fn">0</span></span>⟩</span> }</span></span></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExBase.cast"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L197-L199">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{arg : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$arg»</span></span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">a</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} →
  <span class="fn">{<span class="fn">arg_1</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> a)</span>} →
    <span class="fn">{<span class="fn">sβ</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$arg_1»</span></span>)</span>} →
      <span class="fn">{<span class="fn">a_1</span> : <span class="fn">Q(<span class="fn">«$arg»</span>)</span>} → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <span class="fn">sα</span> <span class="fn">a_1</span></span> → <span class="fn">(<span class="fn">a_3</span> : <span class="fn">Q(<span class="fn">«$arg_1»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <span class="fn">sβ</span> <span class="fn">a_3</span></span></span></span></span></span></span></span></div></div><p>Converts <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> sα</code> to <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> sβ</code>, assuming <code>sα</code> and <code>sβ</code> are defeq.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.cast"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L202-L204">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{arg : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$arg»</span></span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">a</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} →
  <span class="fn">{<span class="fn">arg_1</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> a)</span>} →
    <span class="fn">{<span class="fn">sβ</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$arg_1»</span></span>)</span>} →
      <span class="fn">{<span class="fn">a_1</span> : <span class="fn">Q(<span class="fn">«$arg»</span>)</span>} → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">a_1</span></span> → <span class="fn">(<span class="fn">a_3</span> : <span class="fn">Q(<span class="fn">«$arg_1»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sβ</span> <span class="fn">a_3</span></span></span></span></span></span></span></span></div></div><p>Converts <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> sα</code> to <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> sβ</code>, assuming <code>sα</code> and <code>sβ</code> are defeq.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExSum.cast"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L207-L209">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{arg : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$arg»</span></span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">a</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} →
  <span class="fn">{<span class="fn">arg_1</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> a)</span>} →
    <span class="fn">{<span class="fn">sβ</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$arg_1»</span></span>)</span>} →
      <span class="fn">{<span class="fn">a_1</span> : <span class="fn">Q(<span class="fn">«$arg»</span>)</span>} → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">a_1</span></span> → <span class="fn">(<span class="fn">a_3</span> : <span class="fn">Q(<span class="fn">«$arg_1»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sβ</span> <span class="fn">a_3</span></span></span></span></span></span></span></span></div></div><p>Converts <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> sα</code> to <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> sβ</code>, assuming <code>sα</code> and <code>sβ</code> are defeq.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.Result"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L222-L228">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Result</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(E : <span class="fn"><span class="fn">Q(<span class="fn">«$α»</span>)</span> → <a href="../../.././foundational_types.html">Type</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn">Q(<span class="fn">«$α»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>The result of evaluating an (unnormalized) expression <code>e</code> into the type family <code>E</code>
(one of <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a></code>, <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a></code>, <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a></code>) is a (normalized) element <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'">e'</a></code>
and a representation <code>E <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'">e'</a></code> for it, and a proof of <code>e = <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'">e'</a></code>.</p><ul class="structure_fields" id="Mathlib.Tactic.Ring.Result.mk"><li id="Mathlib.Tactic.Ring.Result.expr" class="structure_field"><div class="structure_field_info">expr : <span class="fn">Q(<span class="fn">«$α»</span>)</span></div><div class="structure_field_doc"><p>The normalized result.</p></div></li><li id="Mathlib.Tactic.Ring.Result.val" class="structure_field"><div class="structure_field_info">val : <span class="fn"><span class="fn">E</span> <span class="fn"><span class="fn">self</span>.expr</span></span></div><div class="structure_field_doc"><p>The data associated to the normalization.</p></div></li><li id="Mathlib.Tactic.Ring.Result.proof" class="structure_field"><div class="structure_field_info">proof : <span class="fn">Q(<span class="fn"><span class="fn">«$e»</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">unknown_1</span></span>)</span></div><div class="structure_field_doc"><p>A proof that the original expression is equal to the normalized result.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Ring.Result" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L230-L232">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedResultOfSigmaQuoted</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <span class="fn"><span class="fn">Q(<span class="fn">«$α»</span>)</span> → <a href="../../.././foundational_types.html">Type</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">((<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>) × <span class="fn"><span class="fn">E</span> <span class="fn">e</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">E</span> <span class="fn">e</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">default</span> with
  | <span class="fn">⟨<span class="fn">e'</span>, <span class="fn">v</span>⟩</span> =&gt; <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">expr</span> := <span class="fn">e'</span>, <span class="fn">val</span> := <span class="fn">v</span>, <span class="fn">proof</span> := <span class="fn">default</span> }</span> }</span></span></span></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.mkNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L240-L242">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">mkNat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">e</span></span></span></div></div><p>Constructs the expression corresponding to <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">const</a> n</code>.
(The <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">const</a></code> constructor does not check that the expression is correct.)</p><details id="instances-for-list-Mathlib.Tactic.Ring.ExProd.mkNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.mkNegNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L248-L250">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNegNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">mkNegNat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">«$α»</span></span>)</span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">e</span></span></span></span></span></div></div><p>Constructs the expression corresponding to <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">const</a> (-n)</code>.
(The <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">const</a></code> constructor does not check that the expression is correct.)</p><details id="instances-for-list-Mathlib.Tactic.Ring.ExProd.mkNegNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.mkRat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L256-L258">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkRat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">mkRat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">«$α»</span></span>)</span> → <span class="fn"><a href="../../.././Batteries/Data/Rat/Basic.html#Rat">ℚ</a> → <span class="fn"><span class="fn">Q(<a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span> → <span class="fn"><span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span> → <span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">e</span></span></span></span></span></span></span></span></div></div><p>Constructs the expression corresponding to <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">const</a> (-n)</code>.
(The <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">const</a></code> constructor does not check that the expression is correct.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkRat">Mathlib.Tactic.Ring.ExProd.mkRat</a> <span class="fn">sα</span> <span class="fn">x</span> <span class="fn">q</span> <span class="fn">n</span> <span class="fn">d</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⟨<span class="fn">q(<span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Rat.rawCast">Rat.rawCast</a> <span class="fn">«$n»</span> <span class="fn">«$d»</span></span>)</span>, <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">Mathlib.Tactic.Ring.ExProd.const</a> <span class="fn">q</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">h</span>)</span></span>⟩</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.ExProd.mkRat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExBase.toProd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L263-L265">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.toProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(vb : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">q(<span class="fn"><span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></span>)</span></span></div></div><p>Embed an exponent (an <code>ExBase, <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a></code> pair) as an <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a></code> by multiplying by 1.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">va</span>.toProd</span> <span class="fn">vb</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mul">Mathlib.Tactic.Ring.ExProd.mul</a> <span class="fn">va</span> <span class="fn">vb</span> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">Mathlib.Tactic.Ring.ExProd.const</a> <span class="fn">1</span>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.ExBase.toProd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.toSum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L268-L269">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.toSum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">toSum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(v : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">e</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">q(<span class="fn"><span class="fn">«$e»</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span>)</span></span></div></div><p>Embed <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a></code> in <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a></code> by adding 0.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">v</span>.toSum</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.add">Mathlib.Tactic.Ring.ExSum.add</a> <span class="fn">v</span> <span class="fn">Mathlib.Tactic.Ring.ExSum.zero</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.ExProd.toSum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.coeff"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L272-L274">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.coeff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">coeff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">e</span></span> → <a href="../../.././Batteries/Data/Rat/Basic.html#Rat">ℚ</a></span></div></div><p>Get the leading coefficient of an <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">Mathlib.Tactic.Ring.ExProd.const</a> <span class="fn">i</span> <span class="fn">h</span>)</span>.coeff</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">i</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mul">Mathlib.Tactic.Ring.ExProd.mul</a> <span class="fn">a₁</span> <span class="fn">a₂</span> <span class="fn">a₃</span>)</span>.coeff</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a₃</span>.coeff</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.ExProd.coeff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.Overlap"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L282-L287">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Overlap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn">Q(<span class="fn">«$α»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>Two monomials are said to &quot;overlap&quot; if they differ by a constant factor, in which case the
constants just add. When this happens, the constant may be either zero (if the monomials cancel)
or nonzero (if they add up); the zero case is handled specially.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Ring.Overlap.zero">zero: <span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} →
  <span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>} →
    <span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>} →
      <span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>} → <span class="fn"><span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat">Mathlib.Meta.NormNum.IsNat</a> <span class="fn">«$e»</span> <span class="fn">0</span></span>)</span> → <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap">Mathlib.Tactic.Ring.Overlap</a> <span class="fn">sα</span> <span class="fn">e</span></span></span></span></span></span></span><div class="inductive_ctor_doc"><p>The expression <code>e</code> (the sum of monomials) is equal to <code>0</code>.</p></div></li><li class="constructor" id="Mathlib.Tactic.Ring.Overlap.nonzero">nonzero: <span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>} →
  <span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>} →
    <span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>} →
      <span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>} → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span>)</span> <span class="fn">e</span></span> → <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap">Mathlib.Tactic.Ring.Overlap</a> <span class="fn">sα</span> <span class="fn">e</span></span></span></span></span></span></span><div class="inductive_ctor_doc"><p>The expression <code>e</code> (the sum of monomials) is equal to another monomial
(with nonzero leading coefficient).</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Ring.Overlap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_overlap_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L291-L292">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_overlap_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_overlap_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(pq_pf : <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_overlap_pf_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L294-L296">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_overlap_pf_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_overlap_pf_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat">Mathlib.Meta.NormNum.IsNat</a> <span class="fn">(<span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b</span>)</span> <span class="fn">0</span></span> → <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat">Mathlib.Meta.NormNum.IsNat</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span>)</span> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalAddOverlap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L304-L322">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAddOverlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalAddOverlap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(vb : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap">Mathlib.Tactic.Ring.Overlap</a> <span class="fn">sα</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">«$b»</span></span>)</span>)</span></span></div></div><p>Given monomials <code>va, vb</code>, attempts to add them together to get another monomial.
If the monomials are not compatible, returns <code>none</code>.
For example, <code>xy + 2xy = 3xy</code> is a <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap.nonzero">nonzero</a></code> overlap, while <code>xy + xz</code> returns <code>none</code>
and <code>xy + -xy = 0</code> is a <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero">zero</a></code> overlap.</p><details id="instances-for-list-Mathlib.Tactic.Ring.evalAddOverlap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pf_zero_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L324-L324">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_zero_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_zero_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(b : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pf_add_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L326-L326">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pf_add_overlap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L328-L330">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_overlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_overlap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c₂ : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₁</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₂</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">(<span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">c₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">c₂</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pf_add_overlap_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L332-L334">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_overlap_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_overlap_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat">Mathlib.Meta.NormNum.IsNat</a> <span class="fn">(<span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₁</span>)</span> <span class="fn">0</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₄ : <span class="fn"><span class="fn"><span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">(<span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pf_add_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L336-L336">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_lt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a₁ : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pf_add_gt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L338-L339">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_gt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_gt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(b₁ : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">(<span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalAdd"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L349-L368">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAdd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalAdd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(vb : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">«$b»</span></span>)</span></span></div></div><p>Adds two polynomials <code>va, vb</code> together to get a normalized result polynomial.</p><ul>
<li><code>0 + b = b</code></li>
<li><code>a + 0 = a</code></li>
<li><code>a * x + a * y = a * (x + y)</code> (for <code>x</code>, <code>y</code> coefficients; uses <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAddOverlap">evalAddOverlap</a></code>)</li>
<li><code>(a₁ + a₂) + (b₁ + b₂) = a₁ + (a₂ + (b₁ + b₂))</code> (if <code>a₁.lt b₁</code>)</li>
<li><code>(a₁ + a₂) + (b₁ + b₂) = b₁ + ((a₁ + a₂) + b₂)</code> (if not <code>a₁.lt b₁</code>)</li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.one_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L370-L370">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.one_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">one_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L372-L372">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_one"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_pf_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L374-L376">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pf_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pf_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₃ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a₁ : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₂ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a₃</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₃</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_pf_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L378-L380">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pf_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pf_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₃ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(b₁ : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(b₂ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b₃</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">(<span class="fn"><span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b₂</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b₃</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b₂</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_pp_pf_overlap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L382-L384">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pp_pf_overlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pp_pf_overlap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ea : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{eb : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">ea</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">eb</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">ea</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">eb</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b₂</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalMulProd"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L396-L427">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMulProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalMulProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(vb : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">«$b»</span></span>)</span></span></div></div><p>Multiplies two monomials <code>va, vb</code> together to get a normalized result monomial.</p><ul>
<li><code>x * y = (x * y)</code> (for <code>x</code>, <code>y</code> coefficients)</li>
<li><code>x * (b₁ * b₂) = b₁ * (b₂ * x)</code> (for <code>x</code> coefficient)</li>
<li><code>(a₁ * a₂) * y = a₁ * (a₂ * y)</code> (for <code>y</code> coefficient)</li>
<li><code>(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)</code>
(if <code>ea</code> and <code>eb</code> are identical except coefficient)</li>
<li><code>(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))</code> (if <code>a₁.lt b₁</code>)</li>
<li><code>(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)</code> (if not <code>a₁.lt b₁</code>)</li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L429-L429">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L431-L433">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₁</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₂</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">c₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">(<span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalMul₁"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L440-L447">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul₁"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalMul₁</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(vb : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">«$b»</span></span>)</span></span></div></div><p>Multiplies a monomial <code>va</code> to a polynomial <code>vb</code> to get a normalized result polynomial.</p><ul>
<li><code>a * 0 = 0</code></li>
<li><code>a * (b₁ + b₂) = (a * b₁) + (a * b₂)</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul₁">Mathlib.Tactic.Ring.evalMul₁</a> <span class="fn">sα</span> <span class="fn">va</span> <span class="fn">Mathlib.Tactic.Ring.ExSum.zero</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">expr</span> := <span class="fn">q(<span class="fn">0</span>)</span>, <span class="fn">val</span> := <span class="fn">Mathlib.Tactic.Ring.ExSum.zero</span>, <span class="fn">proof</span> := <span class="fn">q(<span class="fn">⋯</span>)</span> }</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalMul₁" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.zero_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L449-L449">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zero_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">zero_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(b : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L451-L452">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₁</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₂</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">c₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">c₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span> → <span class="fn"><span class="fn"><span class="fn">(<span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span>)</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalMul"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L459-L466">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalMul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(vb : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">«$b»</span></span>)</span></span></div></div><p>Multiplies two polynomials <code>va, vb</code> together to get a normalized result polynomial.</p><ul>
<li><code>0 * b = 0</code></li>
<li><code>(a₁ + a₂) * b = (a₁ * b) + (a₂ * b)</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul">Mathlib.Tactic.Ring.evalMul</a> <span class="fn">sα</span> <span class="fn">Mathlib.Tactic.Ring.ExSum.zero</span> <span class="fn">vb</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">expr</span> := <span class="fn">q(<span class="fn">0</span>)</span>, <span class="fn">val</span> := <span class="fn">Mathlib.Tactic.Ring.ExSum.zero</span>, <span class="fn">proof</span> := <span class="fn">q(<span class="fn">⋯</span>)</span> }</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalMul" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.natCast_nat"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L468-L468">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_nat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑<span class="fn"><span class="fn">n</span>.rawCast</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">n</span>.rawCast</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.natCast_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L470-L472">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₃ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₃ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(a₂ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">↑<span class="fn">a₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span></span> → <span class="fn"><span class="fn"><span class="fn">↑<span class="fn">a₃</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₃</span></span> → <span class="fn"><span class="fn">↑<span class="fn">(<span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₃</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b₃</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.natCast_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L474-L474">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑<span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.natCast_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L476-L478">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">↑<span class="fn">a₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span></span> → <span class="fn"><span class="fn"><span class="fn">↑<span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span></span> → <span class="fn"><span class="fn">↑<span class="fn">(<span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExBase.evalNatCast"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L487-L495">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalNatCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">evalNatCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">Mathlib.Tactic.AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">↑<span class="fn">«$a»</span></span>)</span>)</span></span></div></div><p>Applies <code><a href="../../.././Init/Data/Cast.html#Nat.cast">Nat.cast</a></code> to a nat polynomial to produce a polynomial in <code>α</code>.</p><ul>
<li>An atom <code>e</code> causes <code>↑e</code> to be allocated as a new atom.</li>
<li>A sum delegates to <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalNatCast">ExSum.evalNatCast</a></code>.</li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.evalNatCast"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L502-L510">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalNatCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">evalNatCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">Mathlib.Tactic.AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">↑<span class="fn">«$a»</span></span>)</span>)</span></span></div></div><p>Applies <code><a href="../../.././Init/Data/Cast.html#Nat.cast">Nat.cast</a></code> to a nat monomial to produce a monomial in <code>α</code>.</p><ul>
<li><code>↑c = c</code> if <code>c</code> is a numeric literal</li>
<li><code>↑(a ^ n * b) = ↑a ^ n * ↑b</code></li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExSum.evalNatCast"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L517-L523">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalNatCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">evalNatCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">Mathlib.Tactic.AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">↑<span class="fn">«$a»</span></span>)</span>)</span></span></div></div><p>Applies <code><a href="../../.././Init/Data/Cast.html#Nat.cast">Nat.cast</a></code> to a nat polynomial to produce a polynomial in <code>α</code>.</p><ul>
<li><code>↑0 = 0</code></li>
<li><code>↑(a + b) = ↑a + ↑b</code></li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.smul_nat"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L527-L527">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">smul_nat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.smul_eq_cast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L529-L530">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_eq_cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">smul_eq_cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">↑<span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalNSMul"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L538-L548">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNSMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalNSMul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(vb : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">Mathlib.Tactic.AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span> <a href="../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">«$b»</span></span>)</span>)</span></span></div></div><p>Constructs the scalar multiplication <code>n • a</code>, where both <code>n : ℕ</code> and <code>a : α</code> are normalized
polynomial expressions.</p><ul>
<li><code>a • b = a * b</code> if <code>α = ℕ</code></li>
<li><code>a • b = ↑a * b</code> otherwise</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalNSMul" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.neg_one_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L550-L551">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_one_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_one_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/Int/Basic.html#Int.negOfNat">Int.negOfNat</a> <span class="fn">1</span>)</span>.rawCast</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.neg_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L553-L554">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a₁ : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₂ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a₃ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a₃</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">(<span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₃</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalNegProd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L561-L575">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNegProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalNegProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(rα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">«$a»</span></span>)</span></span></div></div><p>Negates a monomial <code>va</code> to get another monomial.</p><ul>
<li><code>-c = (-c)</code> (for <code>c</code> coefficient)</li>
<li><code>-(a₁ * a₂) = a₁ * -a₂</code></li>
</ul><details id="instances-for-list-Mathlib.Tactic.Ring.evalNegProd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.neg_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L577-L577">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">-<span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.neg_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L579-L581">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span></span> → <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span></span> → <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">(<span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalNeg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L588-L594">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNeg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalNeg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(rα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">«$a»</span></span>)</span></span></div></div><p>Negates a polynomial <code>va</code> to get another polynomial.</p><ul>
<li><code>-0 = 0</code> (for <code>c</code> coefficient)</li>
<li><code>-(a₁ + a₂) = -a₁ + -a₂</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNeg">Mathlib.Tactic.Ring.evalNeg</a> <span class="fn">sα</span> <span class="fn">rα</span> <span class="fn">Mathlib.Tactic.Ring.ExSum.zero</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">expr</span> := <span class="fn">q(<span class="fn">0</span>)</span>, <span class="fn">val</span> := <span class="fn">Mathlib.Tactic.Ring.ExSum.zero</span>, <span class="fn">proof</span> := <span class="fn">q(<span class="fn">⋯</span>)</span> }</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalNeg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.sub_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L596-L597">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sub_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">sub_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalSub"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L603-L607">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalSub"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalSub</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(rα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(vb : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">«$b»</span></span>)</span></span></div></div><p>Subtracts two polynomials <code>va, vb</code> to get a normalized result polynomial.</p><ul>
<li><code>a - b = a + -b</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalSub" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_prod_atom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L609-L609">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_prod_atom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_prod_atom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span>)</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalPowProdAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L618-L620">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProdAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowProdAtom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(vb : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span></span>)</span></span></div></div><p>The fallback case for exponentiating polynomials is to use <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.toProd">ExBase.toProd</a></code> to just build an
exponent expression. (This has a slightly different normalization than <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowAtom">evalPowAtom</a></code> because
the input types are different.)</p><ul>
<li><code>x ^ e = (x + 0) ^ e * 1</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProdAtom">Mathlib.Tactic.Ring.evalPowProdAtom</a> <span class="fn">sα</span> <span class="fn">va</span> <span class="fn">vb</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">expr</span> := <span class="fn">q(<span class="fn"><span class="fn"><span class="fn">(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span>)</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></span>)</span>, <span class="fn">val</span> := <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.sum">Mathlib.Tactic.Ring.ExBase.sum</a> <span class="fn"><span class="fn">va</span>.toSum</span>)</span>.toProd</span> <span class="fn">vb</span></span>,
    <span class="fn">proof</span> := <span class="fn">q(<span class="fn">⋯</span>)</span> }</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalPowProdAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_atom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L622-L622">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_atom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_atom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalPowAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L630-L632">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowAtom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(vb : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span></span>)</span></span></div></div><p>The fallback case for exponentiating polynomials is to use <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.toProd">ExBase.toProd</a></code> to just build an
exponent expression.</p><ul>
<li><code>x ^ e = x ^ e * 1 + 0</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowAtom">Mathlib.Tactic.Ring.evalPowAtom</a> <span class="fn">sα</span> <span class="fn">va</span> <span class="fn">vb</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">expr</span> := <span class="fn">q(<span class="fn"><span class="fn"><span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span>)</span>, <span class="fn">val</span> := <span class="fn"><span class="fn">(<span class="fn"><span class="fn">va</span>.toProd</span> <span class="fn">vb</span>)</span>.toSum</span>, <span class="fn">proof</span> := <span class="fn">q(<span class="fn">⋯</span>)</span> }</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalPowAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.const_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L634-L634">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.const_pos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">const_pos</span></a></span><span class="decl_args">
<span class="fn">(n : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Nat.ble">Nat.ble</a> <span class="fn">1</span> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">n</span>.rawCast</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_exp_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L636-L637">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_exp_pos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_exp_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(n : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₂</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pos_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L639-L640">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pos_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pos_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(a₂ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a₁</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pos_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L642-L643">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pos_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pos_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(a₁ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExBase.evalPos"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L652-L655">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalPos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">evalPos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">«$a»</span></span>)</span></span></div></div><p>Attempts to prove that a polynomial expression in <code>ℕ</code> is positive.</p><ul>
<li>Atoms are not (necessarily) positive</li>
<li>Sums defer to <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalPos">ExSum.evalPos</a></code></li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.evalPos"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L662-L673">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalPos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">evalPos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">«$a»</span></span>)</span></span></div></div><p>Attempts to prove that a monomial expression in <code>ℕ</code> is positive.</p><ul>
<li><code>0 &lt; c</code> (where <code>c</code> is a numeral) is true by the normalization invariant (<code>c</code> is not zero)</li>
<li><code>0 &lt; x ^ e * b</code> if <code>0 &lt; x</code> and <code>0 &lt; b</code></li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExSum.evalPos"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L680-L686">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalPos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">evalPos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">«$a»</span></span>)</span></span></div></div><p>Attempts to prove that a polynomial expression in <code>ℕ</code> is positive.</p><ul>
<li><code>0 &lt; 0</code> fails</li>
<li><code>0 &lt; a + b</code> if <code>0 &lt; a</code> or <code>0 &lt; b</code></li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L690-L690">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_one"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_bit0"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L692-L694">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_bit0"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_bit0</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">k</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><a href="../../.././Init/Prelude.html#Nat.mul">Nat.mul</a> <span class="fn">2</span> <span class="fn">k</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_bit1"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L696-L698">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_bit1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_bit1</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">k</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#Nat.mul">Nat.mul</a> <span class="fn">2</span> <span class="fn">k</span>)</span>.add</span> <span class="fn">1</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalPowNat"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L709-L724">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowNat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$n»</span></span>)</span></span></div></div><p>The main case of exponentiation of ring expressions is when <code>va</code> is a polynomial and <code>n</code> is a
nonzero literal expression, like <code>(x + y)^5</code>. In this case we work out the polynomial completely
into a sum of monomials.</p><ul>
<li><code>x ^ 1 = x</code></li>
<li><code>x ^ (2*n) = x ^ n * x ^ n</code></li>
<li><code>x ^ (2*n+1) = x ^ n * x ^ n * x</code></li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.one_pow"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L726-L726">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.one_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">one_pow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(b : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_pow"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L728-L730">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ea₁ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c₁ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{xa₁ : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">ea₁</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₁</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₂</span></span> → <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">xa₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">ea₁</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₂</span>)</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">xa₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">c₁</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c₂</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalPowProd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L740-L760">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(vb : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span></span>)</span></span></div></div><p>There are several special cases when exponentiating monomials:</p><ul>
<li><code>1 ^ n = 1</code></li>
<li><code>x ^ y = (x ^ y)</code> when <code>x</code> and <code>y</code> are constants</li>
<li><code>(a * b) ^ e = a ^ e * b ^ e</code></li>
</ul><p>In all other cases we use <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProdAtom">evalPowProdAtom</a></code>.</p><details id="instances-for-list-Mathlib.Tactic.Ring.evalPowProd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExtractCoeff"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L766-L774">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExtractCoeff</span></a></span><span class="decl_args">
<span class="fn">(e : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>The result of <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.extractCoeff">extractCoeff</a></code> is a numeral and a proof that the original expression
factors by this numeral.</p><ul class="structure_fields" id="Mathlib.Tactic.Ring.ExtractCoeff.mk"><li id="Mathlib.Tactic.Ring.ExtractCoeff.k" class="structure_field"><div class="structure_field_info">k : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></div><div class="structure_field_doc"><p>A raw natural number literal.</p></div></li><li id="Mathlib.Tactic.Ring.ExtractCoeff.e'" class="structure_field"><div class="structure_field_info">e' : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></div><div class="structure_field_doc"><p>The result of extracting the coefficient is a monic monomial.</p></div></li><li id="Mathlib.Tactic.Ring.ExtractCoeff.ve'" class="structure_field"><div class="structure_field_info">ve' : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn"><span class="fn">self</span>.e'</span></span></div><div class="structure_field_doc"><p><code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'">e'</a></code> is a monomial.</p></div></li><li id="Mathlib.Tactic.Ring.ExtractCoeff.p" class="structure_field"><div class="structure_field_info">p : <span class="fn">Q(<span class="fn"><span class="fn">«$e»</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">unknown_1</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">unknown_2</span></span></span>)</span></div><div class="structure_field_doc"><p>The proof that <code>e</code> splits into the coefficient <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k">k</a></code> and the monic monomial <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'">e'</a></code>.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Ring.ExtractCoeff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.coeff_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L776-L776">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.coeff_one"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">coeff_one</span></a></span><span class="decl_args">
<span class="fn">(k : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">k</span>.rawCast</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">k</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.coeff_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L778-L780">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.coeff_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">coeff_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₃ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c₂ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(a₁ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(a₂ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a₃</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">c₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">k</span></span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₃</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c₂</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">k</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.extractCoeff"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L788-L795">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.extractCoeff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">extractCoeff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff">Mathlib.Tactic.Ring.ExtractCoeff</a> <span class="fn">a</span></span></div></div><p>Given a monomial expression <code>va</code>, splits off the leading coefficient <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k">k</a></code> and the remainder
<code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'">e'</a></code>, stored in the <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff">ExtractCoeff</a></code> structure.</p><ul>
<li><code>c = 1 * c</code> (if <code>c</code> is a constant)</li>
<li><code>a * b = (a * b') * <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k">k</a></code> if <code>b = b' * <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k">k</a></code></li>
</ul><details id="instances-for-list-Mathlib.Tactic.Ring.extractCoeff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_one_cast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L797-L797">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_one_cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_one_cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.zero_pow"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L799-L799">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zero_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">zero_pow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.single_pow"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L801-L802">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.single_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">single_pow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span>)</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">c</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_nat"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L804-L806">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_nat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">c</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">k</span></span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">d</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">k</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalPow₁"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L817-L835">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow₁"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPow₁</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(vb : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span></span>)</span></span></div></div><p>Exponentiates a polynomial <code>va</code> by a monomial <code>vb</code>, including several special cases.</p><ul>
<li><code>a ^ 1 = a</code></li>
<li><code>0 ^ e = 0</code> if <code>0 &lt; e</code></li>
<li><code>(a + 0) ^ b = a ^ b</code> computed using <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProd">evalPowProd</a></code></li>
<li><code>a ^ b = (a ^ b') ^ <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k">k</a></code> if <code>b = b' * <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k">k</a></code> and <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k">k</a> &gt; 1</code></li>
</ul><p>Otherwise <code>a ^ b</code> is just encoded as <code>a ^ b * 1 + 0</code> using <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowAtom">evalPowAtom</a></code>.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L837-L837">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L839-L841">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₁</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₂</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">c₁</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">(<span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalPow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L848-L856">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(vb : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span></span>)</span></span></div></div><p>Exponentiates two polynomials <code>va, vb</code>.</p><ul>
<li><code>a ^ 0 = 1</code></li>
<li><code>a ^ (b₁ + b₂) = a ^ b₁ * a ^ b₂</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow">Mathlib.Tactic.Ring.evalPow</a> <span class="fn">sα</span> <span class="fn">va</span> <span class="fn">Mathlib.Tactic.Ring.ExSum.zero</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">expr</span> := <span class="fn">q(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span>)</span>, <span class="fn">val</span> := <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNat">Mathlib.Tactic.Ring.ExProd.mkNat</a> <span class="fn">sα</span> <span class="fn">1</span>)</span>.snd</span>.toSum</span>, <span class="fn">proof</span> := <span class="fn">q(<span class="fn">⋯</span>)</span> }</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalPow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.Cache"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L859-L865">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Cache</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>This cache contains data required by the <code>ring</code> tactic during execution.</p><ul class="structure_fields" id="Mathlib.Tactic.Ring.Cache.mk"><li id="Mathlib.Tactic.Ring.Cache.rα" class="structure_field"><div class="structure_field_info">rα : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">«$α»</span></span>)</span></span></div><div class="structure_field_doc"><p>A ring instance on <code>α</code>, if available.</p></div></li><li id="Mathlib.Tactic.Ring.Cache.dα" class="structure_field"><div class="structure_field_info">dα : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">«$α»</span></span>)</span></span></div><div class="structure_field_doc"><p>A division ring instance on <code>α</code>, if available.</p></div></li><li id="Mathlib.Tactic.Ring.Cache.czα" class="structure_field"><div class="structure_field_info">czα : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/CharZero/Defs.html#CharZero">CharZero</a> <span class="fn">«$α»</span></span>)</span></span></div><div class="structure_field_doc"><p>A characteristic zero ring instance on <code>α</code>, if available.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Ring.Cache" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.mkCache"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L868-L872">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mkCache"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mkCache</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache">Mathlib.Tactic.Ring.Cache</a> <span class="fn">sα</span>)</span></span></div></div><p>Create a new cache for <code>α</code> by doing the necessary instance searches.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.mkCache" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.cast_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L874-L875">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_pos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat">Mathlib.Meta.NormNum.IsNat</a> <span class="fn">a</span> <span class="fn">n</span></span> → <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">n</span>.rawCast</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.cast_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L877-L878">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat">Mathlib.Meta.NormNum.IsNat</a> <span class="fn">a</span> <span class="fn">0</span></span> → <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.cast_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L880-L882">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_neg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt">Mathlib.Meta.NormNum.IsInt</a> <span class="fn">a</span> <span class="fn">(<a href="../../.././Init/Data/Int/Basic.html#Int.negOfNat">Int.negOfNat</a> <span class="fn">n</span>)</span></span> → <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/Int/Basic.html#Int.negOfNat">Int.negOfNat</a> <span class="fn">n</span>)</span>.rawCast</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.cast_rat"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L884-L886">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_rat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_rat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat">Mathlib.Meta.NormNum.IsRat</a> <span class="fn">a</span> <span class="fn">n</span> <span class="fn">d</span></span> → <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Rat.rawCast">Rat.rawCast</a> <span class="fn">n</span> <span class="fn">d</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalCast"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L895-L907">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result">Mathlib.Meta.NormNum.Result</a> <span class="fn">e</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">e</span>)</span></span></span></div></div><p>Converts a proof by <code><a href="../../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> that <code>e</code> is a numeral, into a normalization as a monomial:</p><ul>
<li><code>e = 0</code> if <code><a href="../../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> returns <code>IsNat e 0</code></li>
<li><code>e = <a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> n + 0</code> if <code><a href="../../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> returns <code>IsNat e n</code></li>
<li><code>e = <a href="../../.././Mathlib/Tactic/NormNum/Result.html#Int.rawCast">Int.rawCast</a> n + 0</code> if <code><a href="../../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> returns <code>IsInt e n</code></li>
<li><code>e = <a href="../../.././Mathlib/Tactic/NormNum/Result.html#Rat.rawCast">Rat.rawCast</a> n d + 0</code> if <code><a href="../../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> returns <code>IsRat e n d</code></li>
</ul><details id="instances-for-list-Mathlib.Tactic.Ring.evalCast" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.toProd_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L909-L910">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.toProd_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">toProd_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.atom_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L911-L911">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.atom_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">atom_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.atom_pf'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L912-L913">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.atom_pf'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">atom_pf'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L920-L927">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalAtom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn">Q(<span class="fn">«$α»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">Mathlib.Tactic.AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">e</span>)</span></span></div></div><p>Evaluates an atom, an expression where <code>ring</code> can find no additional structure.</p><ul>
<li><code>a = a ^ 1 * 1 + 0</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.inv_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L929-L932">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₃ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₃ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a₁</span><a href="../../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a₃</span><a href="../../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₃</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">b₃</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">(<span class="fn"><span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₃</span>)</span><a href="../../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.inv_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L934-L934">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">0</span><a href="../../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.inv_single"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L936-L937">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_single"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_single</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span><a href="../../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span>)</span><a href="../../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.inv_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L938-L940">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">↑<span class="fn">a₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span></span> → <span class="fn"><span class="fn"><span class="fn">↑<span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span></span> → <span class="fn"><span class="fn">↑<span class="fn">(<span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalInvAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L947-L950">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalInvAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalInvAtom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(dα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">Mathlib.Tactic.AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">Mathlib.Tactic.Ring.ExBase</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span><a href="../../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span>)</span>)</span></span></div></div><p>Applies <code>⁻¹</code> to a polynomial to get an atom.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalInvAtom">Mathlib.Tactic.Ring.evalInvAtom</a> <span class="fn">sα</span> <span class="fn">dα</span> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">let <span class="fn">a'</span> := <span class="fn">q(<span class="fn"><span class="fn">«$a»</span><a href="../../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span>)</span>;
  <span class="fn">do
  let <span class="fn">i</span> ← <span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.addAtom">Mathlib.Tactic.AtomM.addAtom</a> <span class="fn">a'</span></span>
  <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">{ <span class="fn">expr</span> := <span class="fn">a'</span>, <span class="fn">val</span> := <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.atom">Mathlib.Tactic.Ring.ExBase.atom</a> <span class="fn">i</span></span>, <span class="fn">proof</span> := <span class="fn">q(<span class="fn">⋯</span>)</span> }</span></span></span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalInvAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.evalInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L957-L975">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalInv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">evalInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(dα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(czα : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/CharZero/Defs.html#CharZero">CharZero</a> <span class="fn">«$α»</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">Mathlib.Tactic.AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">Mathlib.Tactic.Ring.ExProd</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span><a href="../../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span>)</span>)</span></span></div></div><p>Inverts a polynomial <code>va</code> to get a normalized result polynomial.</p><ul>
<li><code>c⁻¹ = (c⁻¹)</code> if <code>c</code> is a constant</li>
<li><code>(a ^ b * c)⁻¹ = a⁻¹ ^ b * c⁻¹</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.ExProd.evalInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExSum.evalInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L982-L991">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalInv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">evalInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(dα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(czα : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/CharZero/Defs.html#CharZero">CharZero</a> <span class="fn">«$α»</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">Mathlib.Tactic.AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span><a href="../../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span>)</span>)</span></span></div></div><p>Inverts a polynomial <code>va</code> to get a normalized result polynomial.</p><ul>
<li><code>0⁻¹ = 0</code></li>
<li><code>a⁻¹ = (a⁻¹)</code> if <code>a</code> is a nontrivial sum</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.ExSum.evalInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.div_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L995-L996">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.div_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">div_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">b</span><a href="../../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalDiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1002-L1006">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalDiv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalDiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(rα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(czα : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/CharZero/Defs.html#CharZero">CharZero</a> <span class="fn">«$α»</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(va : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(vb : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">Mathlib.Tactic.AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn"><span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">«$b»</span></span>)</span>)</span></span></div></div><p>Divides two polynomials <code>va, vb</code> to get a normalized result polynomial.</p><ul>
<li><code>a / b = a * b⁻¹</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalDiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1008-L1009">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b' : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1011-L1012">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b' : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.nsmul_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1014-L1016">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.nsmul_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">nsmul_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b' : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul">•</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1018-L1019">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b' : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.neg_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1021-L1022">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span> → <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.sub_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1024-L1025">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sub_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">sub_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b' : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">b'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.inv_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1027-L1028">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a'</span><a href="../../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span><a href="../../.././Mathlib/Algebra/Group/Defs.html#Inv.inv">⁻¹</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.div_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1030-L1031">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.div_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">div_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b' : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">b'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.Cache.nat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1034-L1034">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Cache</span>.<span class="name">nat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache">Mathlib.Tactic.Ring.Cache</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a></span></div></div><p>A precomputed <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache">Cache</a></code> for <code>ℕ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.nat">Mathlib.Tactic.Ring.Cache.nat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">rα</span> := <span class="fn">none</span>, <span class="fn">dα</span> := <span class="fn">none</span>, <span class="fn">czα</span> := <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">q(<span class="fn">⋯</span>)</span></span> }</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.Cache.nat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.isAtomOrDerivable"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1048-L1063">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.isAtomOrDerivable"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">isAtomOrDerivable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache">Mathlib.Tactic.Ring.Cache</a> <span class="fn">sα</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn">Q(<span class="fn">«$α»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">Mathlib.Tactic.AtomM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">e</span>)</span>)</span>)</span></span></div></div><p>Checks whether <code>e</code> would be processed by <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval">eval</a></code> as a ring expression,
or otherwise if it is an atom or something simplifiable via <code><a href="../../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>.</p><p>We use this in <code>ring_nf</code> to avoid rewriting atoms unnecessarily.</p><p>Returns:</p><ul>
<li><code>none</code> if <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval">eval</a></code> would process <code>e</code> as an algebraic ring expression</li>
<li><code>some none</code> if <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval">eval</a></code> would treat <code>e</code> as an atom.</li>
<li><code>some (some r)</code> if <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval">eval</a></code> would not process <code>e</code> as an algebraic ring expression,
but <code>NormNum.derive</code> can nevertheless simplify <code>e</code>, with result <code>r</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.isAtomOrDerivable" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.eval"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1069-L1128">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache">Mathlib.Tactic.Ring.Cache</a> <span class="fn">sα</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn">Q(<span class="fn">«$α»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">Mathlib.Tactic.AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Mathlib.Tactic.Ring.Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">Mathlib.Tactic.Ring.ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">e</span>)</span></span></div></div><p>Evaluates expression <code>e</code> of type <code>α</code> into a normalized representation as a polynomial.
This is the main driver of <code>ring</code>, which calls out to <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAdd">evalAdd</a></code>, <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul">evalMul</a></code> etc.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.CSLift"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1135-L1139">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">CSLift</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn"><a href="../../.././Init/Prelude.html#outParam">outParam</a> <a href="../../.././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u</div></div><p><code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift">CSLift</a> α β</code> is a typeclass used by <code>ring</code> for lifting operations from <code>α</code>
(which is not a commutative semiring) into a commutative semiring <code>β</code> by using an injective map
<code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">lift</a> : α → β</code>.</p><ul class="structure_fields" id="Mathlib.Tactic.Ring.CSLift.mk"><li id="Mathlib.Tactic.Ring.CSLift.lift" class="structure_field"><div class="structure_field_info">lift : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span></div><div class="structure_field_doc"><p><code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">lift</a></code> is the &quot;canonical injection&quot; from <code>α</code> to <code>β</code></p></div></li><li id="Mathlib.Tactic.Ring.CSLift.inj" class="structure_field"><div class="structure_field_info">inj : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">Mathlib.Tactic.Ring.CSLift.lift</span></span></div><div class="structure_field_doc"><p><code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">lift</a></code> is an injective function</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Mathlib.Tactic.Ring.CSLift" class="instances-list"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.CSLift.inj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1139-L1139">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.inj"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">CSLift</span>.<span class="name">inj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><a href="../../.././Init/Prelude.html#outParam">outParam</a> <a href="../../.././foundational_types.html">(Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift">Mathlib.Tactic.Ring.CSLift</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">Mathlib.Tactic.Ring.CSLift.lift</span></span></div></div><p><code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">lift</a></code> is an injective function</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.CSLiftVal"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1143-L1147">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">CSLiftVal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><a href="../../.././Init/Prelude.html#outParam">outParam</a> <a href="../../.././foundational_types.html">(Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift">Mathlib.Tactic.Ring.CSLift</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><a href="../../.././Init/Prelude.html#outParam">outParam</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal">CSLiftVal</a> a b</code> means that <code>b = <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">lift</a> a</code>. This is used by <code>ring</code> to construct an expression <code>b</code>
from the input expression <code>a</code>, and then run the usual ring algorithm on <code>b</code>.</p><ul class="structure_fields" id="Mathlib.Tactic.Ring.CSLiftVal.mk"><li id="Mathlib.Tactic.Ring.CSLiftVal.eq" class="structure_field"><div class="structure_field_info">eq : <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">Mathlib.Tactic.Ring.CSLift.lift</a> <span class="fn">a</span></span></span></div><div class="structure_field_doc"><p>The output value <code>b</code> is equal to the lift of <code>a</code>. This can be supplied by the default
instance which sets <code>b := <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">lift</a> a</code>, but <code>ring</code> will treat this as an atom so it is more useful
when there are other instances which distribute addition or multiplication.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Mathlib.Tactic.Ring.CSLiftVal" class="instances-list"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.CSLiftVal.eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1147-L1147">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">CSLiftVal</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><a href="../../.././Init/Prelude.html#outParam">outParam</a> <a href="../../.././foundational_types.html">(Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift">Mathlib.Tactic.Ring.CSLift</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn"><a href="../../.././Init/Prelude.html#outParam">outParam</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal">Mathlib.Tactic.Ring.CSLiftVal</a> <span class="fn">a</span> <span class="fn">b</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">Mathlib.Tactic.Ring.CSLift.lift</a> <span class="fn">a</span></span></span></div></div><p>The output value <code>b</code> is equal to the lift of <code>a</code>. This can be supplied by the default
instance which sets <code>b := <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">lift</a> a</code>, but <code>ring</code> will treat this as an atom so it is more useful
when there are other instances which distribute addition or multiplication.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.instCSLiftValLift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1149-L1149">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCSLiftValLift"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instCSLiftValLift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift">Mathlib.Tactic.Ring.CSLift</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal">Mathlib.Tactic.Ring.CSLiftVal</a> <span class="fn">a</span> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">Mathlib.Tactic.Ring.CSLift.lift</a> <span class="fn">a</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">⋯</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.of_lift"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1151-L1153">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.of_lift"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">of_lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift">Mathlib.Tactic.Ring.CSLift</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b' : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h1 : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal">Mathlib.Tactic.Ring.CSLiftVal</a> <span class="fn">a</span> <span class="fn">a'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h2 : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal">Mathlib.Tactic.Ring.CSLiftVal</a> <span class="fn">b</span> <span class="fn">b'</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1157-L1157">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.of_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.ringCleanupRef"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1159-L1164">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ringCleanupRef"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ringCleanupRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/System/IO.html#IO.Ref">IO.Ref</a> <span class="fn">(<a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span></div></div><p>This is a routine which is used to clean up the unsolved subgoal
of a failed <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ring1">ring1</a></code> application. It is overridden in <code>Mathlib.Tactic.Ring.RingNF</code>
to apply the <code>ring_nf</code> simp set to the goal.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.proveEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1167-L1205">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.proveEq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">proveEq</span></a></span><span class="decl_args">
<span class="fn">(g : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">Mathlib.Tactic.AtomM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Frontend of <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ring1">ring1</a></code>: attempt to close a goal <code>g</code>, assuming it is an equation of semirings.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.proveEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.proveEq.ringCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1195-L1205">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.proveEq.ringCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">proveEq</span>.<span class="name">ringCore</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{v : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(sα : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(e₁ : <span class="fn">Q(<span class="fn">«$α»</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(e₂ : <span class="fn">Q(<span class="fn">«$α»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">Mathlib.Tactic.AtomM</a> <span class="fn">Q(<span class="fn"><span class="fn">«$e₁»</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">«$e₂»</span></span>)</span></span></div></div><p>The core of <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.proveEq">proveEq</a></code> takes expressions <code>e₁ e₂ : α</code> where <code>α</code> is a <code><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a></code>,
and returns a proof that they are equal (or fails).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.proveEq.ringCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ring1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1207-L1216">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ring1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ring1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for solving equations of <em>commutative</em> (semi)rings,
allowing variables in the exponent.</p><ul>
<li>This version of <code>ring</code> fails if the target is not an equality.</li>
<li>The variant <code>ring1!</code> will use a more aggressive reducibility setting
to determine equality of atoms.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.ring1" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.tacticRing1!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Ring/Basic.lean#L1218-L1218">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.tacticRing1!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">tacticRing1!</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for solving equations of <em>commutative</em> (semi)rings,
allowing variables in the exponent.</p><ul>
<li>This version of <code>ring</code> fails if the target is not an equality.</li>
<li>The variant <code>ring1!</code> will use a more aggressive reducibility setting
to determine equality of atoms.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.tacticRing1!">Mathlib.Tactic.Ring.tacticRing1!</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.Ring.tacticRing1!</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;ring1!&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.tacticRing1!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>