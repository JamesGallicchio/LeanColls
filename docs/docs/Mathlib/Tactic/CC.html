<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.CC</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.CC";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Tactic/CC/Addition.html">Mathlib.Tactic.CC.Addition</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.CC" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.mkCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">mkCore</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.mkUsingHsCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">mkUsingHsCore</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.rootsCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">rootsCore</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.incGMT"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">incGMT</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.internalize"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">internalize</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.isEqv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">isEqv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.isNotEqv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">isNotEqv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.eqvProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">eqvProof</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.proofFor"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">proofFor</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.refutationFor"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">refutationFor</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.proofForFalse"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">proofForFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.mkUsingHs"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">mkUsingHs</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.roots"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">roots</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.instToMessageData"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">instToMessageData</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.eqcOfCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">eqcOfCore</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.eqcOf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">eqcOf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.eqcSize"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">eqcSize</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.foldEqcCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">foldEqcCore</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.foldEqc"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">foldEqc</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.CCState.foldEqcM"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">foldEqcM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.cc"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">cc</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.CC.elabCCConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">elabCCConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.cc"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">cc</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Congruence-closure">Congruence closure <a class="hover-link" href="#Congruence-closure">#</a></h1><p>The congruence closure tactic <code><a href="../.././Mathlib/Tactic/CC.html#Lean.MVarId.cc">cc</a></code> tries to solve the goal by chaining
equalities from context and applying congruence (i.e. if <code>a = b</code>, then <code>f a = f b</code>).
It is a finishing tactic, i.e. it is meant to close
the current goal, not to make some inconclusive progress.
A mostly trivial example would be:</p><pre><code class="language-lean">example (a b c : ℕ) (f : ℕ → ℕ) (h: a = b) (h' : b = c) : f a = f c := by
  <a href="../.././Mathlib/Tactic/CC.html#Lean.MVarId.cc">cc</a>
</code></pre><p>As an example requiring some thinking to do by hand, consider:</p><pre><code class="language-lean">example (f : ℕ → ℕ) (x : ℕ)
    (H1 : f (f (f x)) = x) (H2 : f (f (f (f (f x)))) = x) :
    f x = x := by
  <a href="../.././Mathlib/Tactic/CC.html#Lean.MVarId.cc">cc</a>
</code></pre><p>The tactic works by building an equality matching graph. It's a graph where
the vertices are terms and they are linked by edges if they are known to
be equal. Once you've added all the equalities in your context, you take
the transitive closure of the graph and, for each connected component
(i.e. equivalence class) you can elect a term that will represent the
whole class and store proofs that the other elements are equal to it.
You then take the transitive closure of these equalities under the
congruence lemmas.</p><p>The <code><a href="../.././Mathlib/Tactic/CC.html#Lean.MVarId.cc">cc</a></code> implementation in Lean does a few more tricks: for example it
derives <code>a = b</code> from <code><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> a = <a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> b</code>, and <code><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> a != <a href="../.././Init/Prelude.html#Nat.zero">Nat.zero</a></code> for any <code>a</code>.</p><ul>
<li><p>The starting reference point is Nelson, Oppen, <a href="http://www.cs.colorado.edu/~bec/courses/csci5535-s09/reading/nelson-oppen-congruence.pdf">Fast decision procedures based on congruence
closure</a>,
Journal of the ACM (1980)</p>
</li>
<li><p>The congruence lemmas for dependent type theory as used in Lean are described in
<a href="https://leanprover.github.io/papers/congr.pdf">Congruence closure in intensional type theory</a>
(de Moura, Selsam IJCAR 2016).</p>
</li>
</ul></div><div class="decl" id="Mathlib.Tactic.CC.CCState.mkCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L63-L65">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.mkCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">mkCore</span></a></span><span class="decl_args">
<span class="fn">(config : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig">Mathlib.Tactic.CC.CCConfig</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a></div></div><p>Make an new <code>CCState</code> from the given <code>config</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.mkCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.mkUsingHsCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L69-L76">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.mkUsingHsCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">mkUsingHsCore</span></a></span><span class="decl_args">
<span class="fn">(config : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig">Mathlib.Tactic.CC.CCConfig</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a></span></div></div><p>Create a congruence closure state object from the given <code>config</code> using the hypotheses in the
current goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.mkUsingHsCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.rootsCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L80-L81">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.rootsCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">rootsCore</span></a></span><span class="decl_args">
<span class="fn">(ccs : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args">
<span class="fn">(nonsingleton : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Returns the root expression for each equivalence class in the graph.
If the <code><a href="../.././Init/Prelude.html#Bool">Bool</a></code> argument is set to <code>true</code> then it only returns roots of non-singleton classes.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">ccs</span>.rootsCore</span> <span class="fn">nonsingleton</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">ccs</span>.getRoots</span> <span class="fn">#[]</span> <span class="fn">nonsingleton</span>)</span>.toList</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.rootsCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.incGMT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L84-L85">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.incGMT"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">incGMT</span></a></span><span class="decl_args">
<span class="fn">(ccs : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a></div></div><p>Increment the Global Modification time.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.incGMT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.internalize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L88-L90">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.internalize"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">internalize</span></a></span><span class="decl_args">
<span class="fn">(ccs : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a></span></div></div><p>Add the given expression to the graph.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.internalize" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.add"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L94-L99">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">add</span></a></span><span class="decl_args">
<span class="fn">(ccs : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args">
<span class="fn">(H : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a></span></div></div><p>Add the given proof term as a new rule.
The proof term <code>H</code> must be an <code><a href="../.././Init/Prelude.html#Eq">Eq</a> _ _</code>, <code><a href="../.././Init/Prelude.html#HEq">HEq</a> _ _</code>, <code><a href="../.././Init/Core.html#Iff">Iff</a> _ _</code>, or a negation of these.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.add" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.isEqv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L102-L104">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.isEqv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">isEqv</span></a></span><span class="decl_args">
<span class="fn">(ccs : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args">
<span class="fn">(e₁ : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(e₂ : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Check whether two expressions are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.isEqv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.isNotEqv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L107-L109">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.isNotEqv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">isNotEqv</span></a></span><span class="decl_args">
<span class="fn">(ccs : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args">
<span class="fn">(e₁ : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(e₂ : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Check whether two expressions are not in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.isNotEqv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.eqvProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L112-L115">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.eqvProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">eqvProof</span></a></span><span class="decl_args">
<span class="fn">(ccs : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args">
<span class="fn">(e₁ : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(e₂ : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Returns a proof term that the given terms are equivalent in the given <code>CCState</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.eqvProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.proofFor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L118-L121">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.proofFor"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">proofFor</span></a></span><span class="decl_args">
<span class="fn">(ccs : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p><code><a href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.proofFor">proofFor</a> <a href="../.././Mathlib/Tactic/CC.html#Lean.MVarId.cc">cc</a> e</code> constructs a proof for e if it is equivalent to true in <code>CCState</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.proofFor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.refutationFor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L125-L128">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.refutationFor"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">refutationFor</span></a></span><span class="decl_args">
<span class="fn">(ccs : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p><code><a href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.refutationFor">refutationFor</a> <a href="../.././Mathlib/Tactic/CC.html#Lean.MVarId.cc">cc</a> e</code> constructs a proof for <code><a href="../.././Init/Prelude.html#Not">Not</a> e</code> if it is equivalent to <code><a href="../.././Init/Prelude.html#False">False</a></code> in <code>CCState</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.refutationFor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.proofForFalse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L131-L134">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.proofForFalse"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">proofForFalse</span></a></span><span class="decl_args">
<span class="fn">(ccs : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>If the given state is inconsistent, return a proof for <code><a href="../.././Init/Prelude.html#False">False</a></code>. Otherwise fail.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.proofForFalse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.mkUsingHs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L137-L138">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.mkUsingHs"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">mkUsingHs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a></span></div></div><p>Create a congruence closure state object using the hypotheses in the current goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.mkUsingHs">Mathlib.Tactic.CC.CCState.mkUsingHs</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.mkUsingHsCore">Mathlib.Tactic.CC.CCState.mkUsingHsCore</a>
    <span class="fn">{ <span class="fn">ignoreInstances</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">ac</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">hoFns</span> := <span class="fn">none</span>, <span class="fn">em</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">values</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a> }</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.mkUsingHs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.roots"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L141-L142">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.roots"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">roots</span></a></span><span class="decl_args">
<span class="fn">(s : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>The root expressions for each equivalence class in the graph.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">s</span>.roots</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">s</span>.rootsCore</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.roots" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.instToMessageData"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L144-L145">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.instToMessageData"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">instToMessageData</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Message.html#Lean.ToMessageData">Lean.ToMessageData</a> <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.instToMessageData">Mathlib.Tactic.CC.CCState.instToMessageData</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">toMessageData</span> := <span class="fn">fun (<span class="fn">s</span> : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>) =&gt; <span class="fn"><span class="fn">s</span>.ppEqcs</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.eqcOfCore"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L149-L151">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.eqcOfCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">eqcOfCore</span></a></span><span class="decl_args">
<span class="fn">(s : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(f : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Continue to append following expressions in the equivalence class of <code>e</code> to <code>r</code> until <code>f</code> is
found.</p></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.eqcOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L154-L155">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.eqcOf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">eqcOf</span></a></span><span class="decl_args">
<span class="fn">(s : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>The equivalence class of <code>e</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.eqcOf</span> <span class="fn">e</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">s</span>.eqcOfCore</span> <span class="fn">e</span> <span class="fn">e</span> <span class="fn">[]</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.eqcOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.eqcSize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L158-L159">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.eqcSize"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">eqcSize</span></a></span><span class="decl_args">
<span class="fn">(s : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Nat">ℕ</a></div></div><p>The size of the equivalence class of <code>e</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.eqcSize</span> <span class="fn">e</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">s</span>.eqcOf</span> <span class="fn">e</span>)</span>.length</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.eqcSize" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.foldEqcCore"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L165-L169">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.foldEqcCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">foldEqcCore</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(first : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(c : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Fold <code>f</code> over the equivalence class of <code>c</code>, accumulating the result in <code>a</code>.
Loops until the element <code>first</code> is encountered.</p><p>See <code><a href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.foldEqc">foldEqc</a></code> for folding <code>f</code> over all elements of the equivalence class.</p></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.foldEqc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L172-L173">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.foldEqc"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">foldEqc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Fold the function of <code>f</code> over the equivalence class of <code>e</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.foldEqc</span> <span class="fn">e</span> <span class="fn">a</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">s</span>.foldEqcCore</span> <span class="fn">f</span> <span class="fn">e</span> <span class="fn">e</span> <span class="fn">a</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.foldEqc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.CCState.foldEqcM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L176-L180">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.CCState.foldEqcM"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">CCState</span>.<span class="name">foldEqcM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../.././foundational_types.html">Type</a> → <a href="../.././foundational_types.html">Type</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCState">Mathlib.Tactic.CC.CCState</a>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>Fold the monadic function of <code>f</code> over the equivalence class of <code>e</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.foldEqcM</span> <span class="fn">e</span> <span class="fn">a</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">s</span>.foldEqc</span> <span class="fn">e</span> <span class="fn">(<a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">a</span>)</span> <span class="fn">fun (<span class="fn">act</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>) (<span class="fn">e</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>) =&gt; <span class="fn">do
    let <span class="fn">a</span> ← <span class="fn">act</span>
    <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">e</span></span></span></span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.CCState.foldEqcM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.cc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L206-L226">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Lean.MVarId.cc"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">cc</span></a></span><span class="decl_args">
<span class="fn">(m : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(cfg : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig">Mathlib.Tactic.CC.CCConfig</a> <span class="fn">{ <span class="fn">ignoreInstances</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">ac</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">hoFns</span> := <span class="fn">none</span>, <span class="fn">em</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">values</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a> }</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Applies congruence closure to solve the given metavariable.
This procedure tries to solve the goal by chaining
equalities from context and applying congruence (i.e. if <code>a = b</code>, then <code>f a = f b</code>).</p><p>The tactic works by building an equality matching graph. It's a graph where
the vertices are terms and they are linked by edges if they are known to
be equal. Once you've added all the equalities in your context, you take
the transitive closure of the graph and, for each connected component
(i.e. equivalence class) you can elect a term that will represent the
whole class and store proofs that the other elements are equal to it.
You then take the transitive closure of these equalities under the
congruence lemmas.
The <code><a href="../.././Mathlib/Tactic/CC.html#Lean.MVarId.cc">cc</a></code> implementation in Lean does a few more tricks: for example it
derives <code>a = b</code> from <code><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> a = <a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> b</code>, and <code><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> a != <a href="../.././Init/Prelude.html#Nat.zero">Nat.zero</a></code> for any <code>a</code>.</p><ul>
<li>The starting reference point is Nelson, Oppen, <a href="http://www.cs.colorado.edu/~bec/courses/csci5535-s09/reading/nelson-oppen-congruence.pdf">Fast decision procedures based on congruence
closure</a>,
Journal of the ACM (1980)</li>
<li>The congruence lemmas for dependent type theory as used in Lean are described in
<a href="https://leanprover.github.io/papers/congr.pdf">Congruence closure in intensional type theory</a>
(de Moura, Selsam IJCAR 2016).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.MVarId.cc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.CC.elabCCConfig"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L228-L231">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.CC.elabCCConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CC</span>.<span class="name">elabCCConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CCConfig">Mathlib.Tactic.CC.CCConfig</a></span></span></div></div><p>Allow elaboration of <code>CCConfig</code> arguments to tactics.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.CC.elabCCConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.cc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/CC.lean#L234-L256">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/CC.html#Mathlib.Tactic.cc"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">cc</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The congruence closure tactic <code><a href="../.././Mathlib/Tactic/CC.html#Lean.MVarId.cc">cc</a></code> tries to solve the goal by chaining
equalities from context and applying congruence (i.e. if <code>a = b</code>, then <code>f a = f b</code>).
It is a finishing tactic, i.e. it is meant to close
the current goal, not to make some inconclusive progress.
A mostly trivial example would be:</p><pre><code class="language-lean">example (a b c : ℕ) (f : ℕ → ℕ) (h: a = b) (h' : b = c) : f a = f c := by
  <a href="../.././Mathlib/Tactic/CC.html#Lean.MVarId.cc">cc</a>
</code></pre><p>As an example requiring some thinking to do by hand, consider:</p><pre><code class="language-lean">example (f : ℕ → ℕ) (x : ℕ)
    (H1 : f (f (f x)) = x) (H2 : f (f (f (f (f x)))) = x) :
    f x = x := by
  <a href="../.././Mathlib/Tactic/CC.html#Lean.MVarId.cc">cc</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.cc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>