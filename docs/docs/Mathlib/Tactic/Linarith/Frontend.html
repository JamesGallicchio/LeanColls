<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.Linarith.Frontend</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.Linarith.Frontend";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">Frontend</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Control/Basic.html">Mathlib.Control.Basic</a></li><li><a href="../../.././Mathlib/Tactic/Linarith/Preprocessing.html">Mathlib.Tactic.Linarith.Preprocessing</a></li><li><a href="../../.././Mathlib/Tactic/Linarith/Verification.html">Mathlib.Tactic.Linarith.Verification</a></li><li><a href="../../.././Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm.html">Mathlib.Tactic.Linarith.Oracle.SimplexAlgorithm</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.Linarith.Frontend" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Linarith.LinarithConfig"><span class="name">Linarith</span>.<span class="name">LinarithConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Linarith.LinarithConfig.updateReducibility"><span class="name">Linarith</span>.<span class="name">LinarithConfig</span>.<span class="name">updateReducibility</span></a></div><div class="nav_link"><a class="break_within" href="#Linarith.getContrLemma"><span class="name">Linarith</span>.<span class="name">getContrLemma</span></a></div><div class="nav_link"><a class="break_within" href="#Linarith.applyContrLemma"><span class="name">Linarith</span>.<span class="name">applyContrLemma</span></a></div><div class="nav_link"><a class="break_within" href="#Linarith.ExprMultiMap"><span class="name">Linarith</span>.<span class="name">ExprMultiMap</span></a></div><div class="nav_link"><a class="break_within" href="#Linarith.ExprMultiMap.find"><span class="name">Linarith</span>.<span class="name">ExprMultiMap</span>.<span class="name">find</span></a></div><div class="nav_link"><a class="break_within" href="#Linarith.ExprMultiMap.insert"><span class="name">Linarith</span>.<span class="name">ExprMultiMap</span>.<span class="name">insert</span></a></div><div class="nav_link"><a class="break_within" href="#Linarith.partitionByType"><span class="name">Linarith</span>.<span class="name">partitionByType</span></a></div><div class="nav_link"><a class="break_within" href="#Linarith.findLinarithContradiction"><span class="name">Linarith</span>.<span class="name">findLinarithContradiction</span></a></div><div class="nav_link"><a class="break_within" href="#Linarith.runLinarith"><span class="name">Linarith</span>.<span class="name">runLinarith</span></a></div><div class="nav_link"><a class="break_within" href="#Linarith.linarith"><span class="name">Linarith</span>.<span class="name">linarith</span></a></div><div class="nav_link"><a class="break_within" href="#linarithArgsRest"><span class="name">linarithArgsRest</span></a></div><div class="nav_link"><a class="break_within" href="#linarith"><span class="name">linarith</span></a></div><div class="nav_link"><a class="break_within" href="#tacticLinarith!_"><span class="name">tacticLinarith!_</span></a></div><div class="nav_link"><a class="break_within" href="#nlinarith"><span class="name">nlinarith</span></a></div><div class="nav_link"><a class="break_within" href="#tacticNlinarith!_"><span class="name">tacticNlinarith!_</span></a></div><div class="nav_link"><a class="break_within" href="#elabLinarithArg"><span class="name">elabLinarithArg</span></a></div><div class="nav_link"><a class="break_within" href="#elabLinarithConfig"><span class="name">elabLinarithConfig</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="linarith-solving-linear-arithmetic-goals"><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code>: solving linear arithmetic goals <a class="hover-link" href="#linarith-solving-linear-arithmetic-goals">#</a></h1><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> is a tactic for solving goals with linear arithmetic.</p><p>Suppose we have a set of hypotheses in <code>n</code> variables
<code>S = {a₁x₁ + a₂x₂ + ... + aₙxₙ R b₁x₁ + b₂x₂ + ... + bₙxₙ}</code>,
where <code>R ∈ {&lt;, ≤, =, ≥, &gt;}</code>.
Our goal is to determine if the inequalities in <code>S</code> are jointly satisfiable, that is, if there is
an assignment of values to <code>x₁, ..., xₙ</code> such that every inequality in <code>S</code> is true.</p><p>Specifically, we aim to show that they are <em>not</em> satisfiable. This amounts to proving a
contradiction. If our goal is also a linear inequality, we negate it and move it to a hypothesis
before trying to prove <code><a href="../../.././Init/Prelude.html#False">False</a></code>.</p><p>When the inequalities are over a dense linear order, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> is a decision procedure: it will
prove <code><a href="../../.././Init/Prelude.html#False">False</a></code> if and only if the inequalities are unsatisfiable. <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> will also run on some
types like <code>ℤ</code> that are not dense orders, but it will fail to prove <code><a href="../../.././Init/Prelude.html#False">False</a></code> on some unsatisfiable
problems. It will run over concrete types like <code>ℕ</code>, <code>ℚ</code>, and <code>ℝ</code>, as well as abstract types that
are instances of <code><a href="../../.././Mathlib/Algebra/Order/Ring/Defs.html#LinearOrderedCommRing">LinearOrderedCommRing</a></code>.</p><h2 class="markdown-heading" id="Algorithm-sketch">Algorithm sketch <a class="hover-link" href="#Algorithm-sketch">#</a></h2><p>First, the inequalities in the set <code>S</code> are rearranged into the form <code>tᵢ Rᵢ 0</code>, where
<code>Rᵢ ∈ {&lt;, ≤, =}</code> and each <code>tᵢ</code> is of the form <code>∑ cⱼxⱼ</code>.</p><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> uses an untrusted oracle to search for a certificate of unsatisfiability.
The oracle searches for a list of natural number coefficients <code>kᵢ</code> such that <code>∑ kᵢtᵢ = 0</code>, where for
at least one <code>i</code>, <code>kᵢ &gt; 0</code> and <code>Rᵢ = &lt;</code>.</p><p>Given a list of such coefficients, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> verifies that <code>∑ kᵢtᵢ = 0</code> using a normalization
tactic such as <code>ring</code>. It proves that <code>∑ kᵢtᵢ &lt; 0</code> by transitivity, since each component of the sum
is either equal to, less than or equal to, or less than zero by hypothesis. This produces a
contradiction.</p><h2 class="markdown-heading" id="Preprocessing">Preprocessing <a class="hover-link" href="#Preprocessing">#</a></h2><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> does some basic preprocessing before running. Most relevantly, inequalities over natural
numbers are cast into inequalities about integers, and rational division by numerals is canceled
into multiplication. We do this so that we can guarantee the coefficients in the certificate are
natural numbers, which allows the tactic to solve goals over types that are not fields.</p><p>Preprocessors are allowed to branch, that is, to case split on disjunctions. <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> will succeed
overall if it succeeds in all cases. This leads to exponential blowup in the number of <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code>
calls, and should be used sparingly. The default preprocessor set does not include case splits.</p><h2 class="markdown-heading" id="Oracles">Oracles <a class="hover-link" href="#Oracles">#</a></h2><p>There are two oracles that can be used in <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> so far.</p><ol>
<li><p><strong>Fourier-Motzkin elimination.</strong>
This technique transforms a set of inequalities in <code>n</code> variables to an equisatisfiable set in
<code>n - 1</code> variables. Once all variables have been eliminated, we conclude that the original set was
unsatisfiable iff the comparison <code>0 &lt; 0</code> is in the resulting set.
While performing this elimination, we track the history of each derived comparison. This allows us
to represent any comparison at any step as a positive combination of comparisons from the original
set. In particular, if we derive <code>0 &lt; 0</code>, we can find our desired list of coefficients
by counting how many copies of each original comparison appear in the history.
This oracle was historically implemented earlier, and is sometimes faster on small states, but it
has <a href="https://github.com/leanprover-community/mathlib4/issues/2717">bugs</a> and can not handle
large problems. You can use it with <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a> (config := { <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.oracle">oracle</a> := .fourierMotzkin })</code>.</p>
</li>
<li><p><strong>Simplex Algorithm (default).</strong>
This oracle reduces the search for a unsatisfiability certificate to some Linear Programming
problem. The problem is then solved by a standard Simplex Algorithm. We use
<a href="https://en.wikipedia.org/wiki/Bland%27s_rule">Bland's pivot rule</a> to guarantee that the algorithm
terminates.
The default version of the algorithm operates with sparse matrices as it is usually faster. You
can invoke the dense version by <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a> (config := { <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.oracle">oracle</a> := .simplexAlgorithmDense })</code>.</p>
</li>
</ol><h2 class="markdown-heading" id="Implementation-details">Implementation details <a class="hover-link" href="#Implementation-details">#</a></h2><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> homogenizes numerical constants: the expression <code>1</code> is treated as a variable <code>t₀</code>.</p><p>Often <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> is called on goals that have comparison hypotheses over multiple types. This
creates multiple <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> problems, each of which is handled separately; the goal is solved as
soon as one problem is found to be contradictory.</p><p>Disequality hypotheses <code>t ≠ 0</code> do not fit in this pattern. <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> will attempt to prove equality
goals by splitting them into two weak inequalities and running twice. But it does not split
disequality hypotheses, since this would lead to a number of runs exponential in the number of
disequalities in the context.</p><p>The oracle is very modular. It can easily be replaced with another function of type
<code><a href="../../.././Init/Prelude.html#List">List</a> Comp → ℕ → MetaM ((Batteries.HashMap ℕ ℕ))</code>,
which takes a list of comparisons and the largest variable
index appearing in those comparisons, and returns a map from comparison indices to coefficients.
An alternate oracle can be specified in the <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig">LinarithConfig</a></code> object.</p><p>A variant, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#nlinarith">nlinarith</a></code>, adds an extra preprocessing step to handle some basic nonlinear goals.
There is a hook in the <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig">LinarithConfig</a></code> configuration object to add custom preprocessing routines.</p><p>The certificate checking step is <em>not</em> by reflection. <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> converts the certificate into a
proof term of type <code><a href="../../.././Init/Prelude.html#False">False</a></code>.</p><p>Some of the behavior of <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> can be inspected with the option
<code>set_option <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">trace.linarith</a> true</code>.
However, both oracles mainly runs outside the tactic monad, so we cannot trace intermediate
steps there.</p><h2 class="markdown-heading" id="File-structure">File structure <a class="hover-link" href="#File-structure">#</a></h2><p>The components of <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> are spread between a number of files for the sake of organization.</p><ul>
<li><code>Lemmas.lean</code> contains proofs of some arithmetic lemmas that are used in preprocessing and in
verification.</li>
<li><code>Datatypes.lean</code> contains data structures that are used across multiple files, along with some
useful auxiliary functions.</li>
<li><code>Preprocessing.lean</code> contains functions used at the beginning of the tactic to transform
hypotheses into a shape suitable for the main routine.</li>
<li><code>Parsing.lean</code> contains functions used to compute the linear structure of an expression.</li>
<li>The <code>Oracle</code> folder contains files implementing the oracles that can be used to produce a
certificate of unsatisfiability.</li>
<li><code>Verification.lean</code> contains the certificate checking functions that produce a proof of <code><a href="../../.././Init/Prelude.html#False">False</a></code>.</li>
<li><code>Frontend.lean</code> contains the control methods and user-facing components of the tactic.</li>
</ul><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>linarith, nlinarith, lra, nra, Fourier-Motzkin, linear arithmetic, linear programming</p></div><div class="mod_doc"><h3 class="markdown-heading" id="Config-objects">Config objects <a class="hover-link" href="#Config-objects">#</a></h3><p>The config object is defined in the frontend, instead of in <code>Datatypes.lean</code>, since the oracles must
be in context to choose a default.</p></div><div class="decl" id="Linarith.LinarithConfig"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L149-L170">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig"><span class="name">Linarith</span>.<span class="name">LinarithConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>A configuration object for <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code>.</p><ul class="structure_fields" id="Linarith.LinarithConfig.mk"><li id="Linarith.LinarithConfig.discharger" class="structure_field"><div class="structure_field_info">discharger : <span class="fn"><a href="../../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">Lean.Elab.Tactic.TacticM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div><div class="structure_field_doc"><p>Discharger to prove that a candidate linear combination of hypothesis is zero.</p></div></li><li id="Linarith.LinarithConfig.exfalso" class="structure_field"><div class="structure_field_info">exfalso : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Prove goals which are not linear comparisons by first calling <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.exfalso">exfalso</a></code>.</p></div></li><li id="Linarith.LinarithConfig.transparency" class="structure_field"><div class="structure_field_info">transparency : <a href="../../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode">Lean.Meta.TransparencyMode</a></div><div class="structure_field_doc"><p>Transparency mode for identifying atomic expressions in comparisons.</p></div></li><li id="Linarith.LinarithConfig.splitHypotheses" class="structure_field"><div class="structure_field_info">splitHypotheses : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Split conjunctions in hypotheses.</p></div></li><li id="Linarith.LinarithConfig.splitNe" class="structure_field"><div class="structure_field_info">splitNe : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Split <code>≠</code> in hypotheses, by branching in cases <code>&lt;</code> and <code>&gt;</code>.</p></div></li><li id="Linarith.LinarithConfig.preprocessors" class="structure_field"><div class="structure_field_info">preprocessors : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor">Linarith.GlobalBranchingPreprocessor</a></span></div><div class="structure_field_doc"><p>Override the list of preprocessors.</p></div></li><li id="Linarith.LinarithConfig.oracle" class="structure_field"><div class="structure_field_info">oracle : <a href="../../.././Mathlib/Tactic/Linarith/Datatypes.html#Linarith.CertificateOracle">Linarith.CertificateOracle</a></div><div class="structure_field_doc"><p>Specify an oracle for identifying candidate contradictions.
<code>.simplexAlgorithmSparse</code>, <code>.simplexAlgorithmSparse</code>, and <code>.fourierMotzkin</code> are available.</p></div></li></ul><details id="instances-for-list-Linarith.LinarithConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Linarith.LinarithConfig.updateReducibility"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L177-L181">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.updateReducibility"><span class="name">Linarith</span>.<span class="name">LinarithConfig</span>.<span class="name">updateReducibility</span></a></span><span class="decl_args">
<span class="fn">(cfg : <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig">Linarith.LinarithConfig</a>)</span></span>
<span class="decl_args">
<span class="fn">(reduce_default : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig">Linarith.LinarithConfig</a></div></div><p><code>cfg.<a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.updateReducibility">updateReducibility</a> reduce_default</code> will change the transparency setting of <code>cfg</code> to
<code>default</code> if <code>reduce_default</code> is true. In this case, it also sets the discharger to <code>ring!</code>,
since this is typically needed when using stronger unification.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Linarith.LinarithConfig.updateReducibility" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Control">Control <a class="hover-link" href="#Control">#</a></h3></div><div class="decl" id="Linarith.getContrLemma"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L194-L209">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.getContrLemma"><span class="name">Linarith</span>.<span class="name">getContrLemma</span></a></span><span class="decl_args">
<span class="fn">(e : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></div></div><p>If <code>e</code> is a comparison <code>a R b</code> or the negation of a comparison <code>¬ a R b</code>, found in the target,
<code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.getContrLemma">getContrLemma</a> e</code> returns the name of a lemma that will change the goal to an
implication, along with the type of <code>a</code> and <code>b</code>.</p><p>For example, if <code>e</code> is <code>(a : ℕ) &lt; b</code>, returns <code>(`lt_of_not_ge, ℕ)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Linarith.getContrLemma" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Linarith.applyContrLemma"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L219-L225">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.applyContrLemma"><span class="name">Linarith</span>.<span class="name">applyContrLemma</span></a></span><span class="decl_args">
<span class="fn">(g : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span></div></div><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.applyContrLemma">applyContrLemma</a></code> inspects the target to see if it can be moved to a hypothesis by negation.
For example, a goal <code>⊢ a ≤ b</code> can become <code>a &gt; b ⊢ false</code>.
If this is the case, it applies the appropriate lemma and introduces the new hypothesis.
It returns the type of the terms in the comparison (e.g. the type of <code>a</code> and <code>b</code> above) and the
newly introduced local constant.
Otherwise returns <code>none</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Linarith.applyContrLemma" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Linarith.ExprMultiMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L229-L229">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap"><span class="name">Linarith</span>.<span class="name">ExprMultiMap</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u_1</div></div><p>A map of keys to values, where the keys are <code>Expr</code> up to defeq and one key can be
associated to multiple values.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap">Linarith.ExprMultiMap</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">(<a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Linarith.ExprMultiMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Linarith.ExprMultiMap.find"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L233-L238">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap.find"><span class="name">Linarith</span>.<span class="name">ExprMultiMap</span>.<span class="name">find</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap">Linarith.ExprMultiMap</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(k : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Nat">ℕ</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span></div></div><p>Retrieves the list of values at a key, as well as the index of the key for later modification.
(If the key is not in the map it returns <code>self.size</code> as the index.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Linarith.ExprMultiMap.find" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Linarith.ExprMultiMap.insert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L242-L247">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap.insert"><span class="name">Linarith</span>.<span class="name">ExprMultiMap</span>.<span class="name">insert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap">Linarith.ExprMultiMap</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(k : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(v : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap">Linarith.ExprMultiMap</a> <span class="fn">α</span>)</span></span></div></div><p>Insert a new value into the map at key <code>k</code>. This does a defeq check with all other keys
in the map.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Linarith.ExprMultiMap.insert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Linarith.partitionByType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L254-L255">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.partitionByType"><span class="name">Linarith</span>.<span class="name">partitionByType</span></a></span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap">Linarith.ExprMultiMap</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></div></div><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.partitionByType">partitionByType</a> l</code> takes a list <code>l</code> of proofs of comparisons. It sorts these proofs by
the type of the variables in the comparison, e.g. <code>(a : ℚ) &lt; 1</code> and <code>(b : ℤ) &gt; c</code> will be separated.
Returns a map from a type to a list of comparisons over that type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.partitionByType">Linarith.partitionByType</a> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Data/List/Control.html#List.foldlM">List.foldlM</a>
    <span class="fn">(fun (<span class="fn">m</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap">Linarith.ExprMultiMap</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>) (<span class="fn">h</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>) =&gt; <span class="fn">do
      let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../.././Mathlib/Tactic/Linarith/Verification.html#Linarith.typeOfIneqProof">Linarith.typeOfIneqProof</a> <span class="fn">h</span></span>
      <span class="fn"><span class="fn"><span class="fn">m</span>.insert</span> <span class="fn">__do_lift</span> <span class="fn">h</span></span></span>)</span>
    <span class="fn">#[]</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Linarith.partitionByType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Linarith.findLinarithContradiction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L262-L266">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.findLinarithContradiction"><span class="name">Linarith</span>.<span class="name">findLinarithContradiction</span></a></span><span class="decl_args">
<span class="fn">(cfg : <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig">Linarith.LinarithConfig</a>)</span></span>
<span class="decl_args">
<span class="fn">(g : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(ls : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Given a list <code>ls</code> of lists of proofs of comparisons, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.findLinarithContradiction">findLinarithContradiction</a> cfg ls</code> will try to
prove <code><a href="../../.././Init/Prelude.html#False">False</a></code> by calling <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> on each list in succession. It will stop at the first proof of
<code><a href="../../.././Init/Prelude.html#False">False</a></code>, and fail if no contradiction is found with any list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Linarith.findLinarithContradiction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Linarith.runLinarith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L280-L301">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.runLinarith"><span class="name">Linarith</span>.<span class="name">runLinarith</span></a></span><span class="decl_args">
<span class="fn">(cfg : <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig">Linarith.LinarithConfig</a>)</span></span>
<span class="decl_args">
<span class="fn">(prefType : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(hyps : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Given a list <code>hyps</code> of proofs of comparisons, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.runLinarith">runLinarith</a> cfg hyps prefType</code>
preprocesses <code>hyps</code> according to the list of preprocessors in <code>cfg</code>.
This results in a list of branches (typically only one),
each of which must succeed in order to close the goal.</p><p>In each branch, we partition the list of hypotheses by type, and run <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> on each class
in the partition; one of these must succeed in order for <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> to succeed on this branch.
If <code>prefType</code> is given, it will first use the class of proofs of comparisons over that type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Linarith.runLinarith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Linarith.linarith"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L324-L361">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.linarith"><span class="name">Linarith</span>.<span class="name">linarith</span></a></span><span class="decl_args">
<span class="fn">(only_on : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(hyps : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(cfg : <span class="fn"><a href="../../.././Init/Prelude.html#optParam">optParam</a> <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig">Linarith.LinarithConfig</a>
  <span class="fn">{
    <span class="fn">discharger</span> := <span class="fn">do
      let <span class="fn">__do_lift</span> ←
        <span class="fn">do
          let <span class="fn">info</span> ← <span class="fn">Lean.MonadRef.mkInfoFromRefPos</span>
          let _ ← <span class="fn">Lean.getCurrMacroScope</span>
          let _ ← <span class="fn">Lean.getMainModule</span>
          <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a>
              <span class="fn">{
                <span class="fn">raw</span> :=
                  <span class="fn"><a href="../../.././Init/Prelude.html#Lean.Syntax.node2">Lean.Syntax.node2</a> <span class="fn">info</span> <span class="fn">`Mathlib.Tactic.Ring.ring1</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.Syntax.atom">Lean.Syntax.atom</a> <span class="fn">info</span> <span class="fn">&quot;ring1&quot;</span>)</span>
                    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">`null</span> <span class="fn">#[]</span>)</span></span> }</span></span></span>
      <span class="fn"><a href="../../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.evalTactic">Lean.Elab.Tactic.evalTactic</a> <span class="fn"><span class="fn">__do_lift</span>.raw</span></span></span>,
    <span class="fn">exfalso</span> := <a href="../../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">transparency</span> := <a href="../../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.reducible">Lean.Meta.TransparencyMode.reducible</a>, <span class="fn">splitHypotheses</span> := <a href="../../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">splitNe</span> := <a href="../../.././Init/Prelude.html#Bool.false">false</a>,
    <span class="fn">preprocessors</span> := <a href="../../.././Mathlib/Tactic/Linarith/Preprocessing.html#Linarith.defaultPreprocessors">Linarith.defaultPreprocessors</a>, <span class="fn">oracle</span> := <a href="../../.././Mathlib/Tactic/Linarith/Oracle/SimplexAlgorithm.html#Linarith.CertificateOracle.simplexAlgorithmSparse">Linarith.CertificateOracle.simplexAlgorithmSparse</a> }</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a> only_on hyps cfg</code> tries to close the goal using linear arithmetic. It fails
if it does not succeed at doing this.</p><ul>
<li><code>hyps</code> is a list of proofs of comparisons to include in the search.</li>
<li>If <code>only_on</code> is true, the search will be restricted to <code>hyps</code>. Otherwise it will use all
comparisons in the local context.</li>
<li>If <code>cfg.<a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.transparency">transparency</a> := semireducible</code>,
it will unfold semireducible definitions when trying to match atomic expressions.</li>
</ul></div></div><div class="mod_doc"><h3 class="markdown-heading" id="User-facing-functions">User facing functions <a class="hover-link" href="#User-facing-functions">#</a></h3></div><div class="decl" id="linarithArgsRest"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L369-L370">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarithArgsRest"><span class="name">linarithArgsRest</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Syntax for the arguments of <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code>, after the optional <code>!</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-linarithArgsRest" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="linarith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L372-L430">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith"><span class="name">linarith</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> attempts to find a contradiction between hypotheses that are linear (in)equalities.
Equivalently, it can prove a linear inequality by assuming its negation and proving <code><a href="../../.././Init/Prelude.html#False">False</a></code>.</p><p>In theory, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> should prove any goal that is true in the theory of linear arithmetic over
the rationals. While there is some special handling for non-dense orders like <code><a href="../../.././Init/Prelude.html#Nat">Nat</a></code> and <code><a href="../../.././Init/Data/Int/Basic.html#Int">Int</a></code>,
this tactic is not complete for these theories and will not prove every true goal. It will solve
goals over arbitrary types that instantiate <code><a href="../../.././Mathlib/Algebra/Order/Ring/Defs.html#LinearOrderedCommRing">LinearOrderedCommRing</a></code>.</p><p>An example:</p><pre><code class="language-lean">example (x y z : ℚ) (h1 : 2*x &lt; 3*y) (h2 : -4*x + 2*z &lt; 0)
        (h3 : 12*y - 4* z &lt; 0) : <a href="../../.././Init/Prelude.html#False">False</a> := by
  <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a>
</code></pre><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> will use all appropriate hypotheses and the negation of the goal, if applicable.
Disequality hypotheses require case splitting and are not normally considered
(see the <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.splitNe">splitNe</a></code> option below).</p><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a> [t1, t2, t3]</code> will additionally use proof terms <code>t1, t2, t3</code>.</p><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a> only [h1, h2, h3, t1, t2, t3]</code> will use only the goal (if relevant), local hypotheses
<code>h1</code>, <code>h2</code>, <code>h3</code>, and proofs <code>t1</code>, <code>t2</code>, <code>t3</code>. It will ignore the rest of the local context.</p><p><code>linarith!</code> will use a stronger reducibility setting to try to identify atoms. For example,</p><pre><code class="language-lean">example (x : ℚ) : <a href="../../.././Init/Prelude.html#id">id</a> x ≥ x := by
  <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a>
</code></pre><p>will fail, because <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> will not identify <code>x</code> and <code><a href="../../.././Init/Prelude.html#id">id</a> x</code>. <code>linarith!</code> will.
This can sometimes be expensive.</p><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a> (config := { .. })</code> takes a config object with five
optional arguments:</p><ul>
<li><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.discharger">discharger</a></code> specifies a tactic to be used for reducing an algebraic equation in the
proof stage. The default is <code>ring</code>. Other options include <code>simp</code> for basic
problems.</li>
<li><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.transparency">transparency</a></code> controls how hard <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> will try to match atoms to each other. By default
it will only unfold <code>reducible</code> definitions.</li>
<li>If <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.splitHypotheses">splitHypotheses</a></code> is true, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> will split conjunctions in the context into separate
hypotheses.</li>
<li>If <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.splitNe">splitNe</a></code> is <code>true</code>, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> will case split on disequality hypotheses.
For a given <code>x ≠ y</code> hypothesis, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> is run with both <code>x &lt; y</code> and <code>x &gt; y</code>,
and so this runs linarith exponentially many times with respect to the number of
disequality hypotheses. (<code>false</code> by default.)</li>
<li>If <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.exfalso">exfalso</a></code> is <code>false</code>, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> will fail when the goal is neither an inequality nor <code><a href="../../.././Init/Prelude.html#False">False</a></code>.
(<code>true</code> by default.)</li>
<li><code>restrict_type</code> (not yet implemented in mathlib4)
will only use hypotheses that are inequalities over <code>tp</code>. This is useful
if you have e.g. both integer and rational valued inequalities in the local context, which can
sometimes confuse the tactic.</li>
</ul><p>A variant, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#nlinarith">nlinarith</a></code>, does some basic preprocessing to handle some nonlinear goals.</p><p>The option <code>set_option <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">trace.linarith</a> true</code> will trace certain intermediate stages of the <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code>
routine.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-linarith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="tacticLinarith!_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L432-L433">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#tacticLinarith!_"><span class="name">tacticLinarith!_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> attempts to find a contradiction between hypotheses that are linear (in)equalities.
Equivalently, it can prove a linear inequality by assuming its negation and proving <code><a href="../../.././Init/Prelude.html#False">False</a></code>.</p><p>In theory, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> should prove any goal that is true in the theory of linear arithmetic over
the rationals. While there is some special handling for non-dense orders like <code><a href="../../.././Init/Prelude.html#Nat">Nat</a></code> and <code><a href="../../.././Init/Data/Int/Basic.html#Int">Int</a></code>,
this tactic is not complete for these theories and will not prove every true goal. It will solve
goals over arbitrary types that instantiate <code><a href="../../.././Mathlib/Algebra/Order/Ring/Defs.html#LinearOrderedCommRing">LinearOrderedCommRing</a></code>.</p><p>An example:</p><pre><code class="language-lean">example (x y z : ℚ) (h1 : 2*x &lt; 3*y) (h2 : -4*x + 2*z &lt; 0)
        (h3 : 12*y - 4* z &lt; 0) : <a href="../../.././Init/Prelude.html#False">False</a> := by
  <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a>
</code></pre><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> will use all appropriate hypotheses and the negation of the goal, if applicable.
Disequality hypotheses require case splitting and are not normally considered
(see the <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.splitNe">splitNe</a></code> option below).</p><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a> [t1, t2, t3]</code> will additionally use proof terms <code>t1, t2, t3</code>.</p><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a> only [h1, h2, h3, t1, t2, t3]</code> will use only the goal (if relevant), local hypotheses
<code>h1</code>, <code>h2</code>, <code>h3</code>, and proofs <code>t1</code>, <code>t2</code>, <code>t3</code>. It will ignore the rest of the local context.</p><p><code>linarith!</code> will use a stronger reducibility setting to try to identify atoms. For example,</p><pre><code class="language-lean">example (x : ℚ) : <a href="../../.././Init/Prelude.html#id">id</a> x ≥ x := by
  <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a>
</code></pre><p>will fail, because <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> will not identify <code>x</code> and <code><a href="../../.././Init/Prelude.html#id">id</a> x</code>. <code>linarith!</code> will.
This can sometimes be expensive.</p><p><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a> (config := { .. })</code> takes a config object with five
optional arguments:</p><ul>
<li><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.discharger">discharger</a></code> specifies a tactic to be used for reducing an algebraic equation in the
proof stage. The default is <code>ring</code>. Other options include <code>simp</code> for basic
problems.</li>
<li><code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.transparency">transparency</a></code> controls how hard <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> will try to match atoms to each other. By default
it will only unfold <code>reducible</code> definitions.</li>
<li>If <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.splitHypotheses">splitHypotheses</a></code> is true, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> will split conjunctions in the context into separate
hypotheses.</li>
<li>If <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.splitNe">splitNe</a></code> is <code>true</code>, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> will case split on disequality hypotheses.
For a given <code>x ≠ y</code> hypothesis, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> is run with both <code>x &lt; y</code> and <code>x &gt; y</code>,
and so this runs linarith exponentially many times with respect to the number of
disequality hypotheses. (<code>false</code> by default.)</li>
<li>If <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig.exfalso">exfalso</a></code> is <code>false</code>, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> will fail when the goal is neither an inequality nor <code><a href="../../.././Init/Prelude.html#False">False</a></code>.
(<code>true</code> by default.)</li>
<li><code>restrict_type</code> (not yet implemented in mathlib4)
will only use hypotheses that are inequalities over <code>tp</code>. This is useful
if you have e.g. both integer and rational valued inequalities in the local context, which can
sometimes confuse the tactic.</li>
</ul><p>A variant, <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#nlinarith">nlinarith</a></code>, does some basic preprocessing to handle some nonlinear goals.</p><p>The option <code>set_option <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">trace.linarith</a> true</code> will trace certain intermediate stages of the <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code>
routine.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#tacticLinarith!_">tacticLinarith!_</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`tacticLinarith!_</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;linarith!&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span> <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarithArgsRest">linarithArgsRest</a>)</span></span></span></li></ul></details><details id="instances-for-list-tacticLinarith!_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="nlinarith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L435-L447">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#nlinarith"><span class="name">nlinarith</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>An extension of <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> with some preprocessing to allow it to solve some nonlinear arithmetic
problems. (Based on Coq's <code>nra</code> tactic.) See <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> for the available syntax of options,
which are inherited by <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#nlinarith">nlinarith</a></code>; that is, <code>nlinarith!</code> and <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#nlinarith">nlinarith</a> only [h1, h2]</code> all work as
in <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code>. The preprocessing is as follows:</p><ul>
<li>For every subterm <code>a ^ 2</code> or <code>a * a</code> in a hypothesis or the goal,
the assumption <code>0 ≤ a ^ 2</code> or <code>0 ≤ a * a</code> is added to the context.</li>
<li>For every pair of hypotheses <code>a1 R1 b1</code>, <code>a2 R2 b2</code> in the context, <code>R1, R2 ∈ {&lt;, ≤, =}</code>,
the assumption <code>0 R' (b1 - a1) * (b2 - a2)</code> is added to the context (non-recursively),
where <code>R ∈ {&lt;, ≤, =}</code> is the appropriate comparison derived from <code>R1, R2</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-nlinarith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="tacticNlinarith!_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L448-L449">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#tacticNlinarith!_"><span class="name">tacticNlinarith!_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>An extension of <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> with some preprocessing to allow it to solve some nonlinear arithmetic
problems. (Based on Coq's <code>nra</code> tactic.) See <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code> for the available syntax of options,
which are inherited by <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#nlinarith">nlinarith</a></code>; that is, <code>nlinarith!</code> and <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#nlinarith">nlinarith</a> only [h1, h2]</code> all work as
in <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarith">linarith</a></code>. The preprocessing is as follows:</p><ul>
<li>For every subterm <code>a ^ 2</code> or <code>a * a</code> in a hypothesis or the goal,
the assumption <code>0 ≤ a ^ 2</code> or <code>0 ≤ a * a</code> is added to the context.</li>
<li>For every pair of hypotheses <code>a1 R1 b1</code>, <code>a2 R2 b2</code> in the context, <code>R1, R2 ∈ {&lt;, ≤, =}</code>,
the assumption <code>0 R' (b1 - a1) * (b2 - a2)</code> is added to the context (non-recursively),
where <code>R ∈ {&lt;, ≤, =}</code> is the appropriate comparison derived from <code>R1, R2</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#tacticNlinarith!_">tacticNlinarith!_</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`tacticNlinarith!_</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;nlinarith!&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span> <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#linarithArgsRest">linarithArgsRest</a>)</span></span></span></li></ul></details><details id="instances-for-list-tacticNlinarith!_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="elabLinarithArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L452-L456">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#elabLinarithArg"><span class="name">elabLinarithArg</span></a></span><span class="decl_args">
<span class="fn">(tactic : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(t : <a href="../../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">Lean.Elab.Tactic.TacticM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Elaborate <code>t</code> in a way that is suitable for linarith.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-elabLinarithArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="elabLinarithConfig"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/Linarith/Frontend.lean#L458-L461">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Linarith/Frontend.html#elabLinarithConfig"><span class="name">elabLinarithConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><a href="../../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig">Linarith.LinarithConfig</a></span></span></div></div><p>Allow elaboration of <code><a href="../../.././Mathlib/Tactic/Linarith/Frontend.html#Linarith.LinarithConfig">LinarithConfig</a></code> arguments to tactics.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-elabLinarithConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>