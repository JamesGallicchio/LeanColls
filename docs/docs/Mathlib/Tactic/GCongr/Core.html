<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.GCongr.Core</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.GCongr.Core";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">Core</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Batteries/Lean/Except.html">Batteries.Lean.Except</a></li><li><a href="../../.././Batteries/Tactic/Exact.html">Batteries.Tactic.Exact</a></li><li><a href="../../.././Mathlib/Order/Defs.html">Mathlib.Order.Defs</a></li><li><a href="../../.././Mathlib/Tactic/Core.html">Mathlib.Tactic.Core</a></li><li><a href="../../.././Mathlib/Tactic/GCongr/ForwardAttr.html">Mathlib.Tactic.GCongr.ForwardAttr</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.GCongr.Core" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.GCongr.GCongrLemma"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">GCongrLemma</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.GCongr.instInhabitedGCongrLemma"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">instInhabitedGCongrLemma</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.GCongr.instReprGCongrLemma"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">instReprGCongrLemma</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.GCongr.gcongrExt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">gcongrExt</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.GCongr.tacticGcongr_discharger"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">tacticGcongr_discharger</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.GCongr.gcongrDischarger"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">gcongrDischarger</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.GCongr.exactRefl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">exactRefl</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.GCongr.exactLeOfLt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">exactLeOfLt</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.GCongr.symmExact"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">symmExact</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.GCongr.exact"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">exact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.gcongrForward"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">gcongrForward</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.GCongr.gcongrForwardDischarger"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">gcongrForwardDischarger</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.gcongr"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">gcongr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.GCongr.tacticGcongr__With__"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">tacticGcongr__With__</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.GCongr.«tacticRel[_]»"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">«tacticRel[_]»</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="The-gcongr-generalized-congruence-tactic">The <code><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr">gcongr</a></code> (&quot;generalized congruence&quot;) tactic <a class="hover-link" href="#The-gcongr-generalized-congruence-tactic">#</a></h1><p>The <code><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr">gcongr</a></code> tactic applies &quot;generalized congruence&quot; rules, reducing a relational goal
between a LHS and RHS matching the same pattern to relational subgoals between the differing
inputs to the pattern.  For example,</p><pre><code>example {a b x c d : ℝ} (h1 : a + 1 ≤ b + 1) (h2 : c + 2 ≤ d + 2) :
    x ^ 2 * a + c ≤ x ^ 2 * b + d := by
  <a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr">gcongr</a>
  · linarith
  · linarith
</code></pre><p>This example has the goal of proving the relation <code>≤</code> between a LHS and RHS both of the pattern</p><pre><code>x ^ 2 * ?_ + ?_
</code></pre><p>(with inputs <code>a</code>, <code>c</code> on the left and <code>b</code>, <code>d</code> on the right); after the use of
<code><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr">gcongr</a></code>, we have the simpler goals <code>a ≤ b</code> and <code>c ≤ d</code>.</p><p>A pattern can be provided explicitly; this is useful if a non-maximal match is desired:</p><pre><code>example {a b c d x : ℝ} (h : a + c + 1 ≤ b + d + 1) :
    x ^ 2 * (a + c) + 5 ≤ x ^ 2 * (b + d) + 5 := by
  <a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr">gcongr</a> x ^ 2 * ?_ + 5
  linarith
</code></pre><h2 class="markdown-heading" id="Sourcing-the-generalized-congruence-lemmas">Sourcing the generalized congruence lemmas <a class="hover-link" href="#Sourcing-the-generalized-congruence-lemmas">#</a></h2><p>Relevant &quot;generalized congruence&quot; lemmas are declared using the attribute <code>@[gcongr]</code>.  For
example, the first example constructs the proof term</p><pre><code>add_le_add (mul_le_mul_of_nonneg_left _ (pow_bit0_nonneg x 1)) _
</code></pre><p>using the generalized congruence lemmas <code>add_le_add</code> and <code>mul_le_mul_of_nonneg_left</code>. The term
<code>pow_bit0_nonneg x 1</code> is automatically generated by a discharger (see below).</p><p>When a lemma is tagged <code>@[gcongr]</code>, it is verified that that lemma is of &quot;generalized congruence&quot;
form, <code>f x₁ y z₁ ∼ f x₂ y z₂</code>, that is, a relation between the application of a function to two
argument lists, in which the &quot;varying argument&quot; pairs (here <code>x₁</code>/<code>x₂</code> and <code>z₁</code>/<code>z₂</code>) are all free
variables. The &quot;varying&quot;/non-&quot;varying&quot; classification of the arguments is recorded (as an array of
booleans), and the <code><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr">gcongr</a></code> tactic will try a lemma only if it matches the goal in relation <code>∼</code>,
head function <code>f</code> and &quot;varying&quot;/non-&quot;varying&quot; classification for each of the inputs to <code>f</code>.  Thus,
for example, all three of the following lemmas are tagged <code>@[gcongr]</code> and are used in different
situations according to whether the goal compares constant-left-multiplications,
constant-right-multiplications, or fully varying multiplications:</p><pre><code>theorem mul_le_mul_of_nonneg_left [Mul α] [Zero α] [Preorder α] [PosMulMono α]
    {a b c : α} (h : b ≤ c) (a0 : 0 ≤ a) :
    a * b ≤ a * c

theorem mul_le_mul_of_nonneg_right [Mul α] [Zero α] [Preorder α] [MulPosMono α]
    {a b c : α} (h : b ≤ c) (a0 : 0 ≤ a) :
    b * a ≤ c * a

theorem mul_le_mul [MulZeroClass α] [Preorder α] [PosMulMono α] [MulPosMono α]
    {a b c d : α} (h₁ : a ≤ b) (h₂ : c ≤ d) (c0 : 0 ≤ c) (b0 : 0 ≤ b) :
    a * c ≤ b * d
</code></pre><p>The advantage of this approach is that the lemmas with fewer &quot;varying&quot; input pairs typically require
fewer side conditions, so the tactic becomes more useful by special-casing them.</p><p>There can also be more than one generalized congruence lemma dealing with the same relation, head
function and &quot;varying&quot;/non-&quot;varying&quot; configuration, for example with purely notational head
functions which have different theories when different typeclass assumptions apply.  For example,
the following lemma is stored with the same <code>@[gcongr]</code> data as <code>mul_le_mul</code> above, and the two
lemmas are simply tried in succession to determine which has the typeclasses relevant to the goal:</p><pre><code>theorem mul_le_mul' [Mul α] [Preorder α] [CovariantClass α α (· * ·) (· ≤ ·)]
    [CovariantClass α α (Function.swap (· * ·)) (· ≤ ·)] {a b c d : α} (h₁ : a ≤ b) (h₂ : c ≤ d) :
    a * c ≤ b * d
</code></pre><h2 class="markdown-heading" id="Resolving-goals">Resolving goals <a class="hover-link" href="#Resolving-goals">#</a></h2><p>The tactic attempts to discharge side goals to the &quot;generalized congruence&quot; lemmas (such as the
side goal <code>0 ≤ x ^ 2</code> in the above application of <code>mul_le_mul_of_nonneg_left</code>) using the tactic
<code>gcongr_discharger</code>, which wraps <code>positivity</code> but can also be extended. Side goals not discharged
in this way are left for the user.</p><p>The tactic also attempts to discharge &quot;main&quot; goals using the available hypotheses, as well as a
limited amount of forward reasoning.  Such attempts are made <em>before</em> descending further into
matching by congruence. The built-in forward-reasoning includes reasoning by symmetry and
reflexivity, and this can be extended by writing tactic extensions tagged with the
<code>@[gcongr_forward]</code> attribute.</p><h2 class="markdown-heading" id="Introducing-variables-and-hypotheses">Introducing variables and hypotheses <a class="hover-link" href="#Introducing-variables-and-hypotheses">#</a></h2><p>Some natural generalized congruence lemmas have &quot;main&quot; hypotheses which are universally quantified
or have the structure of an implication, for example</p><pre><code>theorem GCongr.Finset.sum_le_sum [OrderedAddCommMonoid N] {f g : ι → N} {s : Finset ι}
    (h : ∀ (i : ι), i ∈ s → f i ≤ g i) :
    s.sum f ≤ s.sum g
</code></pre><p>The tactic automatically introduces the variable <code>i✝ : ι</code> and hypothesis <code>hi✝ : i✝ ∈ s</code> in the
subgoal <code>∀ (i : ι), i ∈ s → f i ≤ g i</code> generated by applying this lemma.  By default this is done
anonymously, so they are inaccessible in the goal state which results.  The user can name them if
needed using the syntax <code><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr">gcongr</a> with i hi</code>.</p><h2 class="markdown-heading" id="Variants">Variants <a class="hover-link" href="#Variants">#</a></h2><p>The tactic <code>rel</code> is a variant of <code><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr">gcongr</a></code>, intended for teaching.  Local hypotheses are not
used automatically to resolve main goals, but must be invoked by name:</p><pre><code>example {a b x c d : ℝ} (h1 : a ≤ b) (h2 : c ≤ d) :
    x ^ 2 * a + c ≤ x ^ 2 * b + d := by
  rel [h1, h2]
</code></pre><p>The <code>rel</code> tactic is finishing-only: if fails if any main or side goals are not resolved.</p></div><div class="decl" id="Mathlib.Tactic.GCongr.GCongrLemma"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean#L129-L133">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">GCongrLemma</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>Structure recording the data for a &quot;generalized congruence&quot; (<code><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr">gcongr</a></code>) lemma.</p><ul class="structure_fields" id="Mathlib.Tactic.GCongr.GCongrLemma.mk"><li id="Mathlib.Tactic.GCongr.GCongrLemma.declName" class="structure_field"><div class="structure_field_info">declName : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a></div></li><li id="Mathlib.Tactic.GCongr.GCongrLemma.mainSubgoals" class="structure_field"><div class="structure_field_info">mainSubgoals : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Nat">Nat</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Init/Prelude.html#Nat">Nat</a>)</span></span></div></li><li id="Mathlib.Tactic.GCongr.GCongrLemma.varyingArgs" class="structure_field"><div class="structure_field_info">varyingArgs : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></li></ul><details id="instances-for-list-Mathlib.Tactic.GCongr.GCongrLemma" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.GCongr.instInhabitedGCongrLemma"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean#L133-L133">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instInhabitedGCongrLemma"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">instInhabitedGCongrLemma</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma">Mathlib.Tactic.GCongr.GCongrLemma</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instInhabitedGCongrLemma">Mathlib.Tactic.GCongr.instInhabitedGCongrLemma</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">declName</span> := <span class="fn">default</span>, <span class="fn">mainSubgoals</span> := <span class="fn">default</span>, <span class="fn">varyingArgs</span> := <span class="fn">default</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.GCongr.instReprGCongrLemma"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean#L133-L133">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instReprGCongrLemma"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">instReprGCongrLemma</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <a href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma">Mathlib.Tactic.GCongr.GCongrLemma</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.instReprGCongrLemma">Mathlib.Tactic.GCongr.instReprGCongrLemma</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">reprPrec</span> := <a href="../../.././Mathlib/Tactic/GCongr/Core.html#_private.Mathlib.Tactic.GCongr.Core.0.Mathlib.Tactic.GCongr.reprGCongrLemma._@.Mathlib.Tactic.GCongr.Core._hyg.53">Mathlib.Tactic.GCongr.reprGCongrLemma✝</a> }</span></span></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.GCongr.gcongrExt"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean#L135-L141">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.gcongrExt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">gcongrExt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/ScopedEnvExtension.html#Lean.SimpleScopedEnvExtension">Lean.SimpleScopedEnvExtension</a> <span class="fn">(<span class="fn">(<a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma">Mathlib.Tactic.GCongr.GCongrLemma</a>)</span>
  <span class="fn">(<a href="../../.././Lean/Data/HashMap.html#Lean.HashMap">Lean.HashMap</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.GCongrLemma">Mathlib.Tactic.GCongr.GCongrLemma</a>)</span>)</span></span></div></div><p>Environment extension for &quot;generalized congruence&quot; (<code><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr">gcongr</a></code>) lemmas.</p></div></div><div class="decl" id="Mathlib.Tactic.GCongr.tacticGcongr_discharger"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean#L221-L221">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.tacticGcongr_discharger"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">tacticGcongr_discharger</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.tacticGcongr_discharger">Mathlib.Tactic.GCongr.tacticGcongr_discharger</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.GCongr.tacticGcongr_discharger</span> <span class="fn">1024</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;gcongr_discharger&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.GCongr.tacticGcongr_discharger" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.GCongr.gcongrDischarger"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean#L227-L231">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.gcongrDischarger"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">gcongrDischarger</span></a></span><span class="decl_args">
<span class="fn">(goal : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>This is used as the default side-goal discharger,
it calls the <code>gcongr_discharger</code> extensible tactic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.GCongr.gcongrDischarger" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.GCongr.exactRefl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean#L236-L240">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.exactRefl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">exactRefl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Tactic/GCongr/ForwardAttr.html#Mathlib.Tactic.GCongr.ForwardExt">Mathlib.Tactic.GCongr.ForwardExt</a></div></div><p>See if the term is <code>a = b</code> and the goal is <code>a ∼ b</code> or <code>b ∼ a</code>, with <code>∼</code> reflexive.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.GCongr.exactRefl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.GCongr.exactLeOfLt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean#L243-L244">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.exactLeOfLt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">exactLeOfLt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Tactic/GCongr/ForwardAttr.html#Mathlib.Tactic.GCongr.ForwardExt">Mathlib.Tactic.GCongr.ForwardExt</a></div></div><p>See if the term is <code>a &lt; b</code> and the goal is <code>a ≤ b</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.exactLeOfLt">Mathlib.Tactic.GCongr.exactLeOfLt</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{
    <span class="fn">eval</span> := <span class="fn">fun (<span class="fn">h</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>) (<span class="fn">goal</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">do
      let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../.././Lean/Meta/AppBuilder.html#Lean.Meta.mkAppM">Lean.Meta.mkAppM</a> <span class="fn">`le_of_lt</span> <span class="fn">#[<span class="fn">h</span>]</span></span>
      <span class="fn"><span class="fn"><span class="fn">goal</span>.assignIfDefeq</span> <span class="fn">__do_lift</span></span></span></span> }</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.GCongr.exactLeOfLt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.GCongr.symmExact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean#L247-L248">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.symmExact"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">symmExact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Tactic/GCongr/ForwardAttr.html#Mathlib.Tactic.GCongr.ForwardExt">Mathlib.Tactic.GCongr.ForwardExt</a></div></div><p>See if the term is <code>a ∼ b</code> with <code>∼</code> symmetric and the goal is <code>b ∼ a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.symmExact">Mathlib.Tactic.GCongr.symmExact</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{
    <span class="fn">eval</span> := <span class="fn">fun (<span class="fn">h</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>) (<span class="fn">goal</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">do
      let <span class="fn">__do_lift</span> ← <span class="fn"><span class="fn">goal</span>.applySymm</span>
      <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.assignIfDefeq</span> <span class="fn">h</span></span></span></span> }</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.GCongr.symmExact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.GCongr.exact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean#L250-L251">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.exact"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">exact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Tactic/GCongr/ForwardAttr.html#Mathlib.Tactic.GCongr.ForwardExt">Mathlib.Tactic.GCongr.ForwardExt</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.exact">Mathlib.Tactic.GCongr.exact</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">eval</span> := <span class="fn">fun (<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>) (<span class="fn">m</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn"><span class="fn"><span class="fn">m</span>.assignIfDefeq</span> <span class="fn">e</span></span></span> }</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.GCongr.exact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.gcongrForward"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean#L256-L269">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongrForward"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">gcongrForward</span></a></span><span class="decl_args">
<span class="fn">(hs : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Attempt to resolve an (implicitly) relational goal by one of a provided list of hypotheses,
either with such a hypothesis directly or by a limited palette of relational forward-reasoning from
these hypotheses.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.MVarId.gcongrForward" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.GCongr.gcongrForwardDischarger"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean#L276-L283">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.gcongrForwardDischarger"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">gcongrForwardDischarger</span></a></span><span class="decl_args">
<span class="fn">(goal : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>This is used as the default main-goal discharger,
consisting of running <code><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongrForward">Lean.MVarId.gcongrForward</a></code> (trying a term together with limited
forward-reasoning on that term) on each nontrivial hypothesis.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.GCongr.gcongrForwardDischarger" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.gcongr"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean#L290-L426">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">gcongr</span></a></span><span class="decl_args">
<span class="fn">(g : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(template : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(names : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.binderIdent</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(mainGoalDischarger : <span class="fn"><a href="../../.././Init/Prelude.html#optParam">optParam</a> <span class="fn">(<a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span>)</span> <a href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.gcongrForwardDischarger">Mathlib.Tactic.GCongr.gcongrForwardDischarger</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(sideGoalDischarger : <span class="fn"><a href="../../.././Init/Prelude.html#optParam">optParam</a> <span class="fn">(<a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span>)</span> <a href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.gcongrDischarger">Mathlib.Tactic.GCongr.gcongrDischarger</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Bool">Bool</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.binderIdent</span>)</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span></span>)</span></span></div></div><p>The core of the <code><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr">gcongr</a></code> tactic.  Parse a goal into the form <code>(f _ ... _) ∼ (f _ ... _)</code>,
look up any relevant @[gcongr] lemmas, try to apply them, recursively run the tactic itself on
&quot;main&quot; goals which are generated, and run the discharger on side goals which are generated. If there
is a user-provided template, first check that the template asks us to descend this far into the
match.</p></div></div><div class="decl" id="Mathlib.Tactic.GCongr.tacticGcongr__With__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean#L428-L480">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.tacticGcongr__With__"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">tacticGcongr__With__</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr">gcongr</a></code> tactic applies &quot;generalized congruence&quot; rules, reducing a relational goal
between a LHS and RHS matching the same pattern to relational subgoals between the differing
inputs to the pattern.  For example,</p><pre><code>example {a b x c d : ℝ} (h1 : a + 1 ≤ b + 1) (h2 : c + 2 ≤ d + 2) :
    x ^ 2 * a + c ≤ x ^ 2 * b + d := by
  <a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr">gcongr</a>
  · linarith
  · linarith
</code></pre><p>This example has the goal of proving the relation <code>≤</code> between a LHS and RHS both of the pattern</p><pre><code>x ^ 2 * ?_ + ?_
</code></pre><p>(with inputs <code>a</code>, <code>c</code> on the left and <code>b</code>, <code>d</code> on the right); after the use of
<code><a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr">gcongr</a></code>, we have the simpler goals <code>a ≤ b</code> and <code>c ≤ d</code>.</p><p>A pattern can be provided explicitly; this is useful if a non-maximal match is desired:</p><pre><code>example {a b c d x : ℝ} (h : a + c + 1 ≤ b + d + 1) :
    x ^ 2 * (a + c) + 5 ≤ x ^ 2 * (b + d) + 5 := by
  <a href="../../.././Mathlib/Tactic/GCongr/Core.html#Lean.MVarId.gcongr">gcongr</a> x ^ 2 * ?_ + 5
  linarith
</code></pre><p>The &quot;generalized congruence&quot; rules used are the library lemmas which have been tagged with the
attribute <code>@[gcongr]</code>.  For example, the first example constructs the proof term</p><pre><code>add_le_add (mul_le_mul_of_nonneg_left _ (pow_bit0_nonneg x 1)) _
</code></pre><p>using the generalized congruence lemmas <code>add_le_add</code> and <code>mul_le_mul_of_nonneg_left</code>.</p><p>The tactic attempts to discharge side goals to these &quot;generalized congruence&quot; lemmas (such as the
side goal <code>0 ≤ x ^ 2</code> in the above application of <code>mul_le_mul_of_nonneg_left</code>) using the tactic
<code>gcongr_discharger</code>, which wraps <code>positivity</code> but can also be extended. Side goals not discharged
in this way are left for the user.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.GCongr.tacticGcongr__With__" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.GCongr.«tacticRel[_]»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/GCongr/Core.lean#L482-L504">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.«tacticRel[_]»"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">GCongr</span>.<span class="name">«tacticRel[_]»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code>rel</code> tactic applies &quot;generalized congruence&quot; rules to solve a relational goal by
&quot;substitution&quot;.  For example,</p><pre><code>example {a b x c d : ℝ} (h1 : a ≤ b) (h2 : c ≤ d) :
    x ^ 2 * a + c ≤ x ^ 2 * b + d := by
  rel [h1, h2]
</code></pre><p>In this example we &quot;substitute&quot; the hypotheses <code>a ≤ b</code> and <code>c ≤ d</code> into the LHS <code>x ^ 2 * a + c</code> of
the goal and obtain the RHS <code>x ^ 2 * b + d</code>, thus proving the goal.</p><p>The &quot;generalized congruence&quot; rules used are the library lemmas which have been tagged with the
attribute <code>@[gcongr]</code>.  For example, the first example constructs the proof term</p><pre><code>add_le_add (mul_le_mul_of_nonneg_left h1 (pow_bit0_nonneg x 1)) h2
</code></pre><p>using the generalized congruence lemmas <code>add_le_add</code> and <code>mul_le_mul_of_nonneg_left</code>.  If there are
no applicable generalized congruence lemmas, the tactic fails.</p><p>The tactic attempts to discharge side goals to these &quot;generalized congruence&quot; lemmas (such as the
side goal <code>0 ≤ x ^ 2</code> in the above application of <code>mul_le_mul_of_nonneg_left</code>) using the tactic
<code>gcongr_discharger</code>, which wraps <code>positivity</code> but can also be extended. If the side goals cannot
be discharged in this way, the tactic fails.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.GCongr.«tacticRel[_]»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>