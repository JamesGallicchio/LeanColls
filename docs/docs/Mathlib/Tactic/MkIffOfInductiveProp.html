<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.MkIffOfInductiveProp</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.MkIffOfInductiveProp";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIffOfInductiveProp</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Lean.html">Lean</a></li><li><a href="../.././Mathlib/Lean/Meta.html">Mathlib.Lean.Meta</a></li><li><a href="../.././Mathlib/Lean/Name.html">Mathlib.Lean.Name</a></li><li><a href="../.././Mathlib/Tactic/TypeStar.html">Mathlib.Tactic.TypeStar</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.MkIffOfInductiveProp" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.compactRelation"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">compactRelation</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.mkExistsList"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">mkExistsList</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.mkOpList"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">mkOpList</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.mkAndList"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">mkAndList</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.mkOrList"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">mkOrList</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.List.init"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">List</span>.<span class="name">init</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.Shape"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">Shape</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.constrToProp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">constrToProp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.splitThenConstructor"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">splitThenConstructor</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.toCases"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">toCases</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.nCasesSum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">nCasesSum</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.nCasesProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">nCasesProd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.listBoolMerge"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">listBoolMerge</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.toInductive"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">toInductive</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.mkIffOfInductivePropImpl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">mkIffOfInductivePropImpl</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.mkIff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">mkIff</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.MkIff.mkIffOfInductiveProp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">mkIffOfInductiveProp</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="mk-iff-of-inductive-prop">mk_iff_of_inductive_prop <a class="hover-link" href="#mk-iff-of-inductive-prop">#</a></h1><p>This file defines a command <code>mk_iff_of_inductive_prop</code> that generates <code>iff</code> rules for
inductive <code>Prop</code>s. For example, when applied to <code>List.Chain</code>, it creates a declaration with
the following type:</p><pre><code class="language-lean">∀ {α : Type*} (R : α → α → Prop) (a : α) (l : <a href="../.././Init/Prelude.html#List">List</a> α),
  Chain R a l ↔ l = [] ∨ ∃ (b : α) (l' : <a href="../.././Init/Prelude.html#List">List</a> α), R a b ∧ Chain R b l ∧ l = b :: l'
</code></pre><p>This tactic can be called using either the <code>mk_iff_of_inductive_prop</code> user command or
the <code>mk_iff</code> attribute.</p></div><div class="decl" id="Mathlib.Tactic.MkIff.compactRelation"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L53-L65">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.compactRelation"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">compactRelation</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> →
  <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></span></span></span></div></div><p><code><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.compactRelation">compactRelation</a> bs as_ps</code>: Produce a relation of the form:</p><pre><code class="language-lean">R := fun as ↦ ∃ bs, ⋀_i a_i = p_i[bs]
</code></pre><p>This relation is user-visible, so we compact it by removing each <code>b_j</code> where a <code>p_i = b_j</code>, and
hence <code>a_i = b_j</code>. We need to take care when there are <code>p_i</code> and <code>p_j</code> with <code>p_i = p_j = b_k</code>.</p></div></div><div class="decl" id="Mathlib.Tactic.MkIff.mkExistsList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L74-L83">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkExistsList"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">mkExistsList</span></a></span><span class="decl_args">
<span class="fn">(args : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(inner : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Generates an expression of the form <code>∃ (args), inner</code>. <code>args</code> is assumed to be a list of fvars.
When possible, <code>p ∧ q</code> is used instead of <code>∃ (_ : p), q</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.MkIff.mkExistsList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.MkIff.mkOpList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L87-L90">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOpList"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">mkOpList</span></a></span><span class="decl_args">
<span class="fn">(op : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(empty : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p><code><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOpList">mkOpList</a> op empty [x1, x2, ...]</code> is defined as <code>op x1 (op x2 ...)</code>.
Returns <code>empty</code> if the list is empty.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOpList">Mathlib.Tactic.MkIff.mkOpList</a> <span class="fn">op</span> <span class="fn">empty</span> <span class="fn">[]</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">empty</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOpList">Mathlib.Tactic.MkIff.mkOpList</a> <span class="fn">op</span> <span class="fn">empty</span> <span class="fn">[<span class="fn">e</span>]</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOpList">Mathlib.Tactic.MkIff.mkOpList</a> <span class="fn">op</span> <span class="fn">empty</span> <span class="fn">(<span class="fn">e</span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">es</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Expr.html#Lean.mkApp2">Lean.mkApp2</a> <span class="fn">op</span> <span class="fn">e</span> <span class="fn">(<a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOpList">Mathlib.Tactic.MkIff.mkOpList</a> <span class="fn">op</span> <span class="fn">empty</span> <span class="fn">es</span>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.MkIff.mkOpList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.MkIff.mkAndList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L93-L93">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkAndList"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">mkAndList</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p><code><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkAndList">mkAndList</a> [x1, x2, ...]</code> is defined as <code>x1 ∧ (x2 ∧ ...)</code>, or <code><a href="../.././Init/Prelude.html#True">True</a></code> if the list is empty.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkAndList">Mathlib.Tactic.MkIff.mkAndList</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOpList">Mathlib.Tactic.MkIff.mkOpList</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.mkConst">Lean.mkConst</a> <span class="fn">`And</span>)</span> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.mkConst">Lean.mkConst</a> <span class="fn">`True</span>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.MkIff.mkAndList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.MkIff.mkOrList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L96-L96">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOrList"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">mkOrList</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p><code><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOrList">mkOrList</a> [x1, x2, ...]</code> is defined as <code>x1 ∨ (x2 ∨ ...)</code>, or <code><a href="../.././Init/Prelude.html#False">False</a></code> if the list is empty.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOrList">Mathlib.Tactic.MkIff.mkOrList</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkOpList">Mathlib.Tactic.MkIff.mkOpList</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.mkConst">Lean.mkConst</a> <span class="fn">`Or</span>)</span> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.mkConst">Lean.mkConst</a> <span class="fn">`False</span>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.MkIff.mkOrList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.MkIff.List.init"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L99-L102">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.List.init"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">List</span>.<span class="name">init</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></span></div></div><p>Drops the final element of a list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.List.init">Mathlib.Tactic.MkIff.List.init</a> <span class="fn">[]</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">[]</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.List.init">Mathlib.Tactic.MkIff.List.init</a> <span class="fn">[<span class="fn">head</span>]</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">[]</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.List.init">Mathlib.Tactic.MkIff.List.init</a> <span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.List.init">Mathlib.Tactic.MkIff.List.init</a> <span class="fn">l</span></span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.MkIff.List.init" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.MkIff.Shape"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L106-L130">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">Shape</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Auxiliary data associated with a single constructor of an inductive declaration.</p><ul class="structure_fields" id="Mathlib.Tactic.MkIff.Shape.mk"><li id="Mathlib.Tactic.MkIff.Shape.variablesKept" class="structure_field"><div class="structure_field_info">variablesKept : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div><div class="structure_field_doc"><p>For each forall-bound variable in the type of the constructor, minus
the &quot;params&quot; that apply to the entire inductive type, this list contains <code>true</code>
if that variable has been kept after <code><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.compactRelation">compactRelation</a></code>.</p><p>For example, <code>List.Chain.nil</code> has type</p><pre><code class="language-lean">  ∀ {α : Type u_1} {R : α → α → Prop} {a : α}, List.Chain R a []`
</code></pre><p>and the first two variables <code>α</code> and <code>R</code> are &quot;params&quot;, while the <code>a : α</code> gets
eliminated in a <code><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.compactRelation">compactRelation</a></code>, so <code><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.variablesKept">variablesKept</a> = [false]</code>.</p><p><code>List.Chain.cons</code> has type</p><pre><code class="language-lean">  ∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : <a href="../.././Init/Prelude.html#List">List</a> α},
     R a b → List.Chain R b l → List.Chain R a (b :: l)
</code></pre><p>and the <code>a : α</code> gets eliminated, so <code><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape.variablesKept">variablesKept</a> = [false,true,true,true,true]</code>.</p></div></li><li id="Mathlib.Tactic.MkIff.Shape.neqs" class="structure_field"><div class="structure_field_info">neqs : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Init/Prelude.html#Nat">Nat</a></span></div><div class="structure_field_doc"><p>The number of equalities, or <code>none</code> in the case when we've reduced something
of the form <code>p ∧ <a href="../.././Init/Prelude.html#True">True</a></code> to just <code>p</code>.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.MkIff.Shape" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.MkIff.constrToProp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L135-L165">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.constrToProp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">constrToProp</span></a></span><span class="decl_args">
<span class="fn">(univs : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(params : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(idxs : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape">Mathlib.Tactic.MkIff.Shape</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></div></div><p>Converts an inductive constructor <code>c</code> into a <code><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape">Shape</a></code> that will be used later in
while proving the iff theorem, and a proposition representing the constructor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.MkIff.constrToProp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.MkIff.splitThenConstructor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L170-L184">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.splitThenConstructor"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">splitThenConstructor</span></a></span><span class="decl_args">
<span class="fn">(mvar : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Splits the goal <code>n</code> times via <code>refine ⟨?_,?_⟩</code>, and then applies <code>constructor</code> to
close the resulting subgoals.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.MkIff.splitThenConstructor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.MkIff.toCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L189-L205">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.toCases"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">toCases</span></a></span><span class="decl_args">
<span class="fn">(mvar : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(shape : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape">Mathlib.Tactic.MkIff.Shape</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Proves the left to right direction of a generated iff theorem.
<code>shape</code> is the output of a call to <code><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.constrToProp">constrToProp</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.MkIff.toCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.MkIff.nCasesSum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L210-L218">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.nCasesSum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">nCasesSum</span></a></span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(mvar : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <a href="../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span>)</span></span></div></div><p>Calls <code>cases</code> on <code>h</code> (assumed to be a binary sum) <code>n</code> times, and returns
the resulting subgoals and their corresponding new hypotheses.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.nCasesSum">Mathlib.Tactic.MkIff.nCasesSum</a> <span class="fn">0</span> <span class="fn">mvar</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">[<span class="fn">(<span class="fn">h</span>, <span class="fn">mvar</span>)</span>]</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.MkIff.nCasesSum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.MkIff.nCasesProd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L223-L230">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.nCasesProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">nCasesProd</span></a></span><span class="decl_args">
<span class="fn">(n : <a href="../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(mvar : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <a href="../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a></span>)</span></span></div></div><p>Calls <code>cases</code> on <code>h</code> (assumed to be a binary product) <code>n</code> times, and returns
the resulting subgoal and the new hypotheses.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.nCasesProd">Mathlib.Tactic.MkIff.nCasesProd</a> <span class="fn">0</span> <span class="fn">mvar</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn">mvar</span>, <span class="fn">[<span class="fn">h</span>]</span>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.MkIff.nCasesProd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.MkIff.listBoolMerge"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L242-L246">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.listBoolMerge"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">listBoolMerge</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span>)</span></span></span></span></div></div><p>Iterate over two lists, if the first element of the first list is <code>false</code>, insert <code>none</code> into the
result and continue with the tail of first list. Otherwise, wrap the first element of the second
list with <code>some</code> and continue with the tails of both lists. Return when either list is empty.</p><p>Example:</p><pre><code><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.listBoolMerge">listBoolMerge</a> [false, true, false, true] [0, 1, 2, 3, 4] = [none, (some 0), none, (some 1)]
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.listBoolMerge">Mathlib.Tactic.MkIff.listBoolMerge</a> <span class="fn">[]</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">[]</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.listBoolMerge">Mathlib.Tactic.MkIff.listBoolMerge</a> <span class="fn">(<a href="../.././Init/Prelude.html#Bool.false">false</a> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">xs</span>)</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">none</span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.listBoolMerge">Mathlib.Tactic.MkIff.listBoolMerge</a> <span class="fn">xs</span> <span class="fn">x</span></span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.listBoolMerge">Mathlib.Tactic.MkIff.listBoolMerge</a> <span class="fn">(<a href="../.././Init/Prelude.html#Bool.true">true</a> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">xs</span>)</span> <span class="fn">(<span class="fn">y</span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">ys</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Option.some">some</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.listBoolMerge">Mathlib.Tactic.MkIff.listBoolMerge</a> <span class="fn">xs</span> <span class="fn">ys</span></span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.listBoolMerge">Mathlib.Tactic.MkIff.listBoolMerge</a> <span class="fn">(<a href="../.././Init/Prelude.html#Bool.true">true</a> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">tail</span>)</span> <span class="fn">[]</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">[]</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.MkIff.listBoolMerge" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.MkIff.toInductive"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L250-L290">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.toInductive"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">toInductive</span></a></span><span class="decl_args">
<span class="fn">(mvar : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(cs : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(gs : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.Shape">Mathlib.Tactic.MkIff.Shape</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <a href="../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Proves the right to left direction of a generated iff theorem.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.MkIff.toInductive" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.MkIff.mkIffOfInductivePropImpl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L294-L334">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIffOfInductivePropImpl"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">mkIffOfInductivePropImpl</span></a></span><span class="decl_args">
<span class="fn">(ind : <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(rel : <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(relStx : <a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Implementation for both <code>mk_iff</code> and <code>mk_iff_of_inductive_prop</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.MkIff.mkIffOfInductivePropImpl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.MkIff.mkIff"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L336-L375">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">mkIff</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Applying the <code>mk_iff</code> attribute to an inductively-defined proposition <code>mk_iff</code> makes an <code>iff</code> rule
<code>r</code> with the shape <code>∀ps is, i as ↔ ⋁_j, ∃cs, is = cs</code>, where <code>ps</code> are the type parameters, <code>is</code> are
the indices, <code>j</code> ranges over all possible constructors, the <code>cs</code> are the parameters for each of the
constructors, and the equalities <code>is = cs</code> are the instantiations for each constructor for each of
the indices to the inductive type <code>i</code>.</p><p>In each case, we remove constructor parameters (i.e. <code>cs</code>) when the corresponding equality would
be just <code>c = i</code> for some index <code>i</code>.</p><p>For example, if we try the following:</p><pre><code class="language-lean">@[mk_iff]
structure Foo (m n : Nat) : Prop where
  equal : m = n
  sum_eq_two : m + n = 2
</code></pre><p>Then <code>#check foo_iff</code> returns:</p><pre><code class="language-lean">foo_iff : ∀ (m n : Nat), Foo m n ↔ m = n ∧ m + n = 2
</code></pre><p>You can add an optional string after <code>mk_iff</code> to change the name of the generated lemma.
For example, if we try the following:</p><pre><code class="language-lean">@[mk_iff bar]
structure Foo (m n : Nat) : Prop where
  equal : m = n
  sum_eq_two : m + n = 2
</code></pre><p>Then <code>#check bar</code> returns:</p><pre><code class="language-lean">bar : ∀ (m n : ℕ), Foo m n ↔ m = n ∧ m + n = 2
</code></pre><p>See also the user command <code>mk_iff_of_inductive_prop</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.MkIff.mkIff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.MkIff.mkIffOfInductiveProp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/20c73142afa995ac9c8fb80a9bb585a55ca38308/Mathlib/Tactic/MkIffOfInductiveProp.lean#L377-L396">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html#Mathlib.Tactic.MkIff.mkIffOfInductiveProp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">MkIff</span>.<span class="name">mkIffOfInductiveProp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>mk_iff_of_inductive_prop i r</code> makes an <code>iff</code> rule for the inductively-defined proposition <code>i</code>.
The new rule <code>r</code> has the shape <code>∀ps is, i as ↔ ⋁_j, ∃cs, is = cs</code>, where <code>ps</code> are the type
parameters, <code>is</code> are the indices, <code>j</code> ranges over all possible constructors, the <code>cs</code> are the
parameters for each of the constructors, and the equalities <code>is = cs</code> are the instantiations for
each constructor for each of the indices to the inductive type <code>i</code>.</p><p>In each case, we remove constructor parameters (i.e. <code>cs</code>) when the corresponding equality would
be just <code>c = i</code> for some index <code>i</code>.</p><p>For example, <code>mk_iff_of_inductive_prop</code> on <code>List.Chain</code> produces:</p><pre><code class="language-lean">∀ { α : Type*} (R : α → α → Prop) (a : α) (l : <a href="../.././Init/Prelude.html#List">List</a> α),
  Chain R a l ↔ l = [] ∨ ∃(b : α) (l' : <a href="../.././Init/Prelude.html#List">List</a> α), R a b ∧ Chain R b l ∧ l = b :: l'
</code></pre><p>See also the <code>mk_iff</code> user attribute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.MkIff.mkIffOfInductiveProp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>